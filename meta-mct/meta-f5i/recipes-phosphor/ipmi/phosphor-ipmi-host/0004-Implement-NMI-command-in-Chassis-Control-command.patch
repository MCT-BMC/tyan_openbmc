From 2eb817f70587afb7175302e051b7cd71f7d16246 Mon Sep 17 00:00:00 2001
From: Mirage Su <mirage.su@mic.com.tw>
Date: Fri, 15 Nov 2019 15:49:29 +0800
Subject: [PATCH] Implement NMI command in Chassis Control command.

---
 chassishandler.cpp | 63 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)

diff --git a/chassishandler.cpp b/chassishandler.cpp
index dc672a5..477e916 100755
--- a/chassishandler.cpp
+++ b/chassishandler.cpp
@@ -767,6 +767,65 @@ int initiate_state_transition(State::Host::Transition transition)
     return rc;
 }
 
+//------------------------------------------
+// Set Enabled property to inform NMI source
+// handling to trigger a NMI_OUT BSOD.
+//------------------------------------------
+int setNmiProperty(const bool value)
+{
+#if 0
+    constexpr const char* nmiSourceObjPath =
+        "/xyz/openbmc_project/Chassis/Control/NMISource";
+    constexpr const char* nmiSourceIntf =
+        "xyz.openbmc_project.Chassis.Control.NMISource";
+    std::string bmcSourceSignal = "xyz.openbmc_project.Chassis.Control."
+                                  "NMISource.BMCSourceSignal.ChassisCmd";
+    std::shared_ptr<sdbusplus::asio::connection> busp = getSdBus();
+
+    try
+    {
+        auto service = ipmi::getService(*busp, nmiSourceIntf, nmiSourceObjPath);
+        ipmi::setDbusProperty(*busp, service, nmiSourceObjPath, nmiSourceIntf,
+                              "BMCSource", bmcSourceSignal);
+        ipmi::setDbusProperty(*busp, service, nmiSourceObjPath, nmiSourceIntf,
+                              "Enabled", value);
+    }
+    catch (std::exception& e)
+    {
+        log<level::ERR>("Failed to trigger NMI_OUT",
+                        entry("EXCEPTION=%s", e.what()));
+        return -1;
+    }
+
+    return 0;
+#endif
+    char command[100];
+    int rc = 0;
+
+    sprintf(command, "echo 317 > /sys/class/gpio/export");
+    rc = system(command);
+    if (rc != 0)
+    {
+        return rc;
+    }
+
+    sprintf(command, "echo out > /sys/class/gpio/gpio317/direction; sleep 1; echo in > /sys/class/gpio/gpio317/direction;");
+    rc = system(command);
+    if (rc != 0)
+    {
+        return rc;
+    }
+
+    sprintf(command, "echo 317 > /sys/class/gpio/unexport");
+    rc = system(command);
+    if (rc != 0)
+    {
+        return rc;
+    }
+
+    return rc;
+}
+
 namespace power_policy
 {
 
@@ -1174,6 +1233,10 @@ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
             rc = initiate_state_transition(State::Host::Transition::Off);
             break;
 
+        case CMD_PULSE_DIAGNOSTIC_INTR:
+            rc = setNmiProperty(true);
+            break;
+
         default:
         {
             log<level::ERR>("Invalid Chassis Control command",
