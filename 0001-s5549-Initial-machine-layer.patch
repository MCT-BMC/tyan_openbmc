From f170e966fd29665ae04695a3c2bc55b52c2abe2a Mon Sep 17 00:00:00 2001
From: John Chung <john.chung@mic.com.tw>
Date: Thu, 17 Dec 2020 17:51:58 +0800
Subject: [PATCH 1/2] [s5549] Initial machine layer

Differential Revision: http://10.99.241.45/D1501
---
 meta-mct/meta-s5549/conf/.vscode/settings.json     |   73 +
 meta-mct/meta-s5549/conf/bblayers.conf.sample      |   22 +
 meta-mct/meta-s5549/conf/conf-notes.txt            |    2 +
 meta-mct/meta-s5549/conf/distro/s5549-pass.conf    |    3 +
 .../meta-s5549/conf/distro/twitter-obmc-s5549.conf |    2 +
 meta-mct/meta-s5549/conf/layer.conf                |   10 +
 meta-mct/meta-s5549/conf/local.conf.sample         |  241 +++
 meta-mct/meta-s5549/conf/machine/s5549.conf        |   21 +
 .../0001-Light-BMC-Heartbeat-LED.patch             |   42 +
 .../0002-Set-the-default-UART-route-setting.patch  |   42 +
 .../u-boot-aspeed/0003-get-mac-from-eeprom.patch   |   94 ++
 .../0004-Set-BMC-RTL8211E-PHY-LED.patch            |   66 +
 .../0005-Set-the-default-ACPI-setting.patch        |   42 +
 .../u-boot/u-boot-aspeed_2016.07.bbappend          |    9 +
 .../dbus/0001-Set-the-limit-size-for-dbus.patch    |   28 +
 .../meta-s5549/recipes-core/dbus/dbus_%.bbappend   |    4 +
 .../meta-s5549/recipes-core/ipmi/ipmi-providers.bb |   32 +
 .../recipes-core/os-release/os-release.bbappend    |   16 +
 .../recipes-core/systemd/obmc-targets.bbappend     |    3 +
 .../obmc-targets/obmc-chassis-reset@.target        |    6 +
 .../recipes-extended/pam/pam-ipmi/ipmi_pass        |  Bin 0 -> 160 bytes
 .../recipes-extended/pam/pam-ipmi_git.bbappend     |   10 +
 ...nal-and-extend-set_property-methods-to-db.patch |   61 +
 .../sdbusplus/sdbusplus_git.bbappend               |    4 +
 .../0001-Force-baseboard-FRU-to-ID0.patch          |   25 +
 .../recipes-intel/ipmi/intel-ipmi-oem_git.bbappend |    5 +
 .../0004-Set-RTD_1_2_3-to-thermistor-mode.patch    |   28 +
 .../0005-Support-IPMB-in-OpenBMC.patch             |  426 ++++++
 .../0006-Modified-ibm-cffps-driver.patch           |   24 +
 ...n-sensor-disappear-when-power-off-problem.patch |   26 +
 .../linux-aspeed/0008-increase-rofs-space.patch    |   28 +
 ...ter-all-of-dimm-sensors-when-initializing.patch |   25 +
 ...-change-aspeed-rpm-driver-to-falling-edge.patch |   37 +
 .../linux/linux-aspeed/aspeed-bmc-mct-s5549.dts    |  380 +++++
 .../recipes-kernel/linux/linux-aspeed/s5549.cfg    |   66 +
 .../recipes-kernel/linux/linux-aspeed_git.bbappend |   13 +
 .../recipes-phosphor/bios/bios-update.bb           |   49 +
 .../org.openbmc.control.BiosFlash.service          |   15 +
 .../recipes-phosphor/bios/files/Makefile           |    1 +
 .../recipes-phosphor/bios/files/bios-update        |  130 ++
 .../recipes-phosphor/bios/files/bios_update.py     |  310 ++++
 .../recipes-phosphor/bios/files/image-active       |   29 +
 .../bios/files/org.openbmc.control.BiosFlash.conf  |    8 +
 .../meta-s5549/recipes-phosphor/bios/files/py.mk   |    9 +
 .../recipes-phosphor/bios/files/setup.cfg          |    4 +
 .../recipes-phosphor/bios/files/setup.py           |    7 +
 .../recipes-phosphor/bios/files/update_bios.sh     |   36 +
 ...0001-leave-gpood-monitor-to-other-service.patch |   74 +
 .../chassis/obmc-op-control-power_git.bbappend     |    6 +
 .../0001-add-SEL-log-for-Power-Button-Press.patch  |   62 +
 .../0002-Add-Power-button-override-SEL.patch       |   54 +
 ...r-button-and-reset-button-press-and-long-.patch |   68 +
 ...Write-to-SEL-when-reset-button-is-pressed.patch |   45 +
 ...vent-issue-for-the-power-and-reset-button.patch |  148 ++
 .../chassis/obmc-phosphor-buttons_git.bbappend     |    9 +
 .../0001-Support-baseboard-fru-reading.patch       |  116 ++
 .../0003-support-fru-write-offset.patch            |   29 +
 .../0004-fix-fsc-to-settable-interface.patch       |   24 +
 .../0004-workaroud-for-fru-edit.patch              |   80 +
 .../0005-remove-NVME-P4000.json.patch              |   73 +
 ...ityManager-service-booting-after-FruDevic.patch |   24 +
 .../entity-manager/Chicony-R550-PSU.json           |  157 ++
 .../configuration/entity-manager/Common-PSU.json   |   27 +
 .../entity-manager/Delta-DPS-500AB-PSU.json        |   27 +
 .../entity-manager/Delta-DPS-550AB-PSU.json        |  157 ++
 .../entity-manager/Delta-DPS-650AB-PSU.json        |   27 +
 .../entity-manager/Intel-V710-NIC.json             |   34 +
 .../configuration/entity-manager/blacklist.json    |    3 +
 .../entity-manager/s5549-Baseboard.json            | 1262 +++++++++++++++
 .../configuration/entity-manager_git.bbappend      |   20 +
 .../configuration/entity-rescan.bb                 |   24 +
 .../entity-rescan/entity-rescan.service            |   14 +
 .../configuration/entity-rescan/entity_rescan.sh   |   14 +
 ...rt-preparing-and-stop-commnad-configurati.patch |   93 ++
 .../0002-Add-timestamps-to-SOL-buffer.patch        |  102 ++
 .../console/obmc-console/obmc-console-ssh@.service |   14 +
 .../console/obmc-console/obmc-console.conf         |    8 +
 .../console/obmc-console_%.bbappend                |    8 +
 .../0002-Add-interface-for-caterr-logging.patch    |   46 +
 ...-SOL-PATTERN-Interface-for-SOL-Processing.patch |   37 +
 ...interface-for-AC-restore-always-on-policy.patch |   54 +
 ...face-for-setting-specified-service-status.patch |   28 +
 ...watchdog-initialized-flag-true-as-default.patch |   22 +
 .../0007-Add-interface-for-DCMI-power.patch        |   54 +
 ...dog-initialized-action-to-None-as-default.patch |   25 +
 ...sion-ID-parameter-to-software-version-int.patch |   30 +
 .../dbus/phosphor-dbus-interfaces_git.bbappend     |   12 +
 .../dbus/phosphor-dbus-monitor-config.bbappend     |    1 +
 .../meta-s5549/recipes-phosphor/event/bmc-sel.bb   |   29 +
 .../recipes-phosphor/event/bmc-sel/bmc-sel.sh      |   33 +
 .../event/bmc-sel/obmc-bmc-sel.service             |   13 +
 .../recipes-phosphor/event/bmc-sel/psu-sel.service |   13 +
 .../recipes-phosphor/event/bmc-sel/psu-sel.sh      |  118 ++
 .../event/mct-event-policy-native.bb               |   14 +
 .../event/mct-event-policy/caterr_event.yaml       |   50 +
 .../0001-remove-the-sesnor-data-scaling.patch      |   27 +
 .../0002-Fan-speed-control.patch                   | 1100 ++++++++++++++
 ...-fix-Tjmax-change-don-t-take-effect-issue.patch |   25 +
 .../0004-Fix-the-pid-coredump-issue.patch          |  201 +++
 .../0005-fix-typo-of-fan-control.patch             |   53 +
 ...-fixed-increase-and-decrease-refresh-time.patch |  107 ++
 .../phosphor-pid-control.service                   |   17 +
 .../fans/phosphor-pid-control_%.bbappend           |   12 +
 .../fans/phosphor-pid-control_git.bbappend         |   10 +
 .../recipes-phosphor/gpio-init/files/Makefile.am   |    7 +
 .../recipes-phosphor/gpio-init/files/bootstrap.sh  |   20 +
 .../recipes-phosphor/gpio-init/files/configure.ac  |   33 +
 .../gpio-init/files/gpio-initial-config.json       |   56 +
 .../gpio-init/files/gpio-initial.cpp               |   88 ++
 .../gpio-init/files/gpio-initial.hpp               |   27 +
 .../gpio-init/files/gpio-initial.service           |   10 +
 .../gpio-init/files/gpio-initial.sh                |  247 +++
 .../recipes-phosphor/gpio-init/gpio-initial.bb     |   48 +
 .../recipes-phosphor/gpio/button-monitor.bb        |   37 +
 .../gpio/button-monitor/CMakeLists.txt             |   34 +
 .../gpio/button-monitor/power-button-monitor.cpp   |  130 ++
 .../gpio/button-monitor/power-button-monitor.hpp   |   33 +
 .../button-monitor/power-button-monitor.service    |   12 +
 .../gpio/button-monitor/reset-button-monitor.cpp   |  130 ++
 .../gpio/button-monitor/reset-button-monitor.hpp   |   33 +
 .../button-monitor/reset-button-monitor.service    |   12 +
 .../recipes-phosphor/gpio/button-monitor/util.hpp  |  188 +++
 .../recipes-phosphor/gpio/button-state.bb          |   22 +
 .../gpio/button-state/id-button-pressed.service    |   10 +
 .../gpio/button-state/toggle_identify_led.sh       |   21 +
 .../meta-s5549/recipes-phosphor/gpio/cpu-state.bb  |   56 +
 .../recipes-phosphor/gpio/cpu-state/CMakeLists.txt |   38 +
 .../recipes-phosphor/gpio/cpu-state/LICENSE        |  201 +++
 .../gpio/cpu-state/caterrHandler.cpp               |  145 ++
 .../gpio/cpu-state/obmc/gpio/prochot0              |    6 +
 .../gpio/cpu-state/obmc/gpio/prochot0_deassert     |    5 +
 .../gpio/cpu-state/obmc/gpio/prochot1              |    6 +
 .../gpio/cpu-state/obmc/gpio/prochot1_deassert     |    5 +
 .../gpio/cpu-state/prochot_thermtrip_update.sh     |   23 +
 .../cpu-state/xyz.openbmc_project.caterr.service   |    8 +
 .../cpu-state/xyz.openbmc_project.prochot0.service |   10 +
 .../xyz.openbmc_project.prochot0_deassert.service  |   10 +
 .../cpu-state/xyz.openbmc_project.prochot1.service |   10 +
 .../xyz.openbmc_project.prochot1_deassert.service  |   10 +
 .../xyz.openbmc_project.thermtrip.service          |    8 +
 .../0001-Support-GPIO-interrupt.patch              |  154 ++
 .../0002-init-host-status.patch                    |   68 +
 ...debug-log-and-change-service-enable-metho.patch |   40 +
 .../phosphor-gpio-monitor@.service                 |    9 +
 .../phosphor-multi-gpio-monitor.service            |   22 +
 .../gpio/phosphor-gpio-monitor/s5549_gpio.json     |   69 +
 .../gpio/phosphor-gpio-monitor_git.bbappend        |   19 +
 .../recipes-phosphor/gpio/power-state.bb           |   24 +
 .../power-state/SetPowerGoodPropertyOff.service    |    6 +
 .../power-state/SetPowerGoodPropertyOn.service     |    7 +
 .../gpio/power-state/setPowerProperty.sh           |   47 +
 .../hbled-ctrl/files/hbled_blink.sh                |    9 +
 .../hbled-ctrl/files/obmc-hbled.service            |   15 +
 .../recipes-phosphor/hbled-ctrl/hbled-ctrl.bb      |   25 +
 .../images/obmc-phosphor-image.bbappend            |   36 +
 .../initrdscripts/obmc-phosphor-initfs.bbappend    |    1 +
 .../obmc-phosphor-initfs/obmc-shutdown.sh          |  112 ++
 .../obmc-phosphor-initfs/obmc-update.sh            |  285 ++++
 .../bmcweb/0001-Support-rest-API-for-MCT-OEM.patch |   62 +
 ...02-Fix-the-issue-for-update-bmcweb-recipe.patch |  310 ++++
 ...t-the-SEL-feature-for-redfish-log-service.patch | 1604 ++++++++++++++++++++
 .../interfaces/bmcweb/mct_oem_rest.hpp             |  246 +++
 .../interfaces/bmcweb_git.bbappend                 |   29 +
 .../ipmi/phosphor-ipmi-config.bbappend             |   13 +
 .../ipmi/phosphor-ipmi-config/channel_config.json  |  178 +++
 .../ipmi/phosphor-ipmi-config/dcmi_cap.json        |   17 +
 .../ipmi/phosphor-ipmi-config/dcmi_sensors.json    |   13 +
 .../ipmi/phosphor-ipmi-config/dev_id.json          |    2 +
 .../ipmi/phosphor-ipmi-config/power_reading.json   |    3 +
 .../ipmi/phosphor-ipmi-config/sdr.json             |  136 ++
 ...nt-NMI-command-in-Chassis-Control-command.patch |   57 +
 ...ve-Unspecified-ip-source-from-static-to-D.patch |   30 +
 .../0006-add-power-diag-log.patch                  |   44 +
 .../0007-fix-set-static-ip-fail-issue.patch        |   24 +
 .../0008-add-ARP-control-status.patch              |   45 +
 ...-ipmit-power-reset-from-dc-cycle-to-reset.patch |   29 +
 ...ot-type-setting-in-system-boot-option-fea.patch |   48 +
 .../0011-fix-warm-reset-command.patch              |   40 +
 ...ion-flags-unexpected-status-in-get-watchd.patch |   30 +
 ...ower-control-SEL-generated-in-chassis-con.patch |  130 ++
 ...he-DCMI-power-reading-and-power-limit-com.patch |  403 +++++
 ...0015-Add-debug-message-for-watchdog-reset.patch |   24 +
 ...-Session-Info-to-use-new-yielding-D-Bus-A.patch |  380 +++++
 ...rong-field-value-for-session-info-commnad.patch |  212 +++
 .../0018-Add-the-detect-for-firmare-revision.patch |   29 +
 ...r-control-until-pervious-action-completed.patch |  155 ++
 .../ipmi/phosphor-ipmi-host_%.bbappend             |    5 +
 .../ipmi/phosphor-ipmi-host_git.bbappend           |   21 +
 .../ipmi/phosphor-ipmi-ipmb/ipmb-channels.json     |   10 +
 .../ipmi/phosphor-ipmi-ipmb_git.bbappend           |    9 +
 .../0001-IPMB-support-for-NM-commands.patch        |   50 +
 .../0002-Display-debug-messsage-for-KCS.patch      |   25 +
 .../ipmi/phosphor-ipmi-kcs_git.bbappend            |    6 +
 ...ve-HMAC-SHA1-from-Authentication-Integrit.patch |   43 +
 ...ax-size-limit-feature-to-SOL-Console-data.patch |   39 +
 .../ipmi/phosphor-ipmi-net_git.bbappend            |    7 +
 .../ipmi/s5549-ipmi-sensor-map-native.bb           |   24 +
 .../ipmi/s5549-ipmi-sensor-map/config.yaml         |  289 ++++
 .../leds/mct-led-manager-config-native.bb          |   19 +
 .../leds/mct-led-manager-config/led.yaml           |   39 +
 .../recipes-phosphor/mct-dcmi/mct-dcmi-power.bb    |   41 +
 .../mct-dcmi/mct-dcmi-power/LICENSE                |  201 +++
 .../mct-dcmi/mct-dcmi-power/Makefile.am            |   13 +
 .../mct-dcmi/mct-dcmi-power/bootstrap.sh           |   20 +
 .../mct-dcmi/mct-dcmi-power/configure.ac           |   35 +
 .../mct-dcmi/mct-dcmi-power/mct-dcmi-power.cpp     |  390 +++++
 .../mct-dcmi/mct-dcmi-power/mct-dcmi-power.hpp     |  133 ++
 .../mct-dcmi/mct-dcmi-power/mct-dcmi-power.service |   13 +
 .../mct-dcmi/mct-dcmi-power/utils.hpp              |  215 +++
 .../mct-default-action/files/default-pwm.service   |   15 +
 .../mct-default-action/files/default-pwm.sh        |   21 +
 .../mct-default-action/files/disable-sw2.service   |   14 +
 .../mct-default-action/files/disable-sw2.sh        |   49 +
 .../mct-default-action/files/initFruFlag.service   |   15 +
 .../mct-default-action/files/initFruFlag.sh        |    8 +
 .../mct-default-action/files/relinkLan.sh          |    5 +
 .../files/restartNetIpmi.service                   |   17 +
 .../mct-default-action/files/restartNetIpmi.sh     |   40 +
 .../mct-default-action/files/writeFRU.sh           |   20 +
 .../mct-default-action/mct-default-action.bb       |   32 +
 .../mct-ipmi-oem/files/CMakeLists.txt              |   58 +
 .../recipes-phosphor/mct-ipmi-oem/files/LICENSE    |  202 +++
 .../recipes-phosphor/mct-ipmi-oem/files/oemcmd.cpp | 1576 +++++++++++++++++++
 .../recipes-phosphor/mct-ipmi-oem/files/oemcmd.hpp |   35 +
 .../recipes-phosphor/mct-ipmi-oem/mct-ipmi-oem.bb  |   35 +
 .../mct-powerctrl/files/host-gpio.service          |    9 +
 .../mct-powerctrl/files/host-powercyclelog.service |   13 +
 .../mct-powerctrl/files/host-poweroff.service      |   14 +
 .../mct-powerctrl/files/host-poweron.service       |   14 +
 .../mct-powerctrl/files/host-powerreset.service    |   13 +
 .../mct-powerctrl/files/init_once.sh               |    6 +
 .../mct-powerctrl/files/powercyclelog.sh           |   10 +
 .../mct-powerctrl/files/poweroff.sh                |   26 +
 .../mct-powerctrl/files/poweron.sh                 |   29 +
 .../mct-powerctrl/files/powerreset.sh              |   27 +
 .../mct-powerctrl/mct-powerctrl.bb                 |   32 +
 ...Add-try-and-catch-to-system-configuration.patch |   58 +
 .../network/phosphor-network_%.bbappend            |    4 +
 .../packagegroups/packagegroup-mct-apps.bbappend   |    4 +
 .../phosphor-u-boot-mgr/phosphor-u-boot-mgr_git.bb |   18 +
 .../register/mct-register-monitor.bb               |   42 +
 .../register/mct-register-monitor/LICENSE          |  201 +++
 .../register/mct-register-monitor/Makefile.am      |   15 +
 .../register/mct-register-monitor/bootstrap.sh     |   20 +
 .../register/mct-register-monitor/configure.ac     |   37 +
 .../mct-register-monitor/lpc-interrupt-monitor.cpp |  197 +++
 .../mct-register-monitor/lpc-interrupt-monitor.hpp |   74 +
 .../lpc-interrupt-monitor.service                  |   16 +
 .../register/mct-register-monitor/utils.hpp        |  194 +++
 .../0001-Add-CATERR-sel-log-monitor.patch          |  264 ++++
 ...ge-ipmi_sel-location-to-persistent-folder.patch |   22 +
 .../0002-Alert-led-when-happen-warning.patch       |   65 +
 ...nsor-reading-not-match-assert-value-issue.patch |   31 +
 ...Bypass-SYS-Air-Inlet-sensor-for-alert-led.patch |   47 +
 .../sel-logger/phosphor-sel-logger_git.bbappend    |   13 +
 .../0001-add-supported-pmbus-name-cffps1.patch     |   28 +
 ...FAN-threshold-event-during-power-transiti.patch |   61 +
 ...w-processor-sensor-to-replace-gpio-sensor.patch |  243 +++
 .../0004-support-ipmi-ACPI-sensor.patch            |  216 +++
 .../dbus-sensors/0005-add-event-sensor.patch       |  187 +++
 .../0006-Add-OCP-NIC-temperature-sensor.patch      |  191 +++
 .../0007-add-necessary-event-sensors-in-dbus.patch |   31 +
 .../0011-Add-OCP-NIC-temperature-sensor.patch      |   38 +
 .../0013-add-ipmi-power-status-sensor.patch        |  211 +++
 .../0015-hidden-peci-core-temperature-sensor.patch |   29 +
 .../0017-Enabling-NVMe-sensor-support.patch        |  545 +++++++
 .../0018-change-power-match-to-pgood-event.patch   |   76 +
 ...ify-temp-and-Die-sensor-threshold-setting.patch |  119 ++
 .../dbus-sensors/0020-Add-prochot-sensor.patch     |   37 +
 ...valid-Value-property-for-power-on-sensors.patch |   91 ++
 ...nsors-to-support-the-invalid-value-proper.patch |  663 ++++++++
 .../dbus-sensors/0023-Add-thermtrip-sensor.patch   |   33 +
 .../0024-disable-PSU-PWM-detecting.patch           |   29 +
 .../0025-Add-VR-MOS-Margin-sensor.patch            |  485 ++++++
 .../0026-support-leaky-bucket-sensor.patch         |  341 +++++
 ...reading-unavailable-bit-if-nvme-is-not-pr.patch |  141 ++
 ...sor-reading-unavailable-bit-for-VR-sensor.patch |   75 +
 .../0031-Fix-the-cpu-sensor-display.patch          |   58 +
 .../dbus-sensors/0032-mct-NVMe-sensor.patch        |  558 +++++++
 ...e-sensor-debug-message-with-using-debug-f.patch |   28 +
 ...or-data-update-error-after-code-base-upda.patch |   48 +
 ...0035-Fix-CPU-DTS-margin-reading-incorrect.patch |   70 +
 .../0036-Fix-sensor-hysteresis-issue.patch         |  124 ++
 ...pu-sensor-hang-and-get-power-status-error.patch |  179 +++
 ...-watchdog2-and-power-control-event-sensor.patch |   30 +
 .../0039-Add-DCMI-power-event-sensor.patch         |   26 +
 .../0040-change-ADC-range-to-be-configurable.patch |   80 +
 .../0041-add-assert-value-to-log-event-data.patch  |   71 +
 ...he-timer-when-the-deasserted-events-occur.patch |  106 ++
 .../0043-add-offset-value-for-E810-OCP-card.patch  |  118 ++
 ...044-log-assert-event-when-timer-cancelled.patch |   28 +
 .../0045-filter-out-invalidate-ADC-value.patch     |   36 +
 .../0046-add-BMC-watchdog-timeout-SEL.patch        |   90 ++
 ...invalidate-MOS-temperature-value-and-add-.patch |   76 +
 .../0048-Add-event-disabled-event-sensor.patch     |   26 +
 ...filter-out-invalidate-sys-air-inlet-value.patch |   35 +
 .../0050-Update-BMC-watchdog-timeout-SEL.patch     |   44 +
 ...ement-the-average-mode-for-fan-tech-value.patch |   74 +
 ...using-timer-from-deadline_timer-to-steady.patch |  928 +++++++++++
 .../dbus-sensors/0053-add-ADC-boundary-retry.patch |   48 +
 ...the-average-mode-for-PSU-fan-sensor-value.patch |   84 +
 .../0055-Add-the-debug-log-for-dimm-sensor.patch   |   29 +
 .../dbus-sensors/0056-create-bmc-reset-flag.patch  |   34 +
 .../sensors/dbus-sensors_git.bbappend              |   65 +
 .../sensors/phosphor-hwmon%.bbappend.deprecated    |   25 +
 .../sensors/phosphor-hwmon%/iio-hwmon.conf         |   77 +
 .../bus@1e78a000/i2c-bus@100/power-supply@58.conf  |   13 +
 .../apb/bus@1e78a000/i2c-bus@40/nct7802@28.conf    |   11 +
 .../ahb/apb/pwm-tacho-controller@1e786000.conf     |   29 +
 .../phosphor-hwmon%/vsensor/cpudimm-temp.conf      |    8 +
 .../sensors/phosphor-hwmon%/vsensor/pch-temp.conf  |    4 +
 .../power-cap.override.yml                         |   18 +
 .../power-restore-policy.override.yml              |   10 +
 .../processor-state.override.yml                   |    6 +
 .../service-status.override.yml                    |    6 +
 .../sol-pattern.override.yml                       |   39 +
 .../phosphor-settings-manager_git.bbappend         |    7 +
 .../0001-make-pgood-property-writable.patch        |   34 +
 .../skeleton/obmc-libobmc-intf/gpio_defs.json      |   42 +
 .../skeleton/obmc-libobmc-intf_git.bbappend        |    5 +
 .../recipes-phosphor/sol/pattern-matching.bb       |   31 +
 .../sol/pattern-matching/CMakeLists.txt            |   66 +
 .../recipes-phosphor/sol/pattern-matching/LICENSE  |  201 +++
 .../sol/pattern-matching/include/PatternMatch.hpp  |   70 +
 ...yz.openbmc_project.sol-pattern-matching.service |   14 +
 .../sol/pattern-matching/sol-pattern.json          |    6 +
 .../sol/pattern-matching/src/PatternMatch.cpp      |  244 +++
 .../sol/pattern-matching/src/PatternMatchMain.cpp  |  141 ++
 .../srvcfg-manager/srvcfg-manager_git.bb           |   26 +
 ...he-clear-bios-post-code-feature-for-host-.patch |   56 +
 .../state/phosphor-post-code-manager_%.bbappend    |    4 +
 .../0001-Detect-host-status-by-pgood.patch         |  137 ++
 ...termine-the-host-initial-state-with-pgood.patch |   73 +
 ...ent-the-AC-restore-random-and-fixed-delay.patch |  105 ++
 .../0004-ignore-power-policy-when-BMC-reset.patch  |   21 +
 .../state/phosphor-state-manager_git.bbappend      |    8 +
 ...1-Fix-watchdog-timeout-action-do-not-work.patch |  142 ++
 ...ment-add-SEL-feature-for-watchdog-timeout.patch |  112 ++
 .../obmc-enable-host-watchdog@.service             |   14 +
 .../watchdog/phosphor-watchdog_%.bbappend          |    6 +
 .../recipes-phosphor/watchdog/system-watchdog.bb   |   16 +
 .../obmc/system-watchdog/system-watchdog.conf      |    3 +
 .../system-watchdog/system-watchdog.service        |   11 +
 .../watchdog-clear-failures.service                |    9 +
 .../system-watchdog/watchdog-clear-failures.timer  |    8 +
 .../system-watchdog/watchdog-reset.service         |    7 +
 ...he-feature-for-setting-web-status-to-enab.patch |  195 +++
 ...-Fix-the-page-for-sensors-reading-feature.patch |  137 ++
 .../0004-Fix-the-page-for-manage-power-usage.patch |   77 +
 ...05-Disable-unfinished-feature-temporarily.patch |  128 ++
 ...e-for-server-information-and-hardware-sta.patch |  116 ++
 ...0007-Fix-the-page-for-system-logs-feature.patch |   69 +
 .../0008-Fix-the-page-for-firmware-feature.patch   |  120 ++
 ...he-page-for-local-user-management-feature.patch |   37 +
 .../webui/phosphor-webui/config.json               |    8 +
 .../webui/phosphor-webui/platform-config.json      |    4 +
 .../webui/phosphor-webui_git.bbappend              |   15 +
 .../workbook/s5549-config/s5549.py                 |   46 +
 .../recipes-phosphor/workbook/s5549-config_git.bb  |   38 +
 359 files changed, 29550 insertions(+)
 create mode 100755 meta-mct/meta-s5549/conf/.vscode/settings.json
 create mode 100755 meta-mct/meta-s5549/conf/bblayers.conf.sample
 create mode 100755 meta-mct/meta-s5549/conf/conf-notes.txt
 create mode 100755 meta-mct/meta-s5549/conf/distro/s5549-pass.conf
 create mode 100755 meta-mct/meta-s5549/conf/distro/twitter-obmc-s5549.conf
 create mode 100755 meta-mct/meta-s5549/conf/layer.conf
 create mode 100755 meta-mct/meta-s5549/conf/local.conf.sample
 create mode 100755 meta-mct/meta-s5549/conf/machine/s5549.conf
 create mode 100755 meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0001-Light-BMC-Heartbeat-LED.patch
 create mode 100755 meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0002-Set-the-default-UART-route-setting.patch
 create mode 100755 meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0003-get-mac-from-eeprom.patch
 create mode 100755 meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0004-Set-BMC-RTL8211E-PHY-LED.patch
 create mode 100755 meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0005-Set-the-default-ACPI-setting.patch
 create mode 100755 meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed_2016.07.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-core/dbus/dbus/0001-Set-the-limit-size-for-dbus.patch
 create mode 100755 meta-mct/meta-s5549/recipes-core/dbus/dbus_%.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-core/ipmi/ipmi-providers.bb
 create mode 100755 meta-mct/meta-s5549/recipes-core/os-release/os-release.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-core/systemd/obmc-targets.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-core/systemd/obmc-targets/obmc-chassis-reset@.target
 create mode 100755 meta-mct/meta-s5549/recipes-extended/pam/pam-ipmi/ipmi_pass
 create mode 100755 meta-mct/meta-s5549/recipes-extended/pam/pam-ipmi_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-extended/sdbusplus/sdbusplus/0001-Add-new_signal-and-extend-set_property-methods-to-db.patch
 create mode 100755 meta-mct/meta-s5549/recipes-extended/sdbusplus/sdbusplus_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-intel/ipmi/intel-ipmi-oem/0001-Force-baseboard-FRU-to-ID0.patch
 create mode 100755 meta-mct/meta-s5549/recipes-intel/ipmi/intel-ipmi-oem_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0004-Set-RTD_1_2_3-to-thermistor-mode.patch
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0005-Support-IPMB-in-OpenBMC.patch
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0006-Modified-ibm-cffps-driver.patch
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0007-Fix-fan-sensor-disappear-when-power-off-problem.patch
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0008-increase-rofs-space.patch
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0009-Register-all-of-dimm-sensors-when-initializing.patch
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0010-change-aspeed-rpm-driver-to-falling-edge.patch
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/aspeed-bmc-mct-s5549.dts
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/s5549.cfg
 create mode 100755 meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/bios-update.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/bios-update/org.openbmc.control.BiosFlash.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/Makefile
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/bios-update
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/bios_update.py
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/image-active
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/org.openbmc.control.BiosFlash.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/py.mk
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/setup.cfg
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/setup.py
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/bios/files/update_bios.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-op-control-power/0001-leave-gpood-monitor-to-other-service.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-op-control-power_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0001-add-SEL-log-for-Power-Button-Press.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0002-Add-Power-button-override-SEL.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0003-Remove-power-button-and-reset-button-press-and-long-.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0004-Write-to-SEL-when-reset-button-is-pressed.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0005-Fix-SEL-event-issue-for-the-power-and-reset-button.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0001-Support-baseboard-fru-reading.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0003-support-fru-write-offset.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0004-fix-fsc-to-settable-interface.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0004-workaroud-for-fru-edit.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0005-remove-NVME-P4000.json.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0006-Set-the-EntityManager-service-booting-after-FruDevic.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Chicony-R550-PSU.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Common-PSU.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-500AB-PSU.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-550AB-PSU.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-650AB-PSU.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Intel-V710-NIC.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/blacklist.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/s5549-Baseboard.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan/entity-rescan.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan/entity_rescan.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/0001-Support-start-preparing-and-stop-commnad-configurati.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/0002-Add-timestamps-to-SOL-buffer.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/obmc-console-ssh@.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/obmc-console.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/console/obmc-console_%.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0002-Add-interface-for-caterr-logging.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0003-Add-SOL-PATTERN-Interface-for-SOL-Processing.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0004-Add-interface-for-AC-restore-always-on-policy.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0005-Add-interface-for-setting-specified-service-status.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0006-Set-watchdog-initialized-flag-true-as-default.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0007-Add-interface-for-DCMI-power.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0008-Set-watchdog-initialized-action-to-None-as-default.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0009-Add-the-version-ID-parameter-to-software-version-int.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-monitor-config.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/bmc-sel.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/obmc-bmc-sel.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/psu-sel.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/psu-sel.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/event/mct-event-policy-native.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/event/mct-event-policy/caterr_event.yaml
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0001-remove-the-sesnor-data-scaling.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0002-Fan-speed-control.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0003-fix-Tjmax-change-don-t-take-effect-issue.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0004-Fix-the-pid-coredump-issue.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0005-fix-typo-of-fan-control.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0006-fixed-increase-and-decrease-refresh-time.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/phosphor-pid-control.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control_%.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/Makefile.am
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/bootstrap.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/configure.ac
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial-config.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio-init/gpio-initial.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/CMakeLists.txt
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/util.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-state.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-state/id-button-pressed.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/button-state/toggle_identify_led.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/CMakeLists.txt
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/LICENSE
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/caterrHandler.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot0
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot0_deassert
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot1
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot1_deassert
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/prochot_thermtrip_update.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.caterr.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot0.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot0_deassert.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot1.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot1_deassert.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.thermtrip.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0001-Support-GPIO-interrupt.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0002-init-host-status.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0003-Filter-the-debug-log-and-change-service-enable-metho.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/phosphor-gpio-monitor@.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/phosphor-multi-gpio-monitor.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/s5549_gpio.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/power-state.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/SetPowerGoodPropertyOff.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/SetPowerGoodPropertyOn.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/setPowerProperty.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/files/hbled_blink.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/files/obmc-hbled.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/hbled-ctrl.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/images/obmc-phosphor-image.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs/obmc-shutdown.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs/obmc-update.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0001-Support-rest-API-for-MCT-OEM.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0002-Fix-the-issue-for-update-bmcweb-recipe.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0003-Implement-the-SEL-feature-for-redfish-log-service.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/mct_oem_rest.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/channel_config.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dcmi_cap.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dcmi_sensors.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dev_id.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/power_reading.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/sdr.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0004-Implement-NMI-command-in-Chassis-Control-command.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0005-ipmi-move-Unspecified-ip-source-from-static-to-D.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0006-add-power-diag-log.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0007-fix-set-static-ip-fail-issue.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0008-add-ARP-control-status.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0009-change-ipmit-power-reset-from-dc-cycle-to-reset.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0010-Fix-BIOS-boot-type-setting-in-system-boot-option-fea.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0011-fix-warm-reset-command.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0012-Fix-expiration-flags-unexpected-status-in-get-watchd.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0013-Implement-power-control-SEL-generated-in-chassis-con.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0014-Implement-the-DCMI-power-reading-and-power-limit-com.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0015-Add-debug-message-for-watchdog-reset.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0016-rewrite-Get-Session-Info-to-use-new-yielding-D-Bus-A.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0017-Fix-the-wrong-field-value-for-session-info-commnad.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0018-Add-the-detect-for-firmare-revision.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0019-block-power-control-until-pervious-action-completed.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host_%.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-ipmb/ipmb-channels.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-ipmb_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs/0001-IPMB-support-for-NM-commands.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs/0002-Display-debug-messsage-for-KCS.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net/0001-Revert-Remove-HMAC-SHA1-from-Authentication-Integrit.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net/0002-Add-the-max-size-limit-feature-to-SOL-Console-data.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/s5549-ipmi-sensor-map-native.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/ipmi/s5549-ipmi-sensor-map/config.yaml
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/leds/mct-led-manager-config-native.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/leds/mct-led-manager-config/led.yaml
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/LICENSE
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/Makefile.am
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/bootstrap.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/configure.ac
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/utils.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/default-pwm.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/default-pwm.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/disable-sw2.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/disable-sw2.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/initFruFlag.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/initFruFlag.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/relinkLan.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/restartNetIpmi.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/restartNetIpmi.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/writeFRU.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-default-action/mct-default-action.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/CMakeLists.txt
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/LICENSE
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/oemcmd.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/oemcmd.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/mct-ipmi-oem.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-gpio.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-powercyclelog.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-poweroff.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-poweron.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-powerreset.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/init_once.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/powercyclelog.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/poweroff.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/poweron.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/powerreset.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/mct-powerctrl.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/network/phosphor-network/0001-Add-try-and-catch-to-system-configuration.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/network/phosphor-network_%.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/packagegroups/packagegroup-mct-apps.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/phosphor-u-boot-mgr/phosphor-u-boot-mgr_git.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/LICENSE
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/Makefile.am
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/bootstrap.sh
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/configure.ac
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/utils.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0001-Add-CATERR-sel-log-monitor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0001-Change-ipmi_sel-location-to-persistent-folder.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0002-Alert-led-when-happen-warning.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0003-fix-sensor-reading-not-match-assert-value-issue.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0004-Bypass-SYS-Air-Inlet-sensor-for-alert-led.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0001-add-supported-pmbus-name-cffps1.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0002-Filter-out-FAN-threshold-event-during-power-transiti.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0003-New-processor-sensor-to-replace-gpio-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0004-support-ipmi-ACPI-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0005-add-event-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0006-Add-OCP-NIC-temperature-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0007-add-necessary-event-sensors-in-dbus.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0011-Add-OCP-NIC-temperature-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0013-add-ipmi-power-status-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0015-hidden-peci-core-temperature-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0017-Enabling-NVMe-sensor-support.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0018-change-power-match-to-pgood-event.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0019-Modify-temp-and-Die-sensor-threshold-setting.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0020-Add-prochot-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0021-Add-Invalid-Value-property-for-power-on-sensors.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0022-Add-type-sensors-to-support-the-invalid-value-proper.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0023-Add-thermtrip-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0024-disable-PSU-PWM-detecting.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0025-Add-VR-MOS-Margin-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0026-support-leaky-bucket-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0029-set-sensor-reading-unavailable-bit-if-nvme-is-not-pr.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0030-add-sensor-reading-unavailable-bit-for-VR-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0031-Fix-the-cpu-sensor-display.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0032-mct-NVMe-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0033-Modify-MNVMe-sensor-debug-message-with-using-debug-f.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0034-Fix-cpu-senor-data-update-error-after-code-base-upda.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0035-Fix-CPU-DTS-margin-reading-incorrect.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0036-Fix-sensor-hysteresis-issue.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0037-Fix-cpu-sensor-hang-and-get-power-status-error.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0038-Add-watchdog2-and-power-control-event-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0039-Add-DCMI-power-event-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0040-change-ADC-range-to-be-configurable.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0041-add-assert-value-to-log-event-data.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0042-Stop-the-timer-when-the-deasserted-events-occur.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0043-add-offset-value-for-E810-OCP-card.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0044-log-assert-event-when-timer-cancelled.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0045-filter-out-invalidate-ADC-value.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0046-add-BMC-watchdog-timeout-SEL.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0047-Filter-out-invalidate-MOS-temperature-value-and-add-.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0048-Add-event-disabled-event-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0049-filter-out-invalidate-sys-air-inlet-value.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0050-Update-BMC-watchdog-timeout-SEL.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0051-Implement-the-average-mode-for-fan-tech-value.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0052-Change-the-using-timer-from-deadline_timer-to-steady.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0053-add-ADC-boundary-retry.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0054-Implement-the-average-mode-for-PSU-fan-sensor-value.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0055-Add-the-debug-log-for-dimm-sensor.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0056-create-bmc-reset-flag.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%.bbappend.deprecated
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/iio-hwmon.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/bus@1e78a000/i2c-bus@100/power-supply@58.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/bus@1e78a000/i2c-bus@40/nct7802@28.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/pwm-tacho-controller@1e786000.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/vsensor/cpudimm-temp.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/vsensor/pch-temp.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/power-cap.override.yml
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/power-restore-policy.override.yml
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/processor-state.override.yml
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/service-status.override.yml
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/sol-pattern.override.yml
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf/0001-make-pgood-property-writable.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf/gpio_defs.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/CMakeLists.txt
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/LICENSE
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/include/PatternMatch.hpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/service/xyz.openbmc_project.sol-pattern-matching.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/sol-pattern.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/src/PatternMatch.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/src/PatternMatchMain.cpp
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/srvcfg-manager/srvcfg-manager_git.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/state/phosphor-post-code-manager/0001-Implement-the-clear-bios-post-code-feature-for-host-.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/state/phosphor-post-code-manager_%.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0001-Detect-host-status-by-pgood.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0002-Determine-the-host-initial-state-with-pgood.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0003-Implement-the-AC-restore-random-and-fixed-delay.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0004-ignore-power-policy-when-BMC-reset.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/0001-Fix-watchdog-timeout-action-do-not-work.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/0002-Implement-add-SEL-feature-for-watchdog-timeout.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/obmc-enable-host-watchdog@.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog_%.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog.bb
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/obmc/system-watchdog/system-watchdog.conf
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/system-watchdog.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-clear-failures.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-clear-failures.timer
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-reset.service
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0002-Implement-the-feature-for-setting-web-status-to-enab.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0003-Fix-the-page-for-sensors-reading-feature.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0004-Fix-the-page-for-manage-power-usage.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0005-Disable-unfinished-feature-temporarily.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0006-Fix-the-page-for-server-information-and-hardware-sta.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0007-Fix-the-page-for-system-logs-feature.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0008-Fix-the-page-for-firmware-feature.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0009-Fix-the-page-for-local-user-management-feature.patch
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/config.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/platform-config.json
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui_git.bbappend
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/workbook/s5549-config/s5549.py
 create mode 100755 meta-mct/meta-s5549/recipes-phosphor/workbook/s5549-config_git.bb

diff --git a/meta-mct/meta-s5549/conf/.vscode/settings.json b/meta-mct/meta-s5549/conf/.vscode/settings.json
new file mode 100755
index 0000000..ade0228
--- /dev/null
+++ b/meta-mct/meta-s5549/conf/.vscode/settings.json
@@ -0,0 +1,73 @@
+{
+    "files.associations": {
+        "cctype": "cpp",
+        "clocale": "cpp",
+        "cmath": "cpp",
+        "csignal": "cpp",
+        "cstdarg": "cpp",
+        "cstddef": "cpp",
+        "cstdio": "cpp",
+        "cstdlib": "cpp",
+        "cstring": "cpp",
+        "ctime": "cpp",
+        "cwchar": "cpp",
+        "cwctype": "cpp",
+        "any": "cpp",
+        "array": "cpp",
+        "atomic": "cpp",
+        "bit": "cpp",
+        "*.tcc": "cpp",
+        "bitset": "cpp",
+        "chrono": "cpp",
+        "codecvt": "cpp",
+        "complex": "cpp",
+        "condition_variable": "cpp",
+        "cstdint": "cpp",
+        "deque": "cpp",
+        "forward_list": "cpp",
+        "list": "cpp",
+        "map": "cpp",
+        "set": "cpp",
+        "unordered_map": "cpp",
+        "vector": "cpp",
+        "exception": "cpp",
+        "algorithm": "cpp",
+        "functional": "cpp",
+        "iterator": "cpp",
+        "memory": "cpp",
+        "memory_resource": "cpp",
+        "numeric": "cpp",
+        "optional": "cpp",
+        "random": "cpp",
+        "ratio": "cpp",
+        "string": "cpp",
+        "string_view": "cpp",
+        "system_error": "cpp",
+        "tuple": "cpp",
+        "type_traits": "cpp",
+        "utility": "cpp",
+        "fstream": "cpp",
+        "future": "cpp",
+        "initializer_list": "cpp",
+        "iomanip": "cpp",
+        "iosfwd": "cpp",
+        "iostream": "cpp",
+        "istream": "cpp",
+        "limits": "cpp",
+        "mutex": "cpp",
+        "new": "cpp",
+        "ostream": "cpp",
+        "sstream": "cpp",
+        "stdexcept": "cpp",
+        "streambuf": "cpp",
+        "thread": "cpp",
+        "cfenv": "cpp",
+        "cinttypes": "cpp",
+        "typeindex": "cpp",
+        "typeinfo": "cpp",
+        "valarray": "cpp",
+        "variant": "cpp",
+        "regex": "cpp",
+        "shared_mutex": "cpp"
+    }
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/conf/bblayers.conf.sample b/meta-mct/meta-s5549/conf/bblayers.conf.sample
new file mode 100755
index 0000000..88a8bbf
--- /dev/null
+++ b/meta-mct/meta-s5549/conf/bblayers.conf.sample
@@ -0,0 +1,22 @@
+# LAYER_CONF_VERSION is increased each time build/conf/bblayers.conf
+# changes incompatibly
+LCONF_VERSION = "8"
+
+BBPATH = "${TOPDIR}"
+BBFILES ?= ""
+
+BBLAYERS ?= " \
+  ##OEROOT##/meta \
+  ##OEROOT##/meta-poky \
+  ##OEROOT##/meta-openembedded/meta-oe \
+  ##OEROOT##/meta-openembedded/meta-networking \
+  ##OEROOT##/meta-openembedded/meta-perl \
+  ##OEROOT##/meta-openembedded/meta-python \
+  ##OEROOT##/meta-openembedded/meta-webserver \
+  ##OEROOT##/meta-phosphor \
+  ##OEROOT##/meta-aspeed \
+  ##OEROOT##/meta-x86 \
+  ##OEROOT##/meta-mct \
+  ##OEROOT##/meta-mct/meta-s5549 \
+"
+BBMASK = "##OEROOT##/meta-phosphor/recipes-extended/rsyslog/rsyslog_%.bbappend"
diff --git a/meta-mct/meta-s5549/conf/conf-notes.txt b/meta-mct/meta-s5549/conf/conf-notes.txt
new file mode 100755
index 0000000..43d4ab0
--- /dev/null
+++ b/meta-mct/meta-s5549/conf/conf-notes.txt
@@ -0,0 +1,2 @@
+Common targets are:
+    obmc-phosphor-image
diff --git a/meta-mct/meta-s5549/conf/distro/s5549-pass.conf b/meta-mct/meta-s5549/conf/distro/s5549-pass.conf
new file mode 100755
index 0000000..2ffa8c9
--- /dev/null
+++ b/meta-mct/meta-s5549/conf/distro/s5549-pass.conf
@@ -0,0 +1,3 @@
+EXTRA_USERS_PARAMS_pn-obmc-phosphor-image = " \
+  usermod -p '$(openssl passwd -1 root)' root; \
+  "
diff --git a/meta-mct/meta-s5549/conf/distro/twitter-obmc-s5549.conf b/meta-mct/meta-s5549/conf/distro/twitter-obmc-s5549.conf
new file mode 100755
index 0000000..c6275c0
--- /dev/null
+++ b/meta-mct/meta-s5549/conf/distro/twitter-obmc-s5549.conf
@@ -0,0 +1,2 @@
+require conf/distro/include/phosphor-base.inc
+require s5549-pass.conf
diff --git a/meta-mct/meta-s5549/conf/layer.conf b/meta-mct/meta-s5549/conf/layer.conf
new file mode 100755
index 0000000..b2f31a0
--- /dev/null
+++ b/meta-mct/meta-s5549/conf/layer.conf
@@ -0,0 +1,10 @@
+# We have a conf and classes directory, add to BBPATH
+BBPATH .= ":${LAYERDIR}"
+
+# We have recipes-* directories, add to BBFILES
+BBFILES += "${LAYERDIR}/recipes-*/*/*.bb \
+            ${LAYERDIR}/recipes-*/*/*.bbappend"
+
+BBFILE_COLLECTIONS += "s5549"
+BBFILE_PATTERN_s5549 = ""
+BBFILE_PRIORITY_s5549 = "5"
diff --git a/meta-mct/meta-s5549/conf/local.conf.sample b/meta-mct/meta-s5549/conf/local.conf.sample
new file mode 100755
index 0000000..ab35bc1
--- /dev/null
+++ b/meta-mct/meta-s5549/conf/local.conf.sample
@@ -0,0 +1,241 @@
+#
+# This file is your local configuration file and is where all local user settings
+# are placed. The comments in this file give some guide to the options a new user
+# to the system might want to change but pretty much any configuration option can
+# be set in this file. More adventurous users can look at local.conf.extended
+# which contains other examples of configuration which can be placed in this file
+# but new users likely won't need any of them initially.
+#
+# Lines starting with the '#' character are commented out and in some cases the
+# default values are provided as comments to show people example syntax. Enabling
+# the option is a question of removing the # character and making any change to the
+# variable as required.
+
+#
+# Machine Selection
+#
+# You need to select a specific machine to target the build with. There are a selection
+# of emulated machines available which can boot and run in the QEMU emulator:
+#
+#MACHINE ?= "qemuarm"
+#MACHINE ?= "qemuarm64"
+#MACHINE ?= "qemumips"
+#MACHINE ?= "qemuppc"
+#MACHINE ?= "qemux86"
+#MACHINE ?= "qemux86-64"
+#
+# There are also the following hardware board target machines included for
+# demonstration purposes:
+#
+#MACHINE ?= "beaglebone"
+#MACHINE ?= "genericx86"
+#MACHINE ?= "genericx86-64"
+#MACHINE ?= "mpc8315e-rdb"
+#MACHINE ?= "edgerouter"
+#
+# This sets the default machine to be qemux86 if no other machine is selected:
+
+MACHINE ?= "s5549"
+
+#
+# Where to place downloads
+#
+# During a first build the system will download many different source code tarballs
+# from various upstream projects. This can take a while, particularly if your network
+# connection is slow. These are all stored in DL_DIR. When wiping and rebuilding you
+# can preserve this directory to speed up this part of subsequent builds. This directory
+# is safe to share between multiple builds on the same machine too.
+#
+# The default is a downloads directory under TOPDIR which is the build directory.
+#
+#DL_DIR ?= "${TOPDIR}/downloads"
+#
+# Where to place shared-state files
+#
+# BitBake has the capability to accelerate builds based on previously built output.
+# This is done using "shared state" files which can be thought of as cache objects
+# and this option determines where those files are placed.
+#
+# You can wipe out TMPDIR leaving this directory intact and the build would regenerate
+# from these files if no changes were made to the configuration. If changes were made
+# to the configuration, only shared state files where the state was still valid would
+# be used (done using checksums).
+#
+# The default is a sstate-cache directory under TOPDIR.
+#
+#SSTATE_DIR ?= "${TOPDIR}/sstate-cache"
+
+#
+# Where to place the build output
+#
+# This option specifies where the bulk of the building work should be done and
+# where BitBake should place its temporary files and output. Keep in mind that
+# this includes the extraction and compilation of many applications and the toolchain
+# which can use Gigabytes of hard disk space.
+#
+# The default is a tmp directory under TOPDIR.
+#
+#TMPDIR = "${TOPDIR}/tmp"
+
+#
+# Default policy config
+#
+# The distribution setting controls which policy settings are used as defaults.
+# The default value is fine for general Yocto project use, at least initially.
+# Ultimately when creating custom policy, people will likely end up subclassing
+# these defaults.
+#
+DISTRO ?= "twitter-obmc-s5549"
+# As an example of a subclass there is a "bleeding" edge policy configuration
+# where many versions are set to the absolute latest code from the upstream
+# source control systems. This is just mentioned here as an example, its not
+# useful to most new users.
+# DISTRO ?= "poky-bleeding"
+
+#
+# Package Management configuration
+#
+# This variable lists which packaging formats to enable. Multiple package backends
+# can be enabled at once and the first item listed in the variable will be used
+# to generate the root filesystems.
+# Options are:
+#  - 'package_deb' for debian style deb files
+#  - 'package_ipk' for ipk files are used by opkg (a debian style embedded package manager)
+#  - 'package_rpm' for rpm style packages
+# E.g.: PACKAGE_CLASSES ?= "package_rpm package_deb package_ipk"
+# We default to rpm:
+PACKAGE_CLASSES ?= "package_rpm"
+
+#
+# SDK/ADT target architecture
+#
+# This variable specifies the architecture to build SDK/ADT items for and means
+# you can build the SDK packages for architectures other than the machine you are
+# running the build on (i.e. building i686 packages on an x86_64 host).
+# Supported values are i686 and x86_64
+#SDKMACHINE ?= "i686"
+SANITY_TESTED_DISTROS_append ?= " RedHatEnterpriseWorkstation-6.*"
+
+#
+# Extra image configuration defaults
+#
+# The EXTRA_IMAGE_FEATURES variable allows extra packages to be added to the generated
+# images. Some of these options are added to certain image types automatically. The
+# variable can contain the following options:
+#  "dbg-pkgs"       - add -dbg packages for all installed packages
+#                     (adds symbol information for debugging/profiling)
+#  "dev-pkgs"       - add -dev packages for all installed packages
+#                     (useful if you want to develop against libs in the image)
+#  "ptest-pkgs"     - add -ptest packages for all ptest-enabled packages
+#                     (useful if you want to run the package test suites)
+#  "tools-sdk"      - add development tools (gcc, make, pkgconfig etc.)
+#  "tools-debug"    - add debugging tools (gdb, strace)
+#  "eclipse-debug"  - add Eclipse remote debugging support
+#  "tools-profile"  - add profiling tools (oprofile, exmap, lttng, valgrind)
+#  "tools-testapps" - add useful testing tools (ts_print, aplay, arecord etc.)
+#  "debug-tweaks"   - make an image suitable for development
+#                     e.g. ssh root access has a blank password
+# There are other application targets that can be used here too, see
+# meta/classes/image.bbclass and meta/classes/core-image.bbclass for more details.
+# We default to enabling the debugging tweaks.
+EXTRA_IMAGE_FEATURES = "debug-tweaks"
+
+#
+# Additional image features
+#
+# The following is a list of additional classes to use when building images which
+# enable extra features. Some available options which can be included in this variable
+# are:
+#   - 'buildstats' collect build statistics
+#   - 'image-mklibs' to reduce shared library files size for an image
+#   - 'image-prelink' in order to prelink the filesystem image
+#   - 'image-swab' to perform host system intrusion detection
+# NOTE: if listing mklibs & prelink both, then make sure mklibs is before prelink
+# NOTE: mklibs also needs to be explicitly enabled for a given image, see local.conf.extended
+USER_CLASSES ?= "buildstats image-mklibs image-prelink"
+
+#
+# Runtime testing of images
+#
+# The build system can test booting virtual machine images under qemu (an emulator)
+# after any root filesystems are created and run tests against those images. To
+# enable this uncomment this line. See classes/testimage(-auto).bbclass for
+# further details.
+#TEST_IMAGE = "1"
+#
+# Interactive shell configuration
+#
+# Under certain circumstances the system may need input from you and to do this it
+# can launch an interactive shell. It needs to do this since the build is
+# multithreaded and needs to be able to handle the case where more than one parallel
+# process may require the user's attention. The default is iterate over the available
+# terminal types to find one that works.
+#
+# Examples of the occasions this may happen are when resolving patches which cannot
+# be applied, to use the devshell or the kernel menuconfig
+#
+# Supported values are auto, gnome, xfce, rxvt, screen, konsole (KDE 3.x only), none
+# Note: currently, Konsole support only works for KDE 3.x due to the way
+# newer Konsole versions behave
+#OE_TERMINAL = "auto"
+# By default disable interactive patch resolution (tasks will just fail instead):
+PATCHRESOLVE = "noop"
+
+#
+# Disk Space Monitoring during the build
+#
+# Monitor the disk space during the build. If there is less that 1GB of space or less
+# than 100K inodes in any key build location (TMPDIR, DL_DIR, SSTATE_DIR), gracefully
+# shutdown the build. If there is less that 100MB or 1K inodes, perform a hard abort
+# of the build. The reason for this is that running completely out of space can corrupt
+# files and damages the build in ways which may not be easily recoverable.
+# It's necessary to monitor /tmp, if there is no space left the build will fail
+# with very exotic errors.
+BB_DISKMON_DIRS = "\
+    STOPTASKS,${TMPDIR},1G,100K \
+    STOPTASKS,${DL_DIR},1G,100K \
+    STOPTASKS,${SSTATE_DIR},1G,100K \
+    STOPTASKS,/tmp,100M,100K \
+    ABORT,${TMPDIR},100M,1K \
+    ABORT,${DL_DIR},100M,1K \
+    ABORT,${SSTATE_DIR},100M,1K \
+    ABORT,/tmp,10M,1K"
+
+#
+# Shared-state files from other locations
+#
+# As mentioned above, shared state files are prebuilt cache data objects which can
+# used to accelerate build time. This variable can be used to configure the system
+# to search other mirror locations for these objects before it builds the data itself.
+#
+# This can be a filesystem directory, or a remote url such as http or ftp. These
+# would contain the sstate-cache results from previous builds (possibly from other
+# machines). This variable works like fetcher MIRRORS/PREMIRRORS and points to the
+# cache locations to check for the shared objects.
+# NOTE: if the mirror uses the same structure as SSTATE_DIR, you need to add PATH
+# at the end as shown in the examples below. This will be substituted with the
+# correct path within the directory structure.
+#SSTATE_MIRRORS ?= "\
+#file://.* http://someserver.tld/share/sstate/PATH;downloadfilename=PATH \n \
+#file://.* file:///some/local/dir/sstate/PATH"
+
+#
+# Qemu configuration
+#
+# By default qemu will build with a builtin VNC server where graphical output can be
+# seen. The two lines below enable the SDL backend too. This assumes there is a
+# libsdl library available on your build system.
+PACKAGECONFIG_append_pn-qemu-native = " sdl"
+PACKAGECONFIG_append_pn-nativesdk-qemu = " sdl"
+#ASSUME_PROVIDED += "libsdl-native"
+
+# CONF_VERSION is increased each time build/conf/ changes incompatibly and is used to
+# track the version of this file when it was generated. This can safely be ignored if
+# this doesn't mean anything to you.
+CONF_VERSION = "1"
+
+# Set the root password to '0penBmc'
+INHERIT += "extrausers"
+EXTRA_USERS_PARAMS = " \
+  usermod -p '\$1\$KdSxTq5i\$W7g5v8sWXDsF0zvh.8Rk61' root; \
+  "
diff --git a/meta-mct/meta-s5549/conf/machine/s5549.conf b/meta-mct/meta-s5549/conf/machine/s5549.conf
new file mode 100755
index 0000000..c5f7d30
--- /dev/null
+++ b/meta-mct/meta-s5549/conf/machine/s5549.conf
@@ -0,0 +1,21 @@
+KMACHINE = "aspeed"
+KERNEL_DEVICETREE = "${KMACHINE}-bmc-mct-s5549.dtb"
+
+require conf/machine/include/ast2500.inc
+require conf/machine/include/obmc-bsp-common.inc
+require conf/machine/include/mct.inc
+
+UBOOT_MACHINE = "ast_g5_phy_config"
+
+FLASH_SIZE = "65536"
+FLASH_RWFS_OFFSET = "40960"
+
+VIRTUAL-RUNTIME_skeleton_workbook = "${MACHINE}-config"
+
+PREFERRED_PROVIDER_virtual/phosphor-led-manager-config-native = "mct-led-manager-config-native"
+#PREFERRED_PROVIDER_virtual/phosphor-ipmi-sensor-inventory = "s5549-ipmi-sensor-map-native"
+
+PREFERRED_PROVIDER_virtual/obmc-host-ctl = "packagegroup-mct-apps"
+PREFERRED_PROVIDER_virtual/obmc-host-ipmi-hw = "phosphor-ipmi-kcs"
+PREFERRED_PROVIDER_virtual/obmc-gpio-monitor = "phosphor-gpio-monitor"
+PREFERRED_RPROVIDER_virtual/phosphor-ipmi-config = "${MACHINE}-ipmi-config"
diff --git a/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0001-Light-BMC-Heartbeat-LED.patch b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0001-Light-BMC-Heartbeat-LED.patch
new file mode 100755
index 0000000..935b85c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0001-Light-BMC-Heartbeat-LED.patch
@@ -0,0 +1,42 @@
+From aeb54ffc992b31517786cd451da2642ba90d909c Mon Sep 17 00:00:00 2001
+From: Mirage Su <mirage.su@mic.com.tw>
+Date: Fri, 14 Dec 2018 15:31:24 +0800
+Subject: [PATCH] Light BMC Heartbeat LED
+
+---
+ board/aspeed/ast-g5/ast-g5.c | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+ mode change 100644 => 100755 board/aspeed/ast-g5/ast-g5.c
+
+diff --git a/board/aspeed/ast-g5/ast-g5.c b/board/aspeed/ast-g5/ast-g5.c
+old mode 100644
+new mode 100755
+index e67a4bf..e1d3011
+--- a/board/aspeed/ast-g5/ast-g5.c
++++ b/board/aspeed/ast-g5/ast-g5.c
+@@ -16,11 +16,25 @@
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
++/*--------------------------------------------------------------------
++ * @fn Light_BMC_Heartbeat_LED
++ * @brief switch the BMC_Heartbeat_LED solid ON
++ * Author  Mirage
++ *--------------------------------------------------------------------*/
++void Light_BMC_Heartbeat_LED(void)
++{
++    puts("Switch the BMC Heartbeat LED solid ON\n");
++    *(volatile ulong *)(0x1E780020) |= 0x0000080 ;
++    *(volatile ulong *)(0x1E780024) |= 0x0000080 ;
++}
++
+ int board_init(void)
+ {
+ 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+ 	gd->flags = 0;
+ 
++	Light_BMC_Heartbeat_LED();
++
+ 	return 0;
+ }
+ 
diff --git a/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0002-Set-the-default-UART-route-setting.patch b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0002-Set-the-default-UART-route-setting.patch
new file mode 100755
index 0000000..b1652f8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0002-Set-the-default-UART-route-setting.patch
@@ -0,0 +1,42 @@
+From f85fe2281e8e6841013c9d506a507048b15e0973 Mon Sep 17 00:00:00 2001
+From: Mirage Su <mirage.su@mic.com.tw>
+Date: Wed, 26 Dec 2018 10:27:39 +0800
+Subject: [PATCH] Set the default UART route setting
+
+UART2<->UART3 for SOL (Remote host console)
+---
+ board/aspeed/ast-g5/ast-g5.c | 15 ++++++++++++++-
+ 1 file changed, 14 insertions(+), 1 deletion(-)
+
+diff --git a/board/aspeed/ast-g5/ast-g5.c b/board/aspeed/ast-g5/ast-g5.c
+index e1d3011..9ddd18e 100755
+--- a/board/aspeed/ast-g5/ast-g5.c
++++ b/board/aspeed/ast-g5/ast-g5.c
+@@ -28,13 +28,26 @@ void Light_BMC_Heartbeat_LED(void)
+     *(volatile ulong *)(0x1E780024) |= 0x0000080 ;
+ }
+
++/*--------------------------------------------------------------------
++ * @fn Set_Default_UART_Route
++ * @brief Set the default UART Route
++ * Author  Mirage
++ *--------------------------------------------------------------------*/
++void Set_Default_UART_Route(void)
++{
++    puts("Set the default UART Route(UART1 <-> UART3 for SOL)...\n");
++    *(volatile ulong *)(0x1E78909C) = 0x1400000 ;
++}
++
++
+ int board_init(void)
+ {
+ 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+ 	gd->flags = 0;
+ 
+ 	Light_BMC_Heartbeat_LED();
+-
++    Set_Default_UART_Route();
++    
+ 	return 0;
+ }
+ 
diff --git a/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0003-get-mac-from-eeprom.patch b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0003-get-mac-from-eeprom.patch
new file mode 100755
index 0000000..54d06bf
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0003-get-mac-from-eeprom.patch
@@ -0,0 +1,94 @@
+From 05eed585012fbbfec157a59f980b9d5e52c6a8f9 Mon Sep 17 00:00:00 2001
+From: "ray.lue" <ray.lue@mic.com.tw>
+Date: Tue, 29 Jan 2019 14:28:51 +0800
+Subject: [PATCH] get mac from eeprom
+
+---
+ board/aspeed/ast-g5/ast-g5.c |  8 ++++++++
+ drivers/net/ftgmac100.c      | 18 +++++++++---------
+ include/configs/ast-g5-phy.h |  6 ++++++
+ 3 files changed, 23 insertions(+), 9 deletions(-)
+ mode change 100644 => 100755 drivers/net/ftgmac100.c
+ mode change 100644 => 100755 include/configs/ast-g5-phy.h
+
+diff --git a/board/aspeed/ast-g5/ast-g5.c b/board/aspeed/ast-g5/ast-g5.c
+index 9ddd18e..eb07bce 100755
+--- a/board/aspeed/ast-g5/ast-g5.c
++++ b/board/aspeed/ast-g5/ast-g5.c
+@@ -82,3 +82,11 @@ void hw_watchdog_reset(void)
+ 	writel(0x4755, AST_WDT2_BASE + 0x08);
+ }
+ #endif /* CONFIG_WATCHDOG */
++#if defined(CONFIG_SYS_I2C_MAC_OFFSET)
++int mac_read_from_eeprom(void)
++{  
++	/* do nothing, the eth driver to do it*/
++	return 0;
++}
++#endif
++
+diff --git a/drivers/net/ftgmac100.c b/drivers/net/ftgmac100.c
+old mode 100644
+new mode 100755
+index 5779057..1e38781
+--- a/drivers/net/ftgmac100.c
++++ b/drivers/net/ftgmac100.c
+@@ -484,19 +484,22 @@ static void ftgmac100_set_mac(struct eth_device *dev,
+ static void ftgmac100_set_mac_from_env(struct eth_device *dev)
+ {
+ #ifdef CONFIG_SYS_I2C_MAC_OFFSET
++#include <i2c.h>
+ 
+ 	char *s;
+     int i, env;                // env variable 0: eeprom, 1: environment parameters
+ 
+ 	s = getenv ("eeprom");
+ 	env = (s && (*s == 'y')) ? 1 : 0;
+-
++	//igonre eeprom env
++	env = 1;
+ 	if (env) {
+ 		printf("TODO ... eerprom --> \n");
+-	    eeprom_init();
+-		i2c_set_bus_num(3);
+-	    eeprom_read(CONFIG_SYS_I2C_EEPROM_ADDR, CONFIG_SYS_I2C_MAC_OFFSET, dev->enetaddr, 6);
+-
++ 		//eeprom_init();
++ 		i2c_set_bus_num(CONFIG_SYS_EEPROM_BUS_NUM);
++ 		i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, CONFIG_SYS_I2C_MAC_OFFSET - (dev->index * 6), CONFIG_SYS_I2C_EEPROM_ADDR_LEN ,dev->enetaddr, 6);
++		//eeprom_read(CONFIG_SYS_I2C_EEPROM_ADDR, CONFIG_SYS_I2C_MAC_OFFSET, dev->enetaddr, 6);		
++		
+ 		for (i = 0; i < 6; i++) {
+ 		    if (dev->enetaddr[i] != 0xFF) {
+ 		        env = 0;	//Suppose not all 0xFF is valid
+@@ -508,10 +511,7 @@ static void ftgmac100_set_mac_from_env(struct eth_device *dev)
+ 		eth_getenv_enetaddr_by_index("eth", dev->index, dev->enetaddr);
+ //		eth_setenv_enetaddr("ethaddr", dev->enetaddr);
+ 	else
+-		eth_getenv_enetaddr_by_index("eth", dev->index, dev->enetaddr);
+-//		eth_getenv_enetaddr("ethaddr", dev->enetaddr);
+-
+-	ftgmac100_set_mac(dev, dev->enetaddr);
++		ftgmac100_set_mac(dev, dev->enetaddr);
+ #else
+ 	eth_getenv_enetaddr_by_index("eth", dev->index, dev->enetaddr);
+ //	eth_getenv_enetaddr("ethaddr", dev->enetaddr);
+diff --git a/include/configs/ast-g5-phy.h b/include/configs/ast-g5-phy.h
+old mode 100644
+new mode 100755
+index 62ddb84..343023f
+--- a/include/configs/ast-g5-phy.h
++++ b/include/configs/ast-g5-phy.h
+@@ -27,6 +27,12 @@
+ #define CONFIG_PHY_MAX_ADDR		32
+ #define CONFIG_FTGMAC100_EGIGA
+ 
++/* MAC in eeprom  */
++#define CONFIG_SYS_EEPROM_BUS_NUM 2
++#define CONFIG_SYS_I2C_EEPROM_ADDR 0x50
++#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 2
++#define CONFIG_SYS_I2C_MAC_OFFSET 0x46
++
+ /* platform.S */
+ #define	CONFIG_DRAM_ECC_SIZE		0x10000000
+ 
diff --git a/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0004-Set-BMC-RTL8211E-PHY-LED.patch b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0004-Set-BMC-RTL8211E-PHY-LED.patch
new file mode 100755
index 0000000..f7c48bf
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0004-Set-BMC-RTL8211E-PHY-LED.patch
@@ -0,0 +1,66 @@
+From 444c7bbd547843754807c07cfaef10e0c84ddbd5 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Fri, 14 Feb 2020 13:47:01 +0800
+Subject: [PATCH 1/1] Set-BMC-RTL8211E-PHY-LED.patch
+
+---
+ drivers/net/ftgmac100.c | 29 +++++++++++++++++++++++++++++
+ 1 file changed, 29 insertions(+)
+
+diff --git a/drivers/net/ftgmac100.c b/drivers/net/ftgmac100.c
+index 02bccfc498..23efd5e5a3 100755
+--- a/drivers/net/ftgmac100.c
++++ b/drivers/net/ftgmac100.c
+@@ -383,6 +383,30 @@ static int ftgmac100_phy_init(struct eth_device *dev)
+ 	return 1;
+ }
+ 
++static int ftgmac100_phy_led_init(struct eth_device *dev)
++{
++	struct ftgmac100_data *priv = dev->priv;
++ 	//RTL8211E phy
++  	// Switch to LED control page
++  	ftgmac100_phy_write(dev, priv->phy_addr, 0x1f, 0x0007);
++  	ftgmac100_phy_write(dev, priv->phy_addr, 0x1e, 0x002c);
++
++  	// Write LED settings
++  	ftgmac100_phy_write(dev, priv->phy_addr, 0x1c, 0x0742);
++  	ftgmac100_phy_write(dev, priv->phy_addr, 0x1a, 0x0040);
++
++  	// Switch back to PHY default page
++  	ftgmac100_phy_write(dev, priv->phy_addr, 0x1f, 0x0000);
++
++  	/* Do not advertise EEE */
++ 	ftgmac100_phy_write(dev, priv->phy_addr, 0x0d, 0x0007);
++ 	ftgmac100_phy_write(dev, priv->phy_addr, 0x0e, 0x003c);
++  	ftgmac100_phy_write(dev, priv->phy_addr, 0x0d, 0x4007);
++	ftgmac100_phy_write(dev, priv->phy_addr, 0x0e, 0x0000);
++
++  return 0;
++}
++
+ static int ftgmac100_update_link_speed(struct eth_device *dev)
+ {
+ 	struct ftgmac100 *ftgmac100 = (struct ftgmac100 *)dev->iobase;
+@@ -597,6 +621,7 @@ static int ftgmac100_init(struct eth_device *dev, bd_t *bd)
+ 		FTGMAC100_MACCR_FULLDUP |
+ 		FTGMAC100_MACCR_RX_RUNT |
+ 		FTGMAC100_MACCR_RX_BROADPKT;
++		
+ 
+ 	__raw_writel(maccr, &ftgmac100->maccr);
+ 
+@@ -797,6 +822,10 @@ int ftgmac100_initialize(bd_t *bd)
+ 		ftgmac100_set_mac_from_env(dev);
+ 
+ 		card_number++;
++
++                ftgmac100_phy_init(dev);
++                ftgmac100_update_link_speed(dev);
++                ftgmac100_phy_led_init(dev);
+ 	}
+ 	return card_number;
+ 
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0005-Set-the-default-ACPI-setting.patch b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0005-Set-the-default-ACPI-setting.patch
new file mode 100755
index 0000000..58ad7e1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed/0005-Set-the-default-ACPI-setting.patch
@@ -0,0 +1,42 @@
+From 063ac297cde68541534ddb47896d9c323de67536 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 17 Dec 2020 17:25:52 +0800
+Subject: [PATCH] Set the default ACPI setting
+
+---
+ board/aspeed/ast-g5/ast-g5.c | 12 +++++++++++-
+ 1 file changed, 11 insertions(+), 1 deletion(-)
+
+diff --git a/board/aspeed/ast-g5/ast-g5.c b/board/aspeed/ast-g5/ast-g5.c
+index b687436..7256691 100755
+--- a/board/aspeed/ast-g5/ast-g5.c
++++ b/board/aspeed/ast-g5/ast-g5.c
+@@ -39,6 +39,16 @@ void Set_Default_UART_Route(void)
+     *(volatile ulong *)(0x1E78909C) = 0x1400000 ;
+ }
+ 
++/*--------------------------------------------------------------------
++ * @fn Set Default ACPI Setting
++ * @brief Set Default ACPI Setting
++ *--------------------------------------------------------------------*/
++void Set_Default_ACPI_Setting(void)
++{
++    puts("Set Default ACPI setting to disable\n");
++    *(volatile ulong *)(0x1E6E2000) = 0x1688A8A8;
++    *(volatile ulong *)(0x1E6E207C) = 0x00080000;
++}
+ 
+ int board_init(void)
+ {
+@@ -47,7 +57,7 @@ int board_init(void)
+ 
+ 	Light_BMC_Heartbeat_LED();
+     Set_Default_UART_Route();
+-    
++	Set_Default_ACPI_Setting();
+ 	return 0;
+ }
+ 
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed_2016.07.bbappend b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed_2016.07.bbappend
new file mode 100755
index 0000000..91a3130
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-bsp/u-boot/u-boot-aspeed_2016.07.bbappend
@@ -0,0 +1,9 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-Light-BMC-Heartbeat-LED.patch \
+            file://0002-Set-the-default-UART-route-setting.patch \
+            file://0003-get-mac-from-eeprom.patch \
+            file://0004-Set-BMC-RTL8211E-PHY-LED.patch \
+            file://0005-Set-the-default-ACPI-setting.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-core/dbus/dbus/0001-Set-the-limit-size-for-dbus.patch b/meta-mct/meta-s5549/recipes-core/dbus/dbus/0001-Set-the-limit-size-for-dbus.patch
new file mode 100755
index 0000000..2b68c71
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-core/dbus/dbus/0001-Set-the-limit-size-for-dbus.patch
@@ -0,0 +1,28 @@
+From 6f87ce7855989c927d1220acb42603b4966cb126 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Fri, 18 Sep 2020 14:38:44 +0800
+Subject: [PATCH] Set the limit size for dbus
+
+---
+ bus/system.conf.in | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/bus/system.conf.in b/bus/system.conf.in
+index f139b55..a5702f3 100644
+--- a/bus/system.conf.in
++++ b/bus/system.conf.in
+@@ -108,11 +108,11 @@
+        133169152 bytes = 127 MiB
+        33554432 bytes = 32 MiB
+        150000ms = 2.5 minutes -->
+-  <!-- <limit name="max_incoming_bytes">133169152</limit> -->
++  <limit name="max_incoming_bytes">33554432</limit>
+   <!-- <limit name="max_incoming_unix_fds">64</limit> -->
+-  <!-- <limit name="max_outgoing_bytes">133169152</limit> -->
++  <limit name="max_outgoing_bytes">33554432</limit>
+   <!-- <limit name="max_outgoing_unix_fds">64</limit> -->
+-  <!-- <limit name="max_message_size">33554432</limit> -->
++  <limit name="max_message_size">33554432</limit>
+   <!-- <limit name="max_message_unix_fds">16</limit> -->
+   <!-- <limit name="service_start_timeout">25000</limit> -->
+   <!-- <limit name="auth_timeout">5000</limit> -->
diff --git a/meta-mct/meta-s5549/recipes-core/dbus/dbus_%.bbappend b/meta-mct/meta-s5549/recipes-core/dbus/dbus_%.bbappend
new file mode 100755
index 0000000..5ba2819
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-core/dbus/dbus_%.bbappend
@@ -0,0 +1,4 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-Set-the-limit-size-for-dbus.patch"
+
diff --git a/meta-mct/meta-s5549/recipes-core/ipmi/ipmi-providers.bb b/meta-mct/meta-s5549/recipes-core/ipmi/ipmi-providers.bb
new file mode 100755
index 0000000..34a776c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-core/ipmi/ipmi-providers.bb
@@ -0,0 +1,32 @@
+SUMMARY = "Intel IPMI Providers"
+DESCRIPTION = "IPMI Provider Libraries"
+
+SRC_URI = "git://github.com/Intel-BMC/intel-ipmi-providers"
+SRCREV = "3f8aa7959d2e8475e50743d32ff178257aafc1e7"
+
+S = "${WORKDIR}/git"
+PV = "0.1+git${SRCPV}"
+
+DEPENDS = "boost phosphor-ipmi-host intel-ipmi-oem systemd microsoft-gsl"
+
+inherit cmake obmc-phosphor-ipmiprovider-symlink
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://LICENSE;md5=2ee41112a44fe7014dce33e26468ba93"
+
+EXTRA_OECMAKE="-DENABLE_TEST=0 -DYOCTO=1"
+
+LIBRARY_NAMES += "libmtmcmds.so"
+LIBRARY_NAMES += "libsmbioshandler.so"
+LIBRARY_NAMES += "libzbridgecmd.so"
+LIBRARY_NAMES += "libsmbiosmdrv2.so"
+LIBRARY_NAMES += "libfwupdcmds.so"
+
+HOSTIPMI_PROVIDER_LIBRARY += "${LIBRARY_NAMES}"
+NETIPMI_PROVIDER_LIBRARY += "${LIBRARY_NAMES}"
+
+FILES_${PN}_append = " ${libdir}/ipmid-providers/lib*${SOLIBS}"
+FILES_${PN}_append = " ${libdir}/host-ipmid/lib*${SOLIBS}"
+FILES_${PN}_append = " ${libdir}/net-ipmid/lib*${SOLIBS}"
+FILES_${PN}-dev_append = " ${libdir}/ipmid-providers/lib*${SOLIBSDEV}"
+
diff --git a/meta-mct/meta-s5549/recipes-core/os-release/os-release.bbappend b/meta-mct/meta-s5549/recipes-core/os-release/os-release.bbappend
new file mode 100755
index 0000000..ccd3a87
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-core/os-release/os-release.bbappend
@@ -0,0 +1,16 @@
+#
+# These file add version 
+
+python() {
+        d.setVar('VERSION', "v0.01-00-s5549")
+        d.setVar('VERSION_ID', "v0.01-00-s5549")
+        d.setVar('BMC_NAME', "S5549")
+}
+
+OS_RELEASE_FIELDS_append += "BMC_NAME"
+
+# Ensure the git commands run every time bitbake is invoked.
+BB_DONT_CACHE = "1"
+
+# Make os-release available to other recipes.
+SYSROOT_DIRS_append = " ${sysconfdir}"
diff --git a/meta-mct/meta-s5549/recipes-core/systemd/obmc-targets.bbappend b/meta-mct/meta-s5549/recipes-core/systemd/obmc-targets.bbappend
new file mode 100755
index 0000000..fc0244f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-core/systemd/obmc-targets.bbappend
@@ -0,0 +1,3 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+CHASSIS_ACTION_TARGETS += "reset"
diff --git a/meta-mct/meta-s5549/recipes-core/systemd/obmc-targets/obmc-chassis-reset@.target b/meta-mct/meta-s5549/recipes-core/systemd/obmc-targets/obmc-chassis-reset@.target
new file mode 100755
index 0000000..b158179
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-core/systemd/obmc-targets/obmc-chassis-reset@.target
@@ -0,0 +1,6 @@
+[Unit]
+Description=Tiogapass Chassis%i Warm Reset
+Wants=obmc-standby.target
+After=obmc-standby.target
+Conflicts=obmc-chassis-poweroff@%i.target
+RefuseManualStop=no
diff --git a/meta-mct/meta-s5549/recipes-extended/pam/pam-ipmi/ipmi_pass b/meta-mct/meta-s5549/recipes-extended/pam/pam-ipmi/ipmi_pass
new file mode 100755
index 0000000000000000000000000000000000000000..0c5117568d434003e8d6f1daab11c864bcc2733b
GIT binary patch
literal 160
zcmcEZ4{-H!@^!XlU|?_nVgVrL0%A5GRsiB92cGT_@0Ak0zIOTVn{^W+486pr&wFqu
zQL%)j{dmNlQ=7kRTJVv9&9MHb?99cVn5xUzbhhctE<R%W&A%+)@MhJaonN(8x&y3~
zdFBRw*nO^1(1MS_?U{S$p51R2uK&gJHTm}CvkW(HbPF9UG<TR=P`1)0=O@pk4SPI0
L|Fmn~=1KzqL61Y}

literal 0
HcmV?d00001

diff --git a/meta-mct/meta-s5549/recipes-extended/pam/pam-ipmi_git.bbappend b/meta-mct/meta-s5549/recipes-extended/pam/pam-ipmi_git.bbappend
new file mode 100755
index 0000000..1249081
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-extended/pam/pam-ipmi_git.bbappend
@@ -0,0 +1,10 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+
+SRC_URI += "file://ipmi_pass"
+
+do_install_append() { 
+        rm -rf ${D}${sysconfdir}/ipmi_pass
+        install -d ${D}/etc/
+        install -m 0644 ${WORKDIR}/ipmi_pass ${D}${sysconfdir}/ipmi_pass
+}
diff --git a/meta-mct/meta-s5549/recipes-extended/sdbusplus/sdbusplus/0001-Add-new_signal-and-extend-set_property-methods-to-db.patch b/meta-mct/meta-s5549/recipes-extended/sdbusplus/sdbusplus/0001-Add-new_signal-and-extend-set_property-methods-to-db.patch
new file mode 100755
index 0000000..0662a33
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-extended/sdbusplus/sdbusplus/0001-Add-new_signal-and-extend-set_property-methods-to-db.patch
@@ -0,0 +1,61 @@
+From c8b3ade4a35b87c7dda6c790bdf982da6c657c23 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 30 Sep 2020 16:29:10 +0800
+Subject: [PATCH] Add new_signal and extend set_property methods to
+ dbus_interface
+
+---
+ sdbusplus/asio/object_server.hpp | 23 ++++++++++++++++++++++-
+ 1 file changed, 22 insertions(+), 1 deletion(-)
+ mode change 100644 => 100755 sdbusplus/asio/object_server.hpp
+
+diff --git a/sdbusplus/asio/object_server.hpp b/sdbusplus/asio/object_server.hpp
+old mode 100644
+new mode 100755
+index a9d5fbf..2f9e631
+--- a/sdbusplus/asio/object_server.hpp
++++ b/sdbusplus/asio/object_server.hpp
+@@ -494,7 +494,8 @@ class dbus_interface
+ 
+         return true;
+     }
+-    template <typename PropertyType>
++   // template <typename PropertyType>
++    template <typename PropertyType, bool changesOnly = false>    
+     bool set_property(const std::string& name, const PropertyType& value)
+     {
+         if (!initialized_)
+@@ -511,6 +512,11 @@ class dbus_interface
+                 if (status != SetPropertyReturnValue::sameValueUpdated)
+                 {
+                     signal_property(name);
++                    return true;
++                }
++                if constexpr (!changesOnly)
++                {
++                   return true;
+                 }
+                 return true;
+             }
+@@ -693,6 +699,21 @@ class dbus_interface
+         return sd_bus_error_set_const(error, SD_BUS_ERROR_INVALID_ARGS, NULL);
+     }
+ 
++
++    /** @brief Create a new signal message.
++     *
++     *  @param[in] member - The signal name to create.
++     */
++    auto new_signal(const char* member)
++    {
++        if (!initialized_)
++        {
++            return message::message(nullptr);
++        }
++        return interface_->new_signal(member);
++    }
++
++
+     bool initialize(const bool skipPropertyChangedSignal = false)
+     {
+         // can only register once
diff --git a/meta-mct/meta-s5549/recipes-extended/sdbusplus/sdbusplus_git.bbappend b/meta-mct/meta-s5549/recipes-extended/sdbusplus/sdbusplus_git.bbappend
new file mode 100755
index 0000000..e0943a2
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-extended/sdbusplus/sdbusplus_git.bbappend
@@ -0,0 +1,4 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-Add-new_signal-and-extend-set_property-methods-to-db.patch"
+
diff --git a/meta-mct/meta-s5549/recipes-intel/ipmi/intel-ipmi-oem/0001-Force-baseboard-FRU-to-ID0.patch b/meta-mct/meta-s5549/recipes-intel/ipmi/intel-ipmi-oem/0001-Force-baseboard-FRU-to-ID0.patch
new file mode 100755
index 0000000..da1d27c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-intel/ipmi/intel-ipmi-oem/0001-Force-baseboard-FRU-to-ID0.patch
@@ -0,0 +1,25 @@
+From 9c6ab1853f1a3ea051ca2f222ad1b888affa5630 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 14 Dec 2020 15:45:48 +0800
+Subject: [PATCH] Force baseboard FRU to ID0
+
+---
+ src/storagecommands.cpp | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/src/storagecommands.cpp b/src/storagecommands.cpp
+index 4345e0b..ca6e56b 100755
+--- a/src/storagecommands.cpp
++++ b/src/storagecommands.cpp
+@@ -266,7 +266,7 @@ ipmi_ret_t replaceCacheFru(uint8_t devId)
+         uint8_t fruHash = 0;
+         //if (fruBus != 0 || fruAddr != 0)
+         //force basebaord fru id to 0. TODO: move baseboard FRU config to Json 
+-        if (fruBus != 2)
++        if (fruBus != 6)
+         {
+             fruHash = hasher(fru.first.str);
+             // can't be 0xFF based on spec, and 0 is reserved for baseboard
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-intel/ipmi/intel-ipmi-oem_git.bbappend b/meta-mct/meta-s5549/recipes-intel/ipmi/intel-ipmi-oem_git.bbappend
new file mode 100755
index 0000000..aa4b86a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-intel/ipmi/intel-ipmi-oem_git.bbappend
@@ -0,0 +1,5 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-Force-baseboard-FRU-to-ID0.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0004-Set-RTD_1_2_3-to-thermistor-mode.patch b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0004-Set-RTD_1_2_3-to-thermistor-mode.patch
new file mode 100755
index 0000000..828b445
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0004-Set-RTD_1_2_3-to-thermistor-mode.patch
@@ -0,0 +1,28 @@
+From 9061378d68d63abca4ea683416471aeb5f76a8e1 Mon Sep 17 00:00:00 2001
+From: Mirage Su <mirage.su@mic.com.tw>
+Date: Thu, 20 Dec 2018 15:01:32 +0800
+Subject: [PATCH] Set RTD_1_2_3 to thermistor mode
+
+---
+ drivers/hwmon/nct7802.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+ mode change 100644 => 100755 drivers/hwmon/nct7802.c
+
+diff --git a/drivers/hwmon/nct7802.c b/drivers/hwmon/nct7802.c
+old mode 100644
+new mode 100755
+index 2876c18..b070527
+--- a/drivers/hwmon/nct7802.c
++++ b/drivers/hwmon/nct7802.c
+@@ -1093,6 +1093,11 @@ static int nct7802_init_chip(struct nct7802_data *data)
+ 	if (err)
+ 		return err;
+ 
++	/* Set RTD1~RTD3 to thermistor mode */
++	err = regmap_update_bits(data->regmap, REG_MODE, 0x3F, 0x2A);
++	if (err)
++		return err;
++
+ 	/* Enable Vcore and VCC voltage monitoring */
+ 	return regmap_update_bits(data->regmap, REG_VMON_ENABLE, 0x03, 0x03);
+ }
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0005-Support-IPMB-in-OpenBMC.patch b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0005-Support-IPMB-in-OpenBMC.patch
new file mode 100755
index 0000000..391d6f8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0005-Support-IPMB-in-OpenBMC.patch
@@ -0,0 +1,426 @@
+From 59e2471d9bf64fa7d539520ef66cf5f33c0b0e55 Mon Sep 17 00:00:00 2001
+From: Haiyue Wang <haiyue.wang@linux.intel.com>
+Date: Tue, 13 Feb 2018 14:28:12 +0800
+Subject: [PATCH] i2c: slave-mqueue: add mqueue driver to receive ipmi message
+
+Some protocols over I2C are designed for bi-directional transferring
+messages by using I2C Master Write protocol. Like the MCTP (Management
+Component Transport Protocol) and IPMB (Intelligent Platform Management
+Bus), they both require that the userspace can receive messages from
+I2C dirvers under slave mode.
+
+This new slave mqueue backend is used to receive and queue messages, it
+will exposes these messages to userspace by sysfs bin file.
+
+Signed-off-by: Haiyue Wang <haiyue.wang@linux.intel.com>
+---
+ Documentation/i2c/slave-mqueue-backend.rst | 125 +++++++++++++++++
+ drivers/i2c/Kconfig                        |  23 +++
+ drivers/i2c/Makefile                       |   1 +
+ drivers/i2c/i2c-slave-mqueue.c             | 217 +++++++++++++++++++++++++++++
+ 4 files changed, 366 insertions(+)
+ create mode 100644 Documentation/i2c/slave-mqueue-backend.rst
+ create mode 100644 drivers/i2c/i2c-slave-mqueue.c
+
+diff --git a/Documentation/i2c/slave-mqueue-backend.rst b/Documentation/i2c/slave-mqueue-backend.rst
+new file mode 100644
+index 000000000000..3966cf0ab8da
+--- /dev/null
++++ b/Documentation/i2c/slave-mqueue-backend.rst
+@@ -0,0 +1,125 @@
++.. SPDX-License-Identifier: GPL-2.0
++
++=====================================
++Linux I2C slave message queue backend
++=====================================
++
++:Author: Haiyue Wang <haiyue.wang@linux.intel.com>
++
++Some protocols over I2C/SMBus are designed for bi-directional transferring
++messages by using I2C Master Write protocol. This requires that both sides
++of the communication have slave addresses.
++
++Like MCTP (Management Component Transport Protocol) and IPMB (Intelligent
++Platform Management Bus), they both require that the userspace can receive
++messages from i2c dirvers under slave mode.
++
++This I2C slave mqueue (message queue) backend is used to receive and queue
++messages from the remote i2c intelligent device; and it will add the target
++slave address (with R/W# bit is always 0) into the message at the first byte,
++so that userspace can use this byte to dispatch the messages into different
++handling modules. Also, like IPMB, the address byte is in its message format,
++it needs it to do checksum.
++
++For messages are time related, so this backend will flush the oldest message
++to queue the newest one.
++
++Link
++----
++`Intelligent Platform Management Bus
++Communications Protocol Specification
++<https://www.intel.com/content/dam/www/public/us/en/documents/product-briefs/ipmp-spec-v1.0.pdf>`_
++
++`Management Component Transport Protocol (MCTP)
++SMBus/I2C Transport Binding Specification
++<https://www.dmtf.org/sites/default/files/standards/documents/DSP0237_1.1.0.pdf>`_
++
++How to use
++----------
++For example, the I2C5 bus has slave address 0x10, the below command will create
++the related message queue interface:
++
++    echo slave-mqueue 0x1010 > /sys/bus/i2c/devices/i2c-5/new_device
++
++Then you can dump the messages like this:
++
++    hexdump -C /sys/bus/i2c/devices/5-1010/slave-mqueue
++
++Code Example
++------------
++*Note: call 'lseek' before 'read', this is a requirement from kernfs' design.*
++
++::
++
++  #include <sys/types.h>
++  #include <sys/stat.h>
++  #include <unistd.h>
++  #include <poll.h>
++  #include <time.h>
++  #include <fcntl.h>
++  #include <stdio.h>
++
++  int main(int argc, char *argv[])
++  {
++          int i, r;
++          struct pollfd pfd;
++          struct timespec ts;
++          unsigned char data[256];
++
++          pfd.fd = open(argv[1], O_RDONLY | O_NONBLOCK);
++          if (pfd.fd < 0)
++                  return -1;
++
++          pfd.events = POLLPRI;
++
++          while (1) {
++                  r = poll(&pfd, 1, 5000);
++
++                  if (r < 0)
++                          break;
++
++                  if (r == 0 || !(pfd.revents & POLLPRI))
++                          continue;
++
++                  lseek(pfd.fd, 0, SEEK_SET);
++                  r = read(pfd.fd, data, sizeof(data));
++                  if (r <= 0)
++                          continue;
++
++                  clock_gettime(CLOCK_MONOTONIC, &ts);
++                  printf("[%ld.%.9ld] :", ts.tv_sec, ts.tv_nsec);
++                  for (i = 0; i < r; i++)
++                          printf(" %02x", data[i]);
++                  printf("\n");
++          }
++
++          close(pfd.fd);
++
++          return 0;
++  }
++
++Result
++------
++*./a.out "/sys/bus/i2c/devices/5-1010/slave-mqueue"*
++
++::
++
++  [10183.232500449] : 20 18 c8 2c 78 01 5b
++  [10183.479358348] : 20 18 c8 2c 78 01 5b
++  [10183.726556812] : 20 18 c8 2c 78 01 5b
++  [10183.972605863] : 20 18 c8 2c 78 01 5b
++  [10184.220124772] : 20 18 c8 2c 78 01 5b
++  [10184.467764166] : 20 18 c8 2c 78 01 5b
++  [10193.233421784] : 20 18 c8 2c 7c 01 57
++  [10193.480273460] : 20 18 c8 2c 7c 01 57
++  [10193.726788733] : 20 18 c8 2c 7c 01 57
++  [10193.972781945] : 20 18 c8 2c 7c 01 57
++  [10194.220487360] : 20 18 c8 2c 7c 01 57
++  [10194.468089259] : 20 18 c8 2c 7c 01 57
++  [10203.233433099] : 20 18 c8 2c 80 01 53
++  [10203.481058715] : 20 18 c8 2c 80 01 53
++  [10203.727610472] : 20 18 c8 2c 80 01 53
++  [10203.974044856] : 20 18 c8 2c 80 01 53
++  [10204.220734634] : 20 18 c8 2c 80 01 53
++  [10204.468461664] : 20 18 c8 2c 80 01 53
++
+diff --git a/drivers/i2c/Kconfig b/drivers/i2c/Kconfig
+index efc3354d60ae..04fb851f2c82 100644
+--- a/drivers/i2c/Kconfig
++++ b/drivers/i2c/Kconfig
+@@ -118,6 +118,29 @@ if I2C_SLAVE
+ config I2C_SLAVE_EEPROM
+ 	tristate "I2C eeprom slave driver"
+ 
++config I2C_SLAVE_MQUEUE_MESSAGE_SIZE
++	int "The message size of I2C mqueue slave"
++	default 120
++
++config I2C_SLAVE_MQUEUE_QUEUE_SIZE
++	int "The queue size of I2C mqueue slave"
++	default 32
++	help
++	  This number MUST be power of 2.
++
++config I2C_SLAVE_MQUEUE
++	tristate "I2C mqueue (message queue) slave driver"
++	help
++	  Some protocols over I2C are designed for bi-directional transferring
++	  messages by using I2C Master Write protocol. This driver is used to
++	  receive and queue messages from the remote I2C device.
++
++	  Userspace can get the messages by reading sysfs file that this driver
++	  exposes.
++
++	  This support is also available as a module. If so, the module will be
++	  called i2c-slave-mqueue.
++
+ endif
+ 
+ config I2C_DEBUG_CORE
+diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
+index bed6ba63c983..9a31bc75a446 100644
+--- a/drivers/i2c/Makefile
++++ b/drivers/i2c/Makefile
+@@ -16,5 +16,6 @@ obj-$(CONFIG_I2C_MUX)		+= i2c-mux.o
+ obj-y				+= algos/ busses/ muxes/
+ obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
+ obj-$(CONFIG_I2C_SLAVE_EEPROM)	+= i2c-slave-eeprom.o
++obj-$(CONFIG_I2C_SLAVE_MQUEUE)	+= i2c-slave-mqueue.o
+ 
+ ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
+diff --git a/drivers/i2c/i2c-slave-mqueue.c b/drivers/i2c/i2c-slave-mqueue.c
+new file mode 100644
+index 000000000000..6014bca0ff2a
+--- /dev/null
++++ b/drivers/i2c/i2c-slave-mqueue.c
+@@ -0,0 +1,217 @@
++// SPDX-License-Identifier: GPL-2.0
++// Copyright (c) 2017 - 2018, Intel Corporation.
++
++#include <linux/i2c.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/slab.h>
++#include <linux/spinlock.h>
++#include <linux/sysfs.h>
++
++#define MQ_MSGBUF_SIZE		CONFIG_I2C_SLAVE_MQUEUE_MESSAGE_SIZE
++#define MQ_QUEUE_SIZE		CONFIG_I2C_SLAVE_MQUEUE_QUEUE_SIZE
++#define MQ_QUEUE_NEXT(x)	(((x) + 1) & (MQ_QUEUE_SIZE - 1))
++
++struct mq_msg {
++	int	len;
++	u8	*buf;
++};
++
++struct mq_queue {
++	struct bin_attribute	bin;
++	struct kernfs_node	*kn;
++
++	spinlock_t		lock; /* spinlock for queue index handling */
++	int			in;
++	int			out;
++
++	struct mq_msg		*curr;
++	int			truncated; /* drop current if truncated */
++	struct mq_msg		*queue;
++};
++
++static int i2c_slave_mqueue_callback(struct i2c_client *client,
++				     enum i2c_slave_event event, u8 *val)
++{
++	struct mq_queue *mq = i2c_get_clientdata(client);
++	struct mq_msg *msg = mq->curr;
++	int ret = 0;
++
++	switch (event) {
++	case I2C_SLAVE_WRITE_REQUESTED:
++		mq->truncated = 0;
++
++		msg->len = 1;
++		msg->buf[0] = client->addr << 1;
++		break;
++
++	case I2C_SLAVE_WRITE_RECEIVED:
++		if (msg->len < MQ_MSGBUF_SIZE) {
++			msg->buf[msg->len++] = *val;
++		} else {
++			dev_err(&client->dev, "message is truncated!\n");
++			mq->truncated = 1;
++			ret = -EINVAL;
++		}
++		break;
++
++	case I2C_SLAVE_STOP:
++		if (unlikely(mq->truncated || msg->len < 2))
++			break;
++
++		spin_lock(&mq->lock);
++		mq->in = MQ_QUEUE_NEXT(mq->in);
++		mq->curr = &mq->queue[mq->in];
++		mq->curr->len = 0;
++
++		/* Flush the oldest message */
++		if (mq->out == mq->in)
++			mq->out = MQ_QUEUE_NEXT(mq->out);
++		spin_unlock(&mq->lock);
++
++		kernfs_notify(mq->kn);
++		break;
++
++	default:
++		*val = 0xFF;
++		break;
++	}
++
++	return ret;
++}
++
++static ssize_t i2c_slave_mqueue_bin_read(struct file *filp,
++					 struct kobject *kobj,
++					 struct bin_attribute *attr,
++					 char *buf, loff_t pos, size_t count)
++{
++	struct mq_queue *mq;
++	struct mq_msg *msg;
++	unsigned long flags;
++	bool more = false;
++	ssize_t ret = 0;
++
++	mq = dev_get_drvdata(container_of(kobj, struct device, kobj));
++
++	spin_lock_irqsave(&mq->lock, flags);
++	if (mq->out != mq->in) {
++		msg = &mq->queue[mq->out];
++
++		if (msg->len <= count) {
++			ret = msg->len;
++			memcpy(buf, msg->buf, ret);
++		} else {
++			ret = -EOVERFLOW; /* Drop this HUGE one. */
++		}
++
++		mq->out = MQ_QUEUE_NEXT(mq->out);
++		if (mq->out != mq->in)
++			more = true;
++	}
++	spin_unlock_irqrestore(&mq->lock, flags);
++
++	if (more)
++		kernfs_notify(mq->kn);
++
++	return ret;
++}
++
++static int i2c_slave_mqueue_probe(struct i2c_client *client,
++				  const struct i2c_device_id *id)
++{
++	struct device *dev = &client->dev;
++	struct mq_queue *mq;
++	int ret, i;
++	void *buf;
++
++	mq = devm_kzalloc(dev, sizeof(*mq), GFP_KERNEL);
++	if (!mq)
++		return -ENOMEM;
++
++	BUILD_BUG_ON(!is_power_of_2(MQ_QUEUE_SIZE));
++
++	buf = devm_kmalloc_array(dev, MQ_QUEUE_SIZE, MQ_MSGBUF_SIZE,
++				 GFP_KERNEL);
++	if (!buf)
++		return -ENOMEM;
++
++	mq->queue = devm_kzalloc(dev, sizeof(*mq->queue) * MQ_QUEUE_SIZE,
++				 GFP_KERNEL);
++	if (!buf)
++		return -ENOMEM;
++
++	for (i = 0; i < MQ_QUEUE_SIZE; i++)
++		mq->queue[i].buf = buf + i * MQ_MSGBUF_SIZE;
++
++	i2c_set_clientdata(client, mq);
++
++	spin_lock_init(&mq->lock);
++	mq->curr = &mq->queue[0];
++
++	sysfs_bin_attr_init(&mq->bin);
++	mq->bin.attr.name = "slave-mqueue";
++	mq->bin.attr.mode = 0400;
++	mq->bin.read = i2c_slave_mqueue_bin_read;
++	mq->bin.size = MQ_MSGBUF_SIZE * MQ_QUEUE_SIZE;
++
++	ret = sysfs_create_bin_file(&dev->kobj, &mq->bin);
++	if (ret)
++		return ret;
++
++	mq->kn = kernfs_find_and_get(dev->kobj.sd, mq->bin.attr.name);
++	if (!mq->kn) {
++		sysfs_remove_bin_file(&dev->kobj, &mq->bin);
++		return -EFAULT;
++	}
++
++	ret = i2c_slave_register(client, i2c_slave_mqueue_callback);
++	if (ret) {
++		kernfs_put(mq->kn);
++		sysfs_remove_bin_file(&dev->kobj, &mq->bin);
++		return ret;
++	}
++
++	return 0;
++}
++
++static int i2c_slave_mqueue_remove(struct i2c_client *client)
++{
++	struct mq_queue *mq = i2c_get_clientdata(client);
++
++	i2c_slave_unregister(client);
++
++	kernfs_put(mq->kn);
++	sysfs_remove_bin_file(&client->dev.kobj, &mq->bin);
++
++	return 0;
++}
++
++static const struct i2c_device_id i2c_slave_mqueue_id[] = {
++	{ "slave-mqueue", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, i2c_slave_mqueue_id);
++
++#if IS_ENABLED(CONFIG_OF)
++static const struct of_device_id i2c_slave_mqueue_of_match[] = {
++	{ .compatible = "slave-mqueue", .data = (void *)0 },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, i2c_slave_mqueue_of_match);
++#endif
++
++static struct i2c_driver i2c_slave_mqueue_driver = {
++	.driver = {
++		.name	= "i2c-slave-mqueue",
++		.of_match_table = of_match_ptr(i2c_slave_mqueue_of_match),
++	},
++	.probe		= i2c_slave_mqueue_probe,
++	.remove		= i2c_slave_mqueue_remove,
++	.id_table	= i2c_slave_mqueue_id,
++};
++module_i2c_driver(i2c_slave_mqueue_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
++MODULE_DESCRIPTION("I2C slave mode for receiving and queuing messages");
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0006-Modified-ibm-cffps-driver.patch b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0006-Modified-ibm-cffps-driver.patch
new file mode 100755
index 0000000..8582033
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0006-Modified-ibm-cffps-driver.patch
@@ -0,0 +1,24 @@
+From a890120c9f7b3584e14d9a0c6892132c309cf2f7 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 19 Sep 2019 21:02:49 +0800
+Subject: [PATCH 1/1] Modified ibm-cffps driver
+
+---
+ drivers/hwmon/pmbus/ibm-cffps.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/hwmon/pmbus/ibm-cffps.c b/drivers/hwmon/pmbus/ibm-cffps.c
+index d44745e498e7..85d1471d0755 100644
+--- a/drivers/hwmon/pmbus/ibm-cffps.c
++++ b/drivers/hwmon/pmbus/ibm-cffps.c
+@@ -367,6 +367,7 @@ static struct pmbus_driver_info ibm_cffps_info[] = {
+ 			PMBUS_HAVE_TEMP2 | PMBUS_HAVE_TEMP3 |
+ 			PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_STATUS_IOUT |
+ 			PMBUS_HAVE_STATUS_INPUT | PMBUS_HAVE_STATUS_TEMP |
++            PMBUS_HAVE_POUT |
+ 			PMBUS_HAVE_STATUS_FAN12,
+ 		.read_byte_data = ibm_cffps_read_byte_data,
+ 		.read_word_data = ibm_cffps_read_word_data,
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0007-Fix-fan-sensor-disappear-when-power-off-problem.patch b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0007-Fix-fan-sensor-disappear-when-power-off-problem.patch
new file mode 100755
index 0000000..a9646ef
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0007-Fix-fan-sensor-disappear-when-power-off-problem.patch
@@ -0,0 +1,26 @@
+From 7fd23c60ff607c57bb52475fafde9aa21ceb9381 Mon Sep 17 00:00:00 2001
+From: OpenEmbedded <oe.patch@oe>
+Date: Wed, 13 Mar 2019 16:36:01 +0800
+Subject: [PATCH] Fix fan sensor disappear when power off problem
+
+---
+ drivers/hwmon/aspeed-pwm-tacho.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/hwmon/aspeed-pwm-tacho.c b/drivers/hwmon/aspeed-pwm-tacho.c
+index 5e449ea..f949eb2 100644
+--- a/drivers/hwmon/aspeed-pwm-tacho.c
++++ b/drivers/hwmon/aspeed-pwm-tacho.c
+@@ -549,8 +549,10 @@ static int aspeed_get_fan_tach_ch_rpm(struct aspeed_pwm_tacho_data *priv,
+ 		usec);
+ 
+ 	/* return -ETIMEDOUT if we didn't get an answer. */
+-	if (ret)
+-		return ret;
++	//if (ret)
++	//	return ret;
++        if (ret)
++            val = 0 ;       //mitac add
+ 
+ 	raw_data = val & RESULT_VALUE_MASK;
+ 	tach_div = priv->type_fan_tach_clock_division[type];
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0008-increase-rofs-space.patch b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0008-increase-rofs-space.patch
new file mode 100755
index 0000000..fa10995
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0008-increase-rofs-space.patch
@@ -0,0 +1,28 @@
+From 2c5a48e2535ac16ff08590df12a7b85a9a24e225 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Fri, 16 Aug 2019 16:58:19 +0800
+Subject: [PATCH] increase rofs space
+
+---
+ arch/arm/boot/dts/openbmc-flash-layout.dtsi | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/arch/arm/boot/dts/openbmc-flash-layout.dtsi b/arch/arm/boot/dts/openbmc-flash-layout.dtsi
+index 6c26524e93e1..08a9570a8256 100644
+--- a/arch/arm/boot/dts/openbmc-flash-layout.dtsi
++++ b/arch/arm/boot/dts/openbmc-flash-layout.dtsi
+@@ -21,12 +21,12 @@ partitions {
+ 	};
+ 
+ 	rofs@c0000 {
+-		reg = <0x4c0000 0x1740000>;
++		reg = <0x4c0000 0x2340000>;
+ 		label = "rofs";
+ 	};
+ 
+ 	rwfs@1c00000 {
+-		reg = <0x1c00000 0x400000>;
++		reg = <0x2800000 0x1800000>;
+ 		label = "rwfs";
+ 	};
+ };
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0009-Register-all-of-dimm-sensors-when-initializing.patch b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0009-Register-all-of-dimm-sensors-when-initializing.patch
new file mode 100755
index 0000000..3959b02
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0009-Register-all-of-dimm-sensors-when-initializing.patch
@@ -0,0 +1,25 @@
+From f119fb599427c84ae08562e6c1d599e2d251afd9 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 5 May 2020 15:54:31 +0800
+Subject: [PATCH] Register all of dimm sensors when initializing
+
+---
+ drivers/hwmon/peci-dimmtemp.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/hwmon/peci-dimmtemp.c b/drivers/hwmon/peci-dimmtemp.c
+index 45eabd2..0ff37d2 100644
+--- a/drivers/hwmon/peci-dimmtemp.c
++++ b/drivers/hwmon/peci-dimmtemp.c
+@@ -233,7 +233,7 @@ static int check_populated_dimms(struct peci_dimmtemp *priv)
+ 		}
+ 
+ 		for (dimm_idx = 0; dimm_idx < dimm_idx_max; dimm_idx++)
+-			if (cfg_data[dimm_idx])
++			// if (cfg_data[dimm_idx])
+ 				priv->dimm_mask |= BIT(chan_rank *
+ 						       dimm_idx_max +
+ 						       dimm_idx);
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0010-change-aspeed-rpm-driver-to-falling-edge.patch b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0010-change-aspeed-rpm-driver-to-falling-edge.patch
new file mode 100755
index 0000000..8827454
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/0010-change-aspeed-rpm-driver-to-falling-edge.patch
@@ -0,0 +1,37 @@
+From ec2b3e2f256d10c15e1f85e89edb2b946d61e70b Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 11 Aug 2020 13:24:14 +0800
+Subject: [PATCH 1/1] change aspeed rpm driver to falling edge
+
+---
+ drivers/hwmon/aspeed-pwm-tacho.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+ mode change 100644 => 100755 drivers/hwmon/aspeed-pwm-tacho.c
+
+diff --git a/drivers/hwmon/aspeed-pwm-tacho.c b/drivers/hwmon/aspeed-pwm-tacho.c
+old mode 100644
+new mode 100755
+index b0eb1f754626..caefeaf0cc9b
+--- a/drivers/hwmon/aspeed-pwm-tacho.c
++++ b/drivers/hwmon/aspeed-pwm-tacho.c
+@@ -146,6 +146,8 @@
+ #define PWM_MAX 255
+ 
+ #define BOTH_EDGES 0x02 /* 10b */
++#define FALLING_EDGES 0x00 /* 10b */
++
+ 
+ #define M_PWM_DIV_H 0x00
+ #define M_PWM_DIV_L 0x05
+@@ -158,7 +160,7 @@
+  * 10: both
+  * 11: reserved.
+  */
+-#define M_TACH_MODE 0x02 /* 10b */
++#define M_TACH_MODE FALLING_EDGES /* 10b */
+ #define M_TACH_UNIT 0x0210
+ #define INIT_FAN_CTRL 0xFF
+ 
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/aspeed-bmc-mct-s5549.dts b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/aspeed-bmc-mct-s5549.dts
new file mode 100755
index 0000000..2fbb87f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/aspeed-bmc-mct-s5549.dts
@@ -0,0 +1,380 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2017 Intel Corporation
+/dts-v1/;
+
+#include "aspeed-g5.dtsi"
+#include <dt-bindings/gpio/aspeed-gpio.h>
+
+/ {
+    model = "s5549 BMC";
+    compatible = "mct,s5549-bmc", "aspeed,ast2500";
+
+    chosen {
+        stdout-path = &uart5;
+        bootargs = "earlyprintk";
+    };
+
+    memory {
+        reg = <0x80000000 0x20000000>;
+    };
+
+    reserved-memory {
+        #address-cells = <1>;
+        #size-cells = <1>;
+        ranges;
+
+        flash_memory: region@98000000 {
+            no-map;
+            reg = <0x98000000 0x02000000>; /* 32M */
+        };
+
+		ramoops@9c000000 {
+			compatible = "ramoops";
+			reg = <0x9c000000 0x180000>; /* 16 * (3 * 0x8000) */
+			record-size = <0x8000>;
+			console-size = <0x8000>;
+			pmsg-size = <0x8000>;
+			max-reason = <3>; /* KMSG_DUMP_EMERG */
+		};
+
+		gfx_memory: framebuffer@9f000000 {
+			no-map;
+			compatible = "shared-dma-pool";
+			reg = <0x9f000000 0x01000000>; /* 16M */
+        };
+
+    };
+
+    leds {
+        compatible = "gpio-leds";
+
+        power {
+            gpios = <&gpio ASPEED_GPIO(F, 4) GPIO_ACTIVE_HIGH>;
+        };
+
+        identify {
+            gpios = <&gpio ASPEED_GPIO(S, 6) GPIO_ACTIVE_HIGH>;
+        };
+
+        hw-fault {
+            gpios = <&gpio ASPEED_GPIO(F, 5) GPIO_ACTIVE_LOW>;
+        };
+
+        BIOS-POST-D1 {
+            gpios = <&gpio ASPEED_GPIO(P, 0) GPIO_ACTIVE_LOW>;
+        };
+
+        BIOS-POST-D2 {
+            gpios = <&gpio ASPEED_GPIO(P, 1) GPIO_ACTIVE_LOW>;
+        };
+
+        BIOS-POST-D3 {
+            gpios = <&gpio ASPEED_GPIO(P, 2) GPIO_ACTIVE_LOW>;
+        };
+
+        BIOS-POST-D4 {
+            gpios = <&gpio ASPEED_GPIO(P, 3) GPIO_ACTIVE_LOW>;
+        };
+
+        BIOS-POST-D5 {
+            gpios = <&gpio ASPEED_GPIO(P, 4) GPIO_ACTIVE_LOW>;
+        };
+
+        BIOS-POST-D6 {
+            gpios = <&gpio ASPEED_GPIO(P, 5) GPIO_ACTIVE_LOW>;
+        };
+
+        BIOS-POST-D7 {
+            gpios = <&gpio ASPEED_GPIO(P, 6) GPIO_ACTIVE_LOW>;
+        };
+
+        BIOS-POST-D8 {
+            gpios = <&gpio ASPEED_GPIO(P, 7) GPIO_ACTIVE_LOW>;
+        };
+    };
+
+    iio-hwmon {
+        compatible = "iio-hwmon";
+        io-channels = <&adc 0>, <&adc 1>, <&adc 2>, <&adc 3>,
+            <&adc 4>, <&adc 5>, <&adc 6>, <&adc 7>,
+            <&adc 8>, <&adc 9>, <&adc 10>, <&adc 11>,
+            <&adc 12>, <&adc 13>, <&adc 14>, <&adc 15>;
+    };
+};
+
+&fmc {
+    status = "okay";
+    flash@0 {
+        status = "okay";
+        m25p,fast-read;
+        label = "bmc";
+#include "openbmc-flash-layout.dtsi"
+    };
+};
+
+&spi1 {
+    status = "okay";
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_spi1_default>;
+
+    flash@0 {
+        status = "okay";
+        m25p,fast-read;
+        label = "pnor";
+    };
+};
+
+&vuart {
+       status = "okay";
+};
+
+&uart1 {
+    status = "okay";
+   pinctrl-names = "default";
+   pinctrl-0 = <&pinctrl_txd1_default
+            &pinctrl_rxd1_default
+            &pinctrl_ncts1_default
+            &pinctrl_ndcd1_default
+            &pinctrl_ndsr1_default
+            &pinctrl_nri1_default
+            &pinctrl_ndtr1_default
+            &pinctrl_nrts1_default>;
+};
+
+&uart2 {
+    status = "okay";
+    pinctrl-names = "default";
+   pinctrl-0 = <&pinctrl_txd2_default
+            &pinctrl_rxd2_default
+            &pinctrl_ncts2_default
+            &pinctrl_ndcd2_default
+            &pinctrl_ndsr2_default
+            &pinctrl_nri2_default
+            &pinctrl_ndtr2_default
+            &pinctrl_nrts2_default>;
+};
+
+&uart3 {
+    status = "okay";
+};
+
+&uart5 {
+    status = "okay";
+};
+/*
+&mac0 {
+    status = "okay";
+    
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_rmii1_default>;
+    use-ncsi;
+};
+*/
+&mac1 {
+    status = "okay";
+
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_rgmii2_default>;
+};
+
+&i2c0 {
+    status = "okay";
+};
+
+&i2c1 {
+    status = "okay";
+};
+
+&i2c2 {
+    status = "okay";
+};
+
+&i2c3 {
+    status = "okay";
+};
+
+&i2c4 {
+    status = "okay";
+};
+
+&i2c5 {
+    status = "okay";
+    multi-master =<1>;
+    ipmb@10 {
+        compatible = "ipmb-dev";
+        reg = <0x10>;
+        i2c-protocol;
+
+    };
+};
+
+&i2c6 {
+    status = "okay";
+    eeprom@50 {
+        compatible = "atmel,24c1024";
+        reg = <0x50>;
+        pagesize = <32>;
+    };
+};
+
+&i2c7 {
+    status = "okay";
+    power-supply@58 {
+        compatible = "ibm,cffps1";
+        reg = <0x58>;
+    };
+};
+
+&gfx {
+       status = "okay";
+       memory-region = <&gfx_memory>;
+};
+
+&video {
+       status = "okay";
+       memory-region = <&gfx_memory>;
+};
+
+&vhub {
+       status = "okay";
+};
+
+&pwm_tacho {
+    status = "okay";
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_pwm0_default &pinctrl_pwm1_default &pinctrl_pwm2_default &pinctrl_pwm3_default &pinctrl_pwm4_default &pinctrl_pwm5_default>;
+    sysfan1@0 {
+        reg = <0x00>;
+        aspeed,fan-tach-ch = /bits/ 8 <0x00>;
+    };
+
+    sysfan2@1 {
+        reg = <0x01>;
+        aspeed,fan-tach-ch = /bits/ 8 <0x01>;
+    };
+
+    sysfan3@2 {
+        reg = <0x02>;
+        aspeed,fan-tach-ch = /bits/ 8 <0x02>;
+    };
+
+    sysfan4@3 {
+        reg = <0x03>;
+        aspeed,fan-tach-ch = /bits/ 8 <0x03>;
+    };
+
+    sysfan5@4 {
+        reg = <0x04>;
+        aspeed,fan-tach-ch = /bits/ 8 <0x04>;
+    };
+
+    sysfan5@5 {
+        reg = <0x05>;
+        aspeed,fan-tach-ch = /bits/ 8 <0x05>;
+    };
+};
+
+&lpc_ctrl {
+    status = "okay";
+    memory-region = <&flash_memory>;
+    flash = <&spi1>;
+};
+
+&adc {
+    status = "okay";
+};
+
+&lpc_bmc {
+    compatible = "aspeed,ast2500-lpc-bmc", "simple-mfd", "syscon";        
+    reg = <0x0 0x80>;
+    reg-io-width = <4>;
+    #address-cells = <1>;
+    #size-cells = <1>;
+    ranges = <0x0 0x0 0x80>;
+
+    kcs1@0 {
+        compatible = "aspeed,ast2500-kcs-bmc";
+        reg = <0x0 0x80>;
+        interrupts = <8>;
+        kcs_chan = <1>;
+        kcs_addr = <0xca0>;
+        status = "okay";
+    };
+
+    kcs2@0 {
+        compatible = "aspeed,ast2500-kcs-bmc";
+        reg = <0x0 0x80>;
+        interrupts = <8>;
+        kcs_chan = <2>;
+        kcs_addr = <0xca8>;
+        status = "okay";
+    };
+
+    kcs3@0 {
+        compatible = "aspeed,ast2500-kcs-bmc";
+        reg = <0x0 0x80>;
+        interrupts = <8>;
+        kcs_chan = <3>;
+        kcs_addr = <0xca2>;
+        status = "okay";
+    };    
+
+    interrupt {
+        status = "okay";
+        compatible = "aspeed,bmc-misc";
+        interrupts-extended = <&scu_ic 4>;
+        lpc-rst {
+            offset = <0x08>;
+            bit-mask = <1>;
+            bit-shift = <6>;
+        };
+    };
+
+};
+
+&hbled {
+    status = "okay";
+};
+
+&peci0 {
+    status = "okay";
+};
+
+&gpio {
+    status = "okay";
+    gpio-line-names =
+    /*A0-A7*/   "","","BMC_EUP_LOT6","","","","","",
+    /*B0-B7*/   "","","","","","","PROCHOT","",
+    /*C0-C7*/   "","","","","","","","",
+    /*D0-D7*/   "","","","","","PHY_RST","","CLR_CMOS",
+    /*E0-E7*/   "","RSTBTN_OUT","","","","","","",
+    /*F0-F7*/   "PCH_NMI","","","","","","","",
+    /*G0-G7*/   "","CATERR","","","BAT_MON","","","BIOS_SPI_SW",
+    /*H0-H7*/   "","","","SYS_FAULT1","","","SYS_FAULT2","",
+    /*I0-I7*/   "","","","","","","","",
+    /*J0-J7*/   "","","","","","","","",
+    /*K0-K7*/   "","","","","","","","",
+    /*L0-L7*/   "","","","","","","","",
+    /*M0-M7*/   "","","","","","","","",
+    /*N0-N7*/   "","","","","","","","",
+    /*O0-O7*/   "","","","","","","","",
+    /*P0-P7*/   "","","","","","","","",
+    /*Q0-Q7*/   "","","","","","","FLASH_SEC_OVRD","",
+    /*R0-R7*/   "THERMTRIP","","","","","","","",
+    /*S0-S7*/   "ID_BUTTON","PS_PWROK","","","","","","",
+    /*T0-T7*/   "","","","","","","","",
+    /*U0-U7*/   "","","","","","","","",
+    /*V0-V7*/   "","","","","","","","",
+    /*W0-W7*/   "","","","","","","","",
+    /*X0-X7*/   "","","","","","","","",
+    /*Y0-Y7*/   "","","","","","","","",
+    /*Z0-Z7*/   "","","PWRBTN_OUT","PCH_SCI_LPC","","","","",
+    /*AA0-AA7*/ "","","","","","","","",
+    /*AB0-AB7*/ "","","","","","","","",
+    /*AC0-AC7*/ "","","","","","","","";
+};
+
+&lpc_snoop {
+    status = "okay";
+    snoop-ports = <0x80>;
+};
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/s5549.cfg b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/s5549.cfg
new file mode 100755
index 0000000..b1caf2e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed/s5549.cfg
@@ -0,0 +1,66 @@
+CONFIG_HWMON=y
+CONFIG_SENSORS_NCT7802=y
+
+CONFIG_DEVMEM=y
+CONFIG_DEVMEM_BOOTPARAM=n
+
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+
+CONFIG_IPMI_KCS_BMC=y
+CONFIG_ASPEED_KCS_IPMI_BMC=y
+CONFIG_ASPEED_G5_HBLED=y
+
+CONFIG_I2C_SLAVE=y
+CONFIG_I2C_SLAVE_MQUEUE=y
+
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_ASPEED=y
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+CONFIG_USB_GADGET=y
+CONFIG_U_SERIAL_CONSOLE=y
+CONFIG_USB_ASPEED_VHUB=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_PRINTER=y
+
+
+CONFIG_USB_F_HID
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_V4L2=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_ASPEED_UART_ROUTING=Y
+
+CONFIG_PECI=y
+CONFIG_PECI_ASPEED=y
+CONFIG_PECI_CHARDEV=y
+CONFIG_SENSORS_PECI_CPUTEMP=y
+CONFIG_SENSORS_PECI_DIMMTEMP=y
+CONFIG_MFD_INTEL_PECI_CLIENT=y
+
+CONFIG_I2C_MUX_GPIO=y
+CONFIG_SPI=y
+
+CONFIG_IPMB_DEVICE_INTERFACE=y
+
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
diff --git a/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed_git.bbappend b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed_git.bbappend
new file mode 100755
index 0000000..d47d82c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-kernel/linux/linux-aspeed_git.bbappend
@@ -0,0 +1,13 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+
+SRC_URI += "file://s5549.cfg \
+            file://aspeed-bmc-mct-s5549.dts;subdir=git/arch/${ARCH}/boot/dts \
+            file://0004-Set-RTD_1_2_3-to-thermistor-mode.patch \
+            file://0006-Modified-ibm-cffps-driver.patch \
+            file://0007-Fix-fan-sensor-disappear-when-power-off-problem.patch \
+            file://0008-increase-rofs-space.patch \
+            file://0009-Register-all-of-dimm-sensors-when-initializing.patch \
+            file://0010-change-aspeed-rpm-driver-to-falling-edge.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/bios-update.bb b/meta-mct/meta-s5549/recipes-phosphor/bios/bios-update.bb
new file mode 100755
index 0000000..9a8fa27
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/bios-update.bb
@@ -0,0 +1,49 @@
+SUMMARY = "MCT BIOS update utility"
+DESCRIPTION = "MCT BIOS update utility."
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+FILESEXTRAPATHS_append := "${THISDIR}/files:"
+
+#inherit skeleton-python
+#inherit native
+#inherit obmc-phosphor-license
+#inherit obmc-phosphor-dbus-service
+inherit obmc-phosphor-systemd
+
+S = "${WORKDIR}/"
+
+SRC_URI = "file://bios_update.py \
+           file://update_bios.sh \
+           file://org.openbmc.control.BiosFlash.conf \
+           file://setup.py \
+           file://bios-update \
+           file://image-active \
+           "
+
+DEPENDS = "systemd"
+
+RDEPENDS_${PN} += "\
+        python-dbus \
+        python-compression \
+        python-shell \
+        python-pygobject \
+        python-subprocess \
+        python-io \
+        pyphosphor-dbus \
+        "
+
+#DBUS_SERVICE_${PN} += "org.openbmc.control.BiosFlash.service"
+SYSTEMD_PACKAGES = "${PN}"
+SYSTEMD_SERVICE_${PN} = "org.openbmc.control.BiosFlash.service"
+
+do_install() {
+    install -d ${D}/usr/sbin
+    install -m 0755 ${S}bios_update.py ${D}/${sbindir}/
+    install -m 0755 ${S}update_bios.sh ${D}/${sbindir}/
+    install -m 0755 ${S}bios-update ${D}/${sbindir}/
+    install -m 0755 ${S}image-active ${D}/${sbindir}/
+    install -d ${D}/etc/dbus-1/system.d/
+    install ${s}org.openbmc.control.BiosFlash.conf ${D}/etc/dbus-1/system.d/
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/bios-update/org.openbmc.control.BiosFlash.service b/meta-mct/meta-s5549/recipes-phosphor/bios/bios-update/org.openbmc.control.BiosFlash.service
new file mode 100755
index 0000000..a7a45b3
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/bios-update/org.openbmc.control.BiosFlash.service
@@ -0,0 +1,15 @@
+[Unit]
+Description=MCT BIOS Code Update
+Wants=mapper-wait@-org-openbmc-managers-Download.service
+After=mapper-wait@-org-openbmc-managers-Download.service
+
+[Service]
+Restart=always
+ExecStart=/usr/bin/env bios_update.py
+SyslogIdentifier=bios_update.py
+Environment="PYTHONUNBUFFERED=1"
+Type=dbus
+BusName=org.openbmc.control.BiosFlash
+
+[Install]
+WantedBy={SYSTEMD_DEFAULT_TARGET}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/Makefile b/meta-mct/meta-s5549/recipes-phosphor/bios/files/Makefile
new file mode 100755
index 0000000..7967f8d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/Makefile
@@ -0,0 +1 @@
+include py.mk
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/bios-update b/meta-mct/meta-s5549/recipes-phosphor/bios/files/bios-update
new file mode 100755
index 0000000..680bf9a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/bios-update
@@ -0,0 +1,130 @@
+#!/bin/sh
+
+set -e
+
+POWER_CMD="/usr/bin/obmcutil"
+GPIO_SET_CMD="/usr/bin/gpioset"
+IMAGE_FILE=$1
+GPIOJ0=72
+GPIOJ1=73
+
+IPMB_OBJ="xyz.openbmc_project.Ipmi.Channel.Ipmb"
+IPMB_PATH="/xyz/openbmc_project/Ipmi/Channel/Ipmb"
+IPMB_INTF="org.openbmc.Ipmb"
+IPMB_CALL="sendRequest yyyyay"
+ME_CMD_RECOVER="1 0x2e 0 0xdf 4 0x57 0x01 0x00 0x01"
+ME_CMD_RESET="1 6 0 0x2 0"
+SPI_DEV="1e630000.spi"
+SPI_PATH="/sys/bus/platform/drivers/aspeed-smc"
+
+MTD_MAX=10
+
+set_gpio_value()
+{
+    $GPIO_SET_CMD gpiochip0 $1=$2
+}
+
+set_gpio_to_bmc()
+{
+    echo "switch bios GPIO to bmc"
+
+    set_gpio_value $GPIOJ0 0
+    set_gpio_value $GPIOJ1 1
+
+    return 0
+}
+
+set_gpio_to_pch()
+{
+    echo "switch bios GPIO to pch"
+
+    set_gpio_value $GPIOJ0 1
+    set_gpio_value $GPIOJ1 0
+
+    return 0
+}
+
+echo "Bios upgrade started at $(date)"
+
+if [ -e "$IMAGE_FILE" ];
+then
+    echo "Bios image is $IMAGE_FILE"
+else
+    echo "Bios image $IMAGE_FILE doesn't exist"
+    exit 1
+fi
+
+#Power off host server.
+echo "Power off host server"
+$POWER_CMD poweroff
+sleep 15
+if [ $($POWER_CMD hoststate|awk 'NR==1 {print $3}'|cut -d . -f 6) != "Off" ];
+then
+    echo "Host server didn't power off"
+    echo "Bios upgrade failed"
+    exit -1
+fi
+echo "Host server powered off"
+
+#Set ME to recovery mode
+echo "Set ME to recovery mode"
+busctl call $IPMB_OBJ $IPMB_PATH $IPMB_INTF $IPMB_CALL $ME_CMD_RECOVER
+sleep 5
+
+#Flip GPIO to access SPI flash used by host.
+echo "Set GPIO to access SPI flash from BMC used by host"
+set_gpio_to_bmc
+sleep 5
+
+#Bind spi driver to access flash
+echo "bind aspeed-smc spi driver"
+echo -n $SPI_DEV > $SPI_PATH/bind
+sleep 1
+
+#Flashcp image to device.
+for d in $(seq 1 $MTD_MAX) ; do
+    if [ -e "/dev/mtd$d" ]; then
+        mtd=`cat /sys/class/mtd/mtd$d/name`
+        if [ $mtd == "pnor" ]; then
+            echo "Flashing bios image to mtd$d..."
+            flashcp -v $IMAGE_FILE /dev/mtd$d
+            if [ $? -eq 0 ]; then
+                echo "bios updated successfully..."
+            else
+                echo "bios update failed..."
+            fi
+            break
+        fi
+        echo "$d is not a pnor device"
+    fi
+    echo "$d not available"
+done
+
+#Unbind spi driver
+sleep 1
+echo "Unbind aspeed-smc spi driver"
+echo -n $SPI_DEV > $SPI_PATH/unbind
+sleep 10
+
+#Flip GPIO back for host to access SPI flash
+echo "Set GPIO $GPIO back for host to access SPI flash"
+set_gpio_to_pch
+sleep 5
+
+#Reset ME to boot from new bios
+echo "Reset ME to boot from new bios"
+busctl call $IPMB_OBJ $IPMB_PATH $IPMB_INTF $IPMB_CALL $ME_CMD_RESET
+sleep 10
+
+#Power on server
+echo "Power on server"
+$POWER_CMD chassison
+sleep 5
+
+# Retry to power on once again if server didn't powered on
+if [ $($POWER_CMD hoststate|awk 'NR==1 {print $3}'|cut -d . -f 6) != "Running" ];
+then
+    sleep 5
+    echo "Powering on server again"
+    $POWER_CMD chassison
+fi
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/bios_update.py b/meta-mct/meta-s5549/recipes-phosphor/bios/files/bios_update.py
new file mode 100755
index 0000000..0d356eb
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/bios_update.py
@@ -0,0 +1,310 @@
+#!/usr/bin/env python
+
+# TODO: openbmc/openbmc#2994 remove python 2 support
+try:  # python 2
+    import gobject
+except ImportError:  # python 3
+    from gi.repository import GObject as gobject
+import dbus
+import dbus.service
+import dbus.mainloop.glib
+import subprocess
+import tempfile
+import shutil
+import tarfile
+import time
+import os, sys
+from obmc.dbuslib.bindings import get_dbus, DbusProperties, DbusObjectManager
+
+DBUS_NAME = 'org.openbmc.control.BiosFlash'
+OBJ_NAME = '/org/openbmc/control/flash/bios'
+DOWNLOAD_INTF = 'org.openbmc.managers.Download'
+
+HOST_DBUS_NAME = 'xyz.openbmc_project.State.Host'
+HOST_OBJ_NAME =  '/xyz/openbmc_project/state/host0'
+
+IPMB_OBJ="xyz.openbmc_project.Ipmi.Channel.Ipmb"
+IPMB_PATH="/xyz/openbmc_project/Ipmi/Channel/Ipmb"
+IPMB_INTF="org.openbmc.Ipmb"
+IPMB_CALL="sendRequest yyyyay"
+ME_CMD_RECOVER="1 0x2e 0 0xdf 4 0x57 0x01 0x00 0x01"
+ME_CMD_RESET="1 6 0 0x2 0"
+
+UPDATE_PATH = '/tmp'
+
+def doExtract(members, files):
+    for tarinfo in members:
+        if tarinfo.name in files:
+            yield tarinfo
+
+def save_fw_env():
+    fw_env = "/etc/fw_env.config"
+    lines = 0
+    files = []
+    envcfg = open(fw_env, 'r')
+    try:
+        for line in envcfg.readlines():
+            # ignore lines that are blank or start with #
+            if (line.startswith("#")):
+                continue
+            if (not len(line.strip())):
+                continue
+            fn = line.partition("\t")[0]
+            files.append(fn)
+            lines += 1
+    finally:
+        envcfg.close()
+    if (lines < 1 or lines > 2 or (lines == 2 and files[0] != files[1])):
+            raise Exception("Error parsing %s\n" % fw_env)
+    shutil.copyfile(files[0], os.path.join(UPDATE_PATH, "image-u-boot-env"))
+
+class BiosFlashControl(DbusProperties, DbusObjectManager):
+    def __init__(self, bus, name):
+        super(BiosFlashControl, self).__init__(
+            conn=bus,
+            object_path=name)
+
+        self.Set(DBUS_NAME, "status", "Idle")
+        self.Set(DBUS_NAME, "filename", "")
+        self.Set(DBUS_NAME, "prepare_update", False)
+
+        bus.add_signal_receiver(
+            self.download_error_handler, signal_name="DownloadError")
+        bus.add_signal_receiver(
+            self.download_complete_handler, signal_name="DownloadComplete")
+
+        self.update_process = None
+        self.progress_name = None
+
+    @dbus.service.method(
+        DBUS_NAME, in_signature='ss', out_signature='')
+    def updateBIOSViaTftp(self, ip, filename):
+        self.Set(DBUS_NAME, "status", "Downloading")
+        self.TftpDownload(ip, filename)
+
+    @dbus.service.method(
+        DBUS_NAME, in_signature='s', out_signature='')
+    def update(self, filename):
+        self.Set(DBUS_NAME, "filename", filename)
+        self.download_complete_handler(filename, filename)
+
+    @dbus.service.signal(DOWNLOAD_INTF, signature='ss')
+    def TftpDownload(self, ip, filename):
+        self.Set(DBUS_NAME, "filename", filename)
+        pass
+
+    # Signal handler
+    def download_error_handler(self, filename):
+        if (filename == self.Get(DBUS_NAME, "filename")):
+            self.Set(DBUS_NAME, "status", "Download Error")
+
+    def download_complete_handler(self, outfile, filename):
+        # do update
+        if (filename != self.Get(DBUS_NAME, "filename")):
+            return
+
+        print("Download complete. Updating...")
+
+        self.Set(DBUS_NAME, "status", "Download Complete")
+        copy_files = {}
+
+        # determine needed files
+        copy_files["image-bios-pnor"] = True
+
+        # copy BIOS image under /run/initramfs path
+        dst = os.path.join(UPDATE_PATH, filename)
+        shutil.copyfile(outfile, dst)
+        os.remove(outfile)
+        
+        p=subprocess.Popen('ls /run/initramfs', shell=True, stdout=subprocess.PIPE)
+        data = p.stdout.read()
+        num = data.find(filename)
+        
+        if num >= 0:
+            self.Set(DBUS_NAME, "status", "Image ready to apply.")
+        else:
+            self.Set(DBUS_NAME, "status", "No image-bios-pnor file under /run/initramfs path.")
+        
+    
+    def Cleanup(self):
+        if self.progress_name:
+            try:
+                os.unlink(self.progress_name)
+                self.progress_name = None
+            except oserror as e:
+                if e.errno == EEXIST:
+                    pass
+                raise
+        self.update_process = None
+
+    @dbus.service.method(
+        DBUS_NAME, in_signature='', out_signature='s')
+    def GetBIOSUpdateProgress(self):
+        msg = ""
+
+        # check Host state
+        o = bus.get_object(HOST_DBUS_NAME, HOST_OBJ_NAME)
+        intf = dbus.Interface(o, "org.freedesktop.DBus.Properties")
+        state = intf.Get(HOST_DBUS_NAME,"CurrentHostState")
+        data = state.rsplit('.',1)
+            
+        if self.Get(DBUS_NAME, "prepare_update"):
+            if data[1] == 'Off':
+                self.Set(DBUS_NAME, "prepare_update", False)
+                self.Set(DBUS_NAME, "status", "System status is Off , Switch SPI interface")
+        else:
+            if data[1] == 'Running':
+                self.Set(DBUS_NAME, "status", "Idle")
+                self.Set(DBUS_NAME, "filename", "")
+        
+        if self.update_process and self.update_process.returncode is None:
+            self.update_process.poll()
+
+        if (self.update_process is None):
+            pass
+        elif (self.update_process.returncode > 0):
+            self.Set(DBUS_NAME, "status", "Apply failed")
+        elif (self.update_process.returncode is None):
+            pass
+        else:
+            files = ""
+            for file in os.listdir(UPDATE_PATH):
+                if file.startswith('bios'):
+                    files = files + file
+            if files == "":
+                msg = "Apply Complete.  Reboot to take effect."
+            else:
+                msg = "Apply Incomplete, Remaining:" + files
+            self.Set(DBUS_NAME, "status", msg)
+
+        msg = self.Get(DBUS_NAME, "status") + "\n"
+        if self.progress_name:
+            try:
+                prog = open(self.progress_name, 'r')
+                for line in prog:
+                    cr = line.rfind("\r", 0, -2)
+                    msg = msg + line[cr + 1:]
+            except OSError as e:
+                if (e.error == EEXIST):
+                    pass
+                raise
+        return msg
+
+    @dbus.service.method(
+        DBUS_NAME, in_signature='', out_signature='')
+    def Apply(self):
+        progress = None
+        self.Set(DBUS_NAME, "status", "Writing images to flash")
+        try:
+            print("Receive method of Apply")
+            progress = tempfile.NamedTemporaryFile(
+                delete=False, prefix="progress.")
+            self.progress_name = progress.name
+            self.update_process = subprocess.Popen([
+                "/usr/sbin/update_bios.sh"],
+                stdout=progress.file,
+                stderr=subprocess.STDOUT)
+        except Exception as e:
+            try:
+                progress.close()
+                os.unlink(progress.name)
+                self.progress_name = None
+            except Exception:
+                pass
+            raise
+
+        try:
+            progress.close()
+        except Exception:
+            pass
+
+    @dbus.service.method(
+        DBUS_NAME, in_signature='', out_signature='')
+    def PrepareForUpdateBIOS(self):
+        print("Prepare For BIOS Update")
+        
+        o = bus.get_object(HOST_DBUS_NAME, HOST_OBJ_NAME)
+        intf = dbus.Interface(o, "org.freedesktop.DBus.Properties")
+        state = intf.Get(HOST_DBUS_NAME,"CurrentHostState")
+        data = state.rsplit('.',1)
+        self.Set(DBUS_NAME, "prepare_update", True)
+
+        if data[1] == 'Running':
+            self.Set(DBUS_NAME, "status", "Wating System Power off")
+            # turn off system
+            intf.Set(HOST_DBUS_NAME,"RequestedHostTransition","xyz.openbmc_project.State.Host.Transition.Off")
+        elif data[1] == 'Quiesced':
+            self.Set(DBUS_NAME, "status", "System status is Quiesced")
+        else:
+            self.Set(DBUS_NAME, "status", "System status is Off , Switch SPI interface")
+        
+    @dbus.service.method(
+        DBUS_NAME, in_signature='', out_signature='')
+    def SwitchSPIInterface(self):
+        self.Set(DBUS_NAME, "status", "Connect SPI interface to BMC")
+        
+        # into recovery mode, no recovery mode pin
+        #subprocess.Popen('gpioset gpiochip0 72=0', shell=True)
+        
+        # connect BMC to SPI Flash 
+        subprocess.Popen('gpioset gpiochip0 72=0', shell=True)
+        subprocess.Popen('gpioset gpiochip0 73=1', shell=True)
+        # Waiting for gpio set
+        time.sleep(5)
+        # Load the ASpeed SMC driver
+        subprocess.Popen('echo -n 1e630000.spi > /sys/bus/platform/drivers/aspeed-smc/bind', shell=True)
+
+        self.Set(DBUS_NAME, "status", "Prepare Update BIOS")
+
+    @dbus.service.method(
+        DBUS_NAME, in_signature='', out_signature='')
+    def RestoreSPIInterface(self):
+        # unLoad the ASpeed SMC driver
+        subprocess.Popen('echo -n 1e630000.spi > /sys/bus/platform/drivers/aspeed-smc/unbind', shell=True)
+
+        time.sleep(10)
+        
+        # connect PCH to SPI Flash 
+        subprocess.Popen('gpioset gpiochip0 72=1', shell=True)
+        subprocess.Popen('gpioset gpiochip0 73=0', shell=True)
+
+        #self.update_process = None
+        if self.update_process:
+            try:
+                self.update_process.kill()
+            except Exception:
+                pass
+        
+        self.Cleanup()
+        self.Set(DBUS_NAME, "status", "Restore From Update setting")
+
+    @dbus.service.method(
+        DBUS_NAME, in_signature='', out_signature='')
+    def SetMERecoveryMode(self):
+        #Set ME to recovery mode
+        subprocess.Popen('busctl call %s %s %s %s %s' %(IPMB_OBJ,IPMB_PATH,IPMB_INTF,IPMB_CALL,ME_CMD_RECOVER), shell=True)
+
+        self.Set(DBUS_NAME, "status", "Set Intel ME To Recovery Mode")
+
+    @dbus.service.method(
+        DBUS_NAME, in_signature='', out_signature='')
+    def SetMEReset(self):
+        #Reset ME to boot from new bios
+        subprocess.Popen('busctl call %s %s %s %s %s' %(IPMB_OBJ,IPMB_PATH,IPMB_INTF,IPMB_CALL,ME_CMD_RESET), shell=True)
+
+        self.Set(DBUS_NAME, "status", "Set Intel ME To Reset")
+
+if __name__ == '__main__':
+    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+    bus = get_dbus()
+    obj = BiosFlashControl(bus, OBJ_NAME)
+    mainloop = gobject.MainLoop()
+
+    obj.unmask_signals()
+    name = dbus.service.BusName(DBUS_NAME, bus)
+
+    print("Running BIOS Flash Control")
+    mainloop.run()
+
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/image-active b/meta-mct/meta-s5549/recipes-phosphor/bios/files/image-active
new file mode 100755
index 0000000..a7f2334
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/image-active
@@ -0,0 +1,29 @@
+#!/bin/sh
+
+set -e
+
+IMAGE_FILE=$1
+
+if [  -z "$IMAGE_FILE"  ]; then
+	echo "Please set your file name"
+	exit -1
+fi
+
+versionId=$(echo $IMAGE_FILE|cut -d'/' -f 4)
+
+if [  -z "$versionId"  ]; then
+	echo "Failed to get version ID"
+	exit -1
+fi
+
+echo $versionId
+
+
+SERVICE="xyz.openbmc_project.Software.BMC.Updater"
+OBJECT="/xyz/openbmc_project/software/$versionId"
+INTERFACE="xyz.openbmc_project.Software.Activation"
+Activation="xyz.openbmc_project.Software.Activation.Activations.Ready"
+RequestedActivation="xyz.openbmc_project.Software.Activation.RequestedActivations.None"
+
+busctl set-property $SERVICE $OBJECT $INTERFACE Activation s $Activation
+busctl set-property $SERVICE $OBJECT $INTERFACE RequestedActivation s $RequestedActivation
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/org.openbmc.control.BiosFlash.conf b/meta-mct/meta-s5549/recipes-phosphor/bios/files/org.openbmc.control.BiosFlash.conf
new file mode 100755
index 0000000..27a9419
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/org.openbmc.control.BiosFlash.conf
@@ -0,0 +1,8 @@
+<!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
+        "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
+<busconfig>
+        <policy user="root">
+                <allow own="org.openbmc.control.BiosFlash"/>
+                <allow send_destination="org.openbmc.control.BiosFlash"/>
+        </policy>
+</busconfig>
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/py.mk b/meta-mct/meta-s5549/recipes-phosphor/bios/files/py.mk
new file mode 100755
index 0000000..9669fce
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/py.mk
@@ -0,0 +1,9 @@
+PYTHON?=python
+all:
+	$(PYTHON) setup.py build
+
+clean:
+	rm -rf build
+
+install: all
+	$(PYTHON) setup.py install --root=$(DESTDIR) --prefix=$(PREFIX)
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/setup.cfg b/meta-mct/meta-s5549/recipes-phosphor/bios/files/setup.cfg
new file mode 100755
index 0000000..b5cec1b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/setup.cfg
@@ -0,0 +1,4 @@
+[install]
+install_scripts=/usr/sbin
+[pycodestyle]
+exclude=./configs/
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/setup.py b/meta-mct/meta-s5549/recipes-phosphor/bios/files/setup.py
new file mode 100755
index 0000000..470198d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/setup.py
@@ -0,0 +1,7 @@
+from distutils.core import setup
+
+setup(name='build',
+      version='1.0',
+      scripts=['bios_update.py'],
+      )
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/bios/files/update_bios.sh b/meta-mct/meta-s5549/recipes-phosphor/bios/files/update_bios.sh
new file mode 100755
index 0000000..b599b00
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/bios/files/update_bios.sh
@@ -0,0 +1,36 @@
+#!/bin/sh
+
+#echo update: "$@"
+
+doflash=y
+biosPath=/tmp/bios/
+tarball=bios.tgz
+tarPath=$biosPath$tarball
+
+if [ -f $tarPath ]
+then 
+	echo "bios image found" |systemd-cat
+	tar xvzf $tarPath -C $biosPath
+	rm -f $tarPath
+else 
+	echo "no bios image found"|systemd-cat
+	exit 1
+fi
+
+for file in ${biosPath}/*
+do 
+	if [ $(basename $file) != $tarball ]; then
+		echo $file |systemd-cat
+		biosImage=$file
+		break
+	fi
+	exit 1
+done
+
+if test -n "$doflash"; then
+    echo "Updating Bios"
+    flashcp -v $biosImage /dev/mtd6
+    rm -rf $biosPath
+fi
+
+exit 0
diff --git a/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-op-control-power/0001-leave-gpood-monitor-to-other-service.patch b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-op-control-power/0001-leave-gpood-monitor-to-other-service.patch
new file mode 100755
index 0000000..9740fd6
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-op-control-power/0001-leave-gpood-monitor-to-other-service.patch
@@ -0,0 +1,74 @@
+From e79640fed82f72df4e6e7b5feddbfaf482a230e0 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 4 Feb 2020 19:40:46 +0800
+Subject: [PATCH] leave gpood monitor to other service
+
+---
+ op-pwrctl/power_control_obj.c | 12 +++++++++---
+ 1 file changed, 9 insertions(+), 3 deletions(-)
+ mode change 100644 => 100755 op-pwrctl/power_control_obj.c
+
+diff --git a/power_control_obj.c b/power_control_obj.c
+old mode 100644
+new mode 100755
+index ada9b3b..057c80f
+--- a/power_control_obj.c
++++ b/power_control_obj.c
+@@ -29,6 +29,7 @@ time_t pgood_timeout_start = 0;
+ static gboolean
+ poll_pgood(gpointer user_data)
+ {
++	return TRUE;
+ 	ControlPower *control_power = object_get_control_power((Object*)user_data);
+ 	Control* control = object_get_control((Object*)user_data);
+ 
+@@ -57,7 +58,8 @@ poll_pgood(gpointer user_data)
+ 		gpio_close(&g_gpio_configs.power_gpio.power_good_in);
+ 		g_print("ERROR PowerControl: GPIO open error (gpio=%s,rc=%d)\n",
+ 				g_gpio_configs.power_gpio.power_good_in.name, rc);
+-		return FALSE;
++		//Mitac, don't stop the polling
++		return true;
+ 	}
+ 	rc = gpio_read(&g_gpio_configs.power_gpio.power_good_in, &pgood_state);
+ 	gpio_close(&g_gpio_configs.power_gpio.power_good_in);
+@@ -133,7 +135,8 @@ poll_pgood(gpointer user_data)
+ 		g_print("ERROR PowerControl: GPIO read error (gpio=%s,rc=%d)\n",
+ 				g_gpio_configs.power_gpio.power_good_in.name, rc);
+ 		//return false so poll won't get called anymore
+-		return FALSE;
++		//Mitac, don't stop the polling anyhow or the entire state management system will be ruined.
++		return true;
+ 	}
+ 	//pgood is not at desired state yet
+ 	if(pgood_state != control_power_get_state(control_power) &&
+@@ -368,10 +371,12 @@ set_up_gpio(PowerGpio *power_gpio, ControlPower* control_power)
+ 			error = rc;
+ 		}
+ 	}
++#if 0 //leave to gpiomonitor	
+ 	rc = gpio_get_params(&power_gpio->power_good_in);
+ 	if(rc != GPIO_OK) {
+ 		error = rc;
+ 	}
++#endif	
+ 	for(int i = 0; i < power_gpio->num_power_up_outs; i++) {
+ 		rc = gpio_get_params(&power_gpio->power_up_outs[i]);
+ 		if(rc != GPIO_OK) {
+@@ -392,7 +397,7 @@ set_up_gpio(PowerGpio *power_gpio, ControlPower* control_power)
+ 	}
+ 
+ 	gpio_inits_done();
+-
++#if 0 //leave to gpiomonitor
+ 	rc = gpio_open(&power_gpio->power_good_in, 0);
+ 	if(rc != GPIO_OK) {
+ 		gpio_close(&power_gpio->power_good_in);
+@@ -407,6 +412,7 @@ set_up_gpio(PowerGpio *power_gpio, ControlPower* control_power)
+ 	control_power_set_pgood(control_power, pgood_state);
+ 	control_power_set_state(control_power, pgood_state);
+ 	g_print("Pgood state: %d\n", pgood_state);
++#endif
+ 
+ 	return error;
+ }
diff --git a/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-op-control-power_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-op-control-power_git.bbappend
new file mode 100755
index 0000000..2105f01
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-op-control-power_git.bbappend
@@ -0,0 +1,6 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+S = "${WORKDIR}/git/op-pwrctl/"
+
+SRC_URI += "file://0001-leave-gpood-monitor-to-other-service.patch"
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0001-add-SEL-log-for-Power-Button-Press.patch b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0001-add-SEL-log-for-Power-Button-Press.patch
new file mode 100755
index 0000000..f6b23e7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0001-add-SEL-log-for-Power-Button-Press.patch
@@ -0,0 +1,62 @@
+From 5136fc408c4e2ce474788ef2df5fd7f57194cc90 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Wed, 30 Oct 2019 09:13:11 +0800
+Subject: [PATCH] add SEL log for Power Button Press
+
+---
+ src/button_handler.cpp | 25 +++++++++++++++++++++++++
+ 1 file changed, 25 insertions(+)
+ mode change 100644 => 100755 src/button_handler.cpp
+
+diff --git a/src/button_handler.cpp b/src/button_handler.cpp
+old mode 100644
+new mode 100755
+index 675f1ea..528a59b
+--- a/src/button_handler.cpp
++++ b/src/button_handler.cpp
+@@ -29,6 +29,13 @@ constexpr auto mapperObjPath = "/xyz/openbmc_project/object_mapper";
+ constexpr auto mapperService = "xyz.openbmc_project.ObjectMapper";
+ constexpr auto ledGroupBasePath = "/xyz/openbmc_project/led/groups/";
+ 
++static constexpr char const* ipmiSELService = "xyz.openbmc_project.Logging.IPMI";
++static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
++static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
++static const std::string ipmiSELAddMessage = "SEL Entry";
++static const std::string sensorPath = "/xyz/openbmc_project/sensors/pwr_button/BUTTON";
++static constexpr size_t selEvtDataMaxSize = 3;
++
+ Handler::Handler(sdbusplus::bus::bus& bus) : bus(bus)
+ {
+     try
+@@ -133,6 +140,11 @@ void Handler::powerPressed(sdbusplus::message::message& msg)
+ {
+     auto transition = Host::Transition::On;
+ 
++    uint16_t genid = 0x20;
++    bool assert = 1;
++    std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
++    eventData[0] = 0;
++
+     try
+     {
+         if (poweredOn())
+@@ -142,6 +154,19 @@ void Handler::powerPressed(sdbusplus::message::message& msg)
+ 
+         log<level::INFO>("Handling power button press");
+ 
++        sdbusplus::message::message writeSEL = bus.new_method_call(
++            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++        writeSEL.append(ipmiSELAddMessage, sensorPath, eventData, assert,
++                    genid);
++        try
++        {
++            bus.call(writeSEL);
++        }
++        catch (sdbusplus::exception_t& e)
++        {
++            log<level::ERR>("call IpmiSelAdd failed");
++        }
++
+         sdbusplus::message::variant<std::string> state =
+             convertForMessage(transition);
+ 
diff --git a/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0002-Add-Power-button-override-SEL.patch b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0002-Add-Power-button-override-SEL.patch
new file mode 100755
index 0000000..71bccfa
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0002-Add-Power-button-override-SEL.patch
@@ -0,0 +1,54 @@
+From 9ae7e62d540af622f4fd173cc267381cab44d038 Mon Sep 17 00:00:00 2001
+From: Varun Sampat <vsampat@twitter.com>
+Date: Tue, 7 Jan 2020 21:40:20 -0500
+Subject: [PATCH] Add Power button override SEL
+
+---
+ src/button_handler.cpp | 20 ++++++++++++++++++++
+ 1 file changed, 20 insertions(+)
+
+diff --git a/src/button_handler.cpp b/src/button_handler.cpp
+index 528a59b..1a26744 100755
+--- a/src/button_handler.cpp
++++ b/src/button_handler.cpp
+@@ -34,6 +34,7 @@ static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
+ static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
+ static const std::string ipmiSELAddMessage = "SEL Entry";
+ static const std::string sensorPath = "/xyz/openbmc_project/sensors/pwr_button/BUTTON";
++static const std::string sensorPathAcpi = "/xyz/openbmc_project/sensors/acpi/ACPI_POWER_STATE";
+ static constexpr size_t selEvtDataMaxSize = 3;
+ 
+ Handler::Handler(sdbusplus::bus::bus& bus) : bus(bus)
+@@ -186,6 +187,12 @@ void Handler::powerPressed(sdbusplus::message::message& msg)
+ 
+ void Handler::longPowerPressed(sdbusplus::message::message& msg)
+ {
++    
++    uint16_t genid = 0x20;
++    bool assert = 1;
++    std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
++    eventData[0] = 0x0A;
++
+     try
+     {
+         if (!poweredOn())
+@@ -197,6 +204,19 @@ void Handler::longPowerPressed(sdbusplus::message::message& msg)
+ 
+         log<level::INFO>("Handling long power button press");
+ 
++        sdbusplus::message::message writeSEL = bus.new_method_call(
++            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++        writeSEL.append(ipmiSELAddMessage, sensorPathAcpi, eventData, assert,
++                    genid);
++        try
++        {
++            bus.call(writeSEL);
++        }
++        catch (sdbusplus::exception_t& e)
++        {
++            log<level::ERR>("call IpmiSelAdd failed");
++        }
++
+         sdbusplus::message::variant<std::string> state =
+             convertForMessage(Chassis::Transition::Off);
+ 
diff --git a/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0003-Remove-power-button-and-reset-button-press-and-long-.patch b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0003-Remove-power-button-and-reset-button-press-and-long-.patch
new file mode 100755
index 0000000..a037114
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0003-Remove-power-button-and-reset-button-press-and-long-.patch
@@ -0,0 +1,68 @@
+From de6016609d4dc4421974562a868b2e53fd06144e Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 17 Mar 2020 09:48:03 +0800
+Subject: [PATCH] Remove power button and reset button press and long press
+ action
+
+Remove power button press and long press bus method call
+Remove power button press bus method call
+---
+ src/button_handler.cpp | 28 ----------------------------
+ 1 file changed, 28 deletions(-)
+
+diff --git a/src/button_handler.cpp b/src/button_handler.cpp
+index 1a26744..385bb4d 100755
+--- a/src/button_handler.cpp
++++ b/src/button_handler.cpp
+@@ -168,15 +168,6 @@ void Handler::powerPressed(sdbusplus::message::message& msg)
+             log<level::ERR>("call IpmiSelAdd failed");
+         }
+ 
+-        sdbusplus::message::variant<std::string> state =
+-            convertForMessage(transition);
+-
+-        auto service = getService(HOST_STATE_OBJECT_NAME, hostIface);
+-        auto method = bus.new_method_call(
+-            service.c_str(), HOST_STATE_OBJECT_NAME, propertyIface, "Set");
+-        method.append(hostIface, "RequestedHostTransition", state);
+-
+-        bus.call(method);
+     }
+     catch (SdBusError& e)
+     {
+@@ -217,15 +208,6 @@ void Handler::longPowerPressed(sdbusplus::message::message& msg)
+             log<level::ERR>("call IpmiSelAdd failed");
+         }
+ 
+-        sdbusplus::message::variant<std::string> state =
+-            convertForMessage(Chassis::Transition::Off);
+-
+-        auto service = getService(CHASSIS_STATE_OBJECT_NAME, chassisIface);
+-        auto method = bus.new_method_call(
+-            service.c_str(), CHASSIS_STATE_OBJECT_NAME, propertyIface, "Set");
+-        method.append(chassisIface, "RequestedPowerTransition", state);
+-
+-        bus.call(method);
+     }
+     catch (SdBusError& e)
+     {
+@@ -246,16 +228,6 @@ void Handler::resetPressed(sdbusplus::message::message& msg)
+ 
+         log<level::INFO>("Handling reset button press");
+ 
+-        sdbusplus::message::variant<std::string> state =
+-            convertForMessage(Host::Transition::Reboot);
+-
+-        auto service = getService(HOST_STATE_OBJECT_NAME, hostIface);
+-        auto method = bus.new_method_call(
+-            service.c_str(), HOST_STATE_OBJECT_NAME, propertyIface, "Set");
+-
+-        method.append(hostIface, "RequestedHostTransition", state);
+-
+-        bus.call(method);
+     }
+     catch (SdBusError& e)
+     {
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0004-Write-to-SEL-when-reset-button-is-pressed.patch b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0004-Write-to-SEL-when-reset-button-is-pressed.patch
new file mode 100755
index 0000000..17e295b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0004-Write-to-SEL-when-reset-button-is-pressed.patch
@@ -0,0 +1,45 @@
+From 176ff087aadee66a69af1d06f3e701b67d2e4416 Mon Sep 17 00:00:00 2001
+From: Nik Johnson <njohnson@twitter.com>
+Date: Wed, 15 Apr 2020 18:46:06 -0400
+Subject: [PATCH] Write to SEL when reset button is pressed
+
+---
+ src/button_handler.cpp | 18 ++++++++++++++++++
+ 1 file changed, 18 insertions(+)
+
+diff --git a/src/button_handler.cpp b/src/button_handler.cpp
+index 385bb4d..b28723e 100755
+--- a/src/button_handler.cpp
++++ b/src/button_handler.cpp
+@@ -218,6 +218,12 @@ void Handler::longPowerPressed(sdbusplus::message::message& msg)
+ 
+ void Handler::resetPressed(sdbusplus::message::message& msg)
+ {
++
++    uint16_t genid = 0x20;
++    bool assert = 1;
++    std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
++    eventData[0] = 0x02;
++
+     try
+     {
+         if (!poweredOn())
+@@ -228,6 +234,18 @@ void Handler::resetPressed(sdbusplus::message::message& msg)
+ 
+         log<level::INFO>("Handling reset button press");
+ 
++        sdbusplus::message::message writeSEL = bus.new_method_call(
++            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++        writeSEL.append(ipmiSELAddMessage, sensorPath, eventData, assert,
++                    genid);
++        try
++        {
++            bus.call(writeSEL);
++        }
++        catch (sdbusplus::exception_t& e)
++        {
++            log<level::ERR>("call IpmiSelAdd failed");
++        }
+     }
+     catch (SdBusError& e)
+     {
diff --git a/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0005-Fix-SEL-event-issue-for-the-power-and-reset-button.patch b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0005-Fix-SEL-event-issue-for-the-power-and-reset-button.patch
new file mode 100755
index 0000000..74b5a12
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons/0005-Fix-SEL-event-issue-for-the-power-and-reset-button.patch
@@ -0,0 +1,148 @@
+From 2c89e1da6163182b7e2f76f132f9221dae7eddf7 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 11 Nov 2020 16:37:54 +0800
+Subject: [PATCH] Fix SEL event issue for the power and reset button
+
+Add the power button SEL event to long press
+Fix the issue for the reset button would not log SEL event when host power off
+Refactor the generate butoon SEL fucntion
+---
+ inc/button_handler.hpp |  7 ++++++
+ src/button_handler.cpp | 63 ++++++++++++++++++++++----------------------------
+ 2 files changed, 34 insertions(+), 36 deletions(-)
+ mode change 100644 => 100755 inc/button_handler.hpp
+
+diff --git a/inc/button_handler.hpp b/inc/button_handler.hpp
+old mode 100644
+new mode 100755
+index 7340c2f..1f3c007
+--- a/inc/button_handler.hpp
++++ b/inc/button_handler.hpp
+@@ -83,6 +83,13 @@ class Handler
+     bool poweredOn() const;
+ 
+     /**
++     * @brief Log the SEL for button event
++     *
++     * @param[in] eventData0 - event data 0 for SEL
++     */
++    void logButtonEvent(uint8_t eventData0) const;
++
++    /**
+      * @brief Returns the service name for an object
+      *
+      * @param[in] path - the object path
+diff --git a/src/button_handler.cpp b/src/button_handler.cpp
+index 1c819b6..ff210ec 100755
+--- a/src/button_handler.cpp
++++ b/src/button_handler.cpp
+@@ -137,17 +137,36 @@ bool Handler::poweredOn() const
+                sdbusplus::message::variant_ns::get<std::string>(state));
+ }
+ 
+-void Handler::powerPressed(sdbusplus::message::message& msg)
++void Handler::logButtonEvent(uint8_t eventData0) const
+ {
+-    auto transition = Host::Transition::On;
+-
+     uint16_t genid = 0x20;
+     bool assert = 1;
+     std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
+-    eventData[0] = 0;
++    eventData[0] = eventData0;
+ 
++    sdbusplus::message::message writeSEL = bus.new_method_call(
++        ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++    writeSEL.append(ipmiSELAddMessage, sensorPath, eventData, assert,
++                    genid);
+     try
+     {
++        bus.call(writeSEL);
++    }
++    catch (SdBusError& e)
++    {
++        log<level::ERR>("Failed to log the button event",
++                        entry("ERROR=%s", e.what()));
++    }
++}
++
++void Handler::powerPressed(sdbusplus::message::message& msg)
++{
++    auto transition = Host::Transition::On;
++
++    try
++    {
++        logButtonEvent(0x00);
++
+         if (poweredOn())
+         {
+             transition = Host::Transition::Off;
+@@ -155,19 +174,6 @@ void Handler::powerPressed(sdbusplus::message::message& msg)
+ 
+         log<level::INFO>("Handling power button press");
+ 
+-        sdbusplus::message::message writeSEL = bus.new_method_call(
+-            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+-        writeSEL.append(ipmiSELAddMessage, sensorPath, eventData, assert,
+-                    genid);
+-        try
+-        {
+-            bus.call(writeSEL);
+-        }
+-        catch (sdbusplus::exception_t& e)
+-        {
+-            log<level::ERR>("call IpmiSelAdd failed");
+-        }
+-
+     }
+     catch (SdBusError& e)
+     {
+@@ -186,6 +192,8 @@ void Handler::longPowerPressed(sdbusplus::message::message& msg)
+ 
+     try
+     {
++        logButtonEvent(0x00);
++
+         if (!poweredOn())
+         {
+             log<level::INFO>(
+@@ -218,14 +226,10 @@ void Handler::longPowerPressed(sdbusplus::message::message& msg)
+ 
+ void Handler::resetPressed(sdbusplus::message::message& msg)
+ {
+-
+-    uint16_t genid = 0x20;
+-    bool assert = 1;
+-    std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
+-    eventData[0] = 0x02;
+-
+     try
+     {
++        logButtonEvent(0x02);
++
+         if (!poweredOn())
+         {
+             log<level::INFO>("Power is off so ignoring reset button press");
+@@ -233,19 +237,6 @@ void Handler::resetPressed(sdbusplus::message::message& msg)
+         }
+ 
+         log<level::INFO>("Handling reset button press");
+-
+-        sdbusplus::message::message writeSEL = bus.new_method_call(
+-            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+-        writeSEL.append(ipmiSELAddMessage, sensorPath, eventData, assert,
+-                    genid);
+-        try
+-        {
+-            bus.call(writeSEL);
+-        }
+-        catch (sdbusplus::exception_t& e)
+-        {
+-            log<level::ERR>("call IpmiSelAdd failed");
+-        }
+     }
+     catch (SdBusError& e)
+     {
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons_git.bbappend
new file mode 100755
index 0000000..c198d32
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/chassis/obmc-phosphor-buttons_git.bbappend
@@ -0,0 +1,9 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-add-SEL-log-for-Power-Button-Press.patch \
+            file://0002-Add-Power-button-override-SEL.patch \
+            file://0003-Remove-power-button-and-reset-button-press-and-long-.patch \
+            file://0004-Write-to-SEL-when-reset-button-is-pressed.patch \
+            file://0005-Fix-SEL-event-issue-for-the-power-and-reset-button.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0001-Support-baseboard-fru-reading.patch b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0001-Support-baseboard-fru-reading.patch
new file mode 100755
index 0000000..90a2ee7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0001-Support-baseboard-fru-reading.patch
@@ -0,0 +1,116 @@
+From 6c7ded398891abb080a2b495e0fab249ad1b6d3d Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 10 Dec 2019 20:37:38 +0800
+Subject: [PATCH] Support baseboard fru reading
+
+---
+ src/FruDevice.cpp | 30 ++++++++++++++++++++++++++++--
+ 1 file changed, 28 insertions(+), 2 deletions(-)
+ mode change 100644 => 100755 src/FruDevice.cpp
+
+diff --git a/src/FruDevice.cpp b/src/FruDevice.cpp
+old mode 100644
+new mode 100755
+index 3ae71b1..08c6970
+--- a/src/FruDevice.cpp
++++ b/src/FruDevice.cpp
+@@ -55,6 +55,8 @@ static size_t UNKNOWN_BUS_OBJECT_COUNT = 0;
+ constexpr size_t MAX_FRU_SIZE = 512;
+ constexpr size_t MAX_EEPROM_PAGE_INDEX = 255;
+ constexpr size_t busTimeoutSeconds = 5;
++#define FRU_OFFSET  0x0000
++
+ 
+ constexpr const char* blacklistPath = PACKAGE_DIR "blacklist.json";
+ 
+@@ -189,6 +191,8 @@ std::vector<char> readFruContents(int flag, int file, uint16_t address,
+             }
+         }
+     }
++    //MiTAC limit FRU to 512B : workaroud to prevent unreasonable fru size caculation       due to ipmitool fru edit issue.
++    if(fruLength > 512) fruLength = 512;
+ 
+     // You already copied these first 8 bytes (the ipmi fru header size)
+     fruLength -= 8;
+@@ -244,7 +248,7 @@ static int64_t readFromEeprom(int flag __attribute__((unused)), int fd,
+                               uint16_t address __attribute__((unused)),
+                               uint16_t offset, uint8_t len, uint8_t* buf)
+ {
+-    auto result = lseek(fd, offset, SEEK_SET);
++    auto result = lseek(fd, offset + FRU_OFFSET, SEEK_SET);
+     if (result < 0)
+     {
+         std::cerr << "failed to seek\n";
+@@ -390,6 +394,7 @@ bool validateHeader(const std::array<uint8_t, I2C_SMBUS_BLOCK_MAX>& blockData)
+         return false;
+     }
+ 
++#if 0 //MiTAC : ipmitool issue: fru edit don't check the non-existing area and fill incorrect area offset.
+     // verify offsets are 0, or don't point to another offset
+     std::set<uint8_t> foundOffsets;
+     for (int ii = 1; ii < 6; ii++)
+@@ -404,6 +409,7 @@ bool validateHeader(const std::array<uint8_t, I2C_SMBUS_BLOCK_MAX>& blockData)
+             return false;
+         }
+     }
++#endif 
+ 
+     // validate checksum
+     size_t sum = 0;
+@@ -794,6 +800,9 @@ bool formatFru(const std::vector<char>& fruBytes,
+ 
+     const std::vector<const char*>* fieldData;
+ 
++    //MiTAC: area overlapping check.
++    std::vector<char>::const_iterator perviousAreaEnd = fruBytes.begin();
++
+     for (const std::string& area : FRU_AREAS)
+     {
+         ++fruAreaOffsetField;
+@@ -809,6 +818,13 @@ bool formatFru(const std::vector<char>& fruBytes,
+             std::vector<char>::const_iterator fruBytesIter =
+                 fruBytes.begin() + offset + 2;
+ 
++            //check area length and overlapping 
++            if(*(fruBytesIter-1) == 0 || *(fruBytesIter-1) == 0xff || fruBytesIter <= perviousAreaEnd )
++            {
++                //skip incorrect area
++                continue;
++            }
++            
+             if (fruBytesIter >= fruBytes.end())
+             {
+                 return false;
+@@ -875,6 +891,7 @@ bool formatFru(const std::vector<char>& fruBytes,
+                  * field to be read */
+                 if (static_cast<uint8_t>(*fruBytesIter) == 0xC1)
+                 {
++                    perviousAreaEnd = fruBytesIter;
+                     break;
+                 }
+ 
+@@ -901,7 +918,7 @@ bool formatFru(const std::vector<char>& fruBytes,
+                     std::cerr << "Warning Fru Length Mismatch:\n    ";
+                     for (auto& c : fruBytes)
+                     {
+-                        std::cerr << c;
++                        std::cerr <<" "<< std::hex << std::setw(2) << std::setfill('0')<<(static_cast<unsigned int>(c));
+                     }
+                     std::cerr << "\n";
+                     if (DEBUG)
+@@ -1120,6 +1137,15 @@ bool writeFru(uint8_t bus, uint8_t address, const std::vector<uint8_t>& fru)
+                 return false;
+             }
+ 
++            //mitac support fru offset for write operation
++            auto result = lseek(eeprom, FRU_OFFSET, SEEK_SET);
++            if (result < 0)
++            {
++                std::cerr << "failed to seek\n";
++                return false;
++            }
++            //mitac end
++
+             ssize_t writtenBytes = write(eeprom, fru.data(), fru.size());
+             if (writtenBytes < 0)
+             {
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0003-support-fru-write-offset.patch b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0003-support-fru-write-offset.patch
new file mode 100755
index 0000000..140e6e8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0003-support-fru-write-offset.patch
@@ -0,0 +1,29 @@
+From 996ddcb51b75c63d0aa400c5b9caeb3da559983c Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Fri, 29 Nov 2019 22:41:16 +0800
+Subject: [PATCH] support fru write offset
+
+---
+ src/FruDevice.cpp | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/src/FruDevice.cpp b/src/FruDevice.cpp
+index 841dcd4..a1fdd48 100755
+--- a/src/FruDevice.cpp
++++ b/src/FruDevice.cpp
+@@ -1016,6 +1016,15 @@ bool writeFru(uint8_t bus, uint8_t address, const std::vector<uint8_t>& fru)
+                 return false;
+             }
+ 
++            //mitac support fru offset for write operation
++            auto result = lseek(eeprom, FRU_OFFSET, SEEK_SET);
++            if (result < 0)
++            {
++                std::cerr << "failed to seek\n";
++                return false;
++            }
++            //mitac end
++
+             ssize_t writtenBytes = write(eeprom, fru.data(), fru.size());
+             if (writtenBytes < 0)
+             {
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0004-fix-fsc-to-settable-interface.patch b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0004-fix-fsc-to-settable-interface.patch
new file mode 100755
index 0000000..49fb995
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0004-fix-fsc-to-settable-interface.patch
@@ -0,0 +1,24 @@
+From 368d64f3eff8e72d4f8cdea28235abc13742975c Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Mon, 20 Jan 2020 10:55:50 +0800
+Subject: [PATCH] fix-fsc-to-settable-interface
+
+---
+ src/EntityManager.cpp | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/src/EntityManager.cpp b/src/EntityManager.cpp
+index 53a34bc..0a363a8 100644
+--- a/src/EntityManager.cpp
++++ b/src/EntityManager.cpp
+@@ -73,8 +73,8 @@ const static boost::container::flat_map<const char*, probe_type_codes, cmp_str>
+                  {"FOUND", probe_type_codes::FOUND},
+                  {"MATCH_ONE", probe_type_codes::MATCH_ONE}}};
+ 
+-static constexpr std::array<const char*, 5> settableInterfaces = {
+-    "FanProfile", "Pid", "Pid.Zone", "Stepwise", "Thresholds"};
++static constexpr std::array<const char*, 6> settableInterfaces = {
++    "FanProfile", "Pid", "Pid.Zone", "Stepwise", "Fsc", "Thresholds"};
+ using JsonVariantType =
+     std::variant<std::vector<std::string>, std::vector<double>, std::string,
+                  int64_t, uint64_t, double, int32_t, uint32_t, int16_t,
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0004-workaroud-for-fru-edit.patch b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0004-workaroud-for-fru-edit.patch
new file mode 100755
index 0000000..3fa600e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0004-workaroud-for-fru-edit.patch
@@ -0,0 +1,80 @@
+From 8fadcbc95232b4a6da211571cb2a0c3ea7da780b Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 3 Dec 2019 20:57:20 +0800
+Subject: [PATCH] workaroud for fru edit
+
+---
+ src/FruDevice.cpp | 18 +++++++++++++++++-
+ 1 file changed, 17 insertions(+), 1 deletion(-)
+
+diff --git a/src/FruDevice.cpp b/src/FruDevice.cpp
+index a1fdd48..192a611 100755
+--- a/src/FruDevice.cpp
++++ b/src/FruDevice.cpp
+@@ -176,6 +176,7 @@ bool validateHeader(const std::array<uint8_t, I2C_SMBUS_BLOCK_MAX>& blockData)
+         return false;
+     }
+ 
++#if 0 //MiTAC : ipmitool issue: fru edit don't check the non-existing area and fill incorrect area offset.
+     // verify offsets are 0, or don't point to another offset
+     std::set<uint8_t> foundOffsets;
+     for (int ii = 1; ii < 6; ii++)
+@@ -190,6 +191,7 @@ bool validateHeader(const std::array<uint8_t, I2C_SMBUS_BLOCK_MAX>& blockData)
+             return false;
+         }
+     }
++#endif 
+ 
+     // validate checksum
+     size_t sum = 0;
+@@ -274,6 +276,9 @@ static std::vector<char> processEeprom(int bus, int address)
+         fruLength = (areaOffset > fruLength) ? areaOffset : fruLength;
+     }
+ 
++    //MiTAC limit FRU to 512B : workaroud to prevent unreasonable fru size caculation due to ipmitool fru edit issue.
++    if(fruLength > 512) fruLength = 512;
++    
+     // You already copied these first 8 bytes (the ipmi fru header size)
+     fruLength -= 8;
+ 
+@@ -690,6 +695,9 @@ bool formatFru(const std::vector<char>& fruBytes,
+ 
+     const std::vector<const char*>* fieldData;
+ 
++    //MiTAC: area overlapping check. 
++    std::vector<char>::const_iterator perviousAreaEnd = fruBytes.begin();
++    
+     for (const std::string& area : FRU_AREAS)
+     {
+         fruAreaOffsetField++;
+@@ -705,6 +713,13 @@ bool formatFru(const std::vector<char>& fruBytes,
+             std::vector<char>::const_iterator fruBytesIter =
+                 fruBytes.begin() + offset + 2;
+ 
++            //check area length and overlapping 
++            if(*(fruBytesIter-1) == 0 || *(fruBytesIter-1) == 0xff || fruBytesIter <= perviousAreaEnd )
++            {
++                //skip incorrect area
++                continue;
++            }
++            
+             if (fruBytesIter >= fruBytes.end())
+             {
+                 return false;
+@@ -771,6 +786,7 @@ bool formatFru(const std::vector<char>& fruBytes,
+                  * field to be read */
+                 if (static_cast<uint8_t>(*fruBytesIter) == 0xC1)
+                 {
++                    perviousAreaEnd = fruBytesIter;
+                     break;
+                 }
+ 
+@@ -797,7 +813,7 @@ bool formatFru(const std::vector<char>& fruBytes,
+                     std::cerr << "Warning Fru Length Mismatch:\n    ";
+                     for (auto& c : fruBytes)
+                     {
+-                        std::cerr << c;
++                        std::cerr <<" "<< std::hex << std::setw(2) << std::setfill('0')<<(static_cast<unsigned int>(c));
+                     }
+                     std::cerr << "\n";
+                     if (DEBUG)
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0005-remove-NVME-P4000.json.patch b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0005-remove-NVME-P4000.json.patch
new file mode 100755
index 0000000..299a2f2
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0005-remove-NVME-P4000.json.patch
@@ -0,0 +1,73 @@
+From 9afca6cc3c8eb86b72140cbbaf91beb90043eeda Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 11 Mar 2020 14:56:50 +0800
+Subject: [PATCH 1/1] remove NVME P4000.json
+
+---
+ configurations/NVME P4000.json | 53 ----------------------------------
+ 1 file changed, 53 deletions(-)
+ delete mode 100644 configurations/NVME P4000.json
+
+diff --git a/configurations/NVME P4000.json b/configurations/NVME P4000.json
+deleted file mode 100644
+index da8dacc..0000000
+--- a/configurations/NVME P4000.json	
++++ /dev/null
+@@ -1,53 +0,0 @@
+-{
+-    "Bus": "$bus",
+-    "Exposes": [
+-        {
+-            "Address": "$address",
+-            "Bus": "$bus",
+-            "Name": "NVMe $index FRU",
+-            "Type": "EEPROM"
+-        },
+-        {
+-            "Address": "0x53",
+-            "Bus": "$bus",
+-            "Name": "NVMe $index Temp",
+-            "Thresholds": [
+-                {
+-                    "Direction": "greater than",
+-                    "Name": "upper critical",
+-                    "Severity": 1,
+-                    "Value": 115
+-                },
+-                {
+-                    "Direction": "greater than",
+-                    "Name": "upper non critical",
+-                    "Severity": 0,
+-                    "Value": 110
+-                },
+-                {
+-                    "Direction": "less than",
+-                    "Name": "lower non critical",
+-                    "Severity": 0,
+-                    "Value": 5
+-                },
+-                {
+-                    "Direction": "less than",
+-                    "Name": "lower critical",
+-                    "Severity": 1,
+-                    "Value": 0
+-                }
+-            ],
+-            "Type": "NVME1000"
+-        }
+-    ],
+-    "Name": "NVMe $index",
+-    "Probe": "xyz.openbmc_project.FruDevice({'PRODUCT_PRODUCT_NAME': 'P\\d{4}\\w?'})",
+-    "Type": "NVMe",
+-    "xyz.openbmc_project.Inventory.Decorator.Asset": {
+-        "Manufacturer": "$PRODUCT_MANUFACTURER",
+-        "Model": "$PRODUCT_PRODUCT_NAME",
+-        "PartNumber": "$PRODUCT_PART_NUMBER",
+-        "SerialNumber": "$PRODUCT_SERIAL_NUMBER"
+-    },
+-    "xyz.openbmc_project.Inventory.Item.Chassis": {}
+-}
+\ No newline at end of file
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0006-Set-the-EntityManager-service-booting-after-FruDevic.patch b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0006-Set-the-EntityManager-service-booting-after-FruDevic.patch
new file mode 100755
index 0000000..5cba4b1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/0006-Set-the-EntityManager-service-booting-after-FruDevic.patch
@@ -0,0 +1,24 @@
+From a7dd1ad04be08c9330e25d55055a4c5d3ff1ddec Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 6 Apr 2020 09:39:34 +0800
+Subject: [PATCH] Set the EntityManager service booting after FruDevice service
+
+---
+ service_files/xyz.openbmc_project.EntityManager.service | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/service_files/xyz.openbmc_project.EntityManager.service b/service_files/xyz.openbmc_project.EntityManager.service
+index 651b0f2..1bcc9f4 100644
+--- a/service_files/xyz.openbmc_project.EntityManager.service
++++ b/service_files/xyz.openbmc_project.EntityManager.service
+@@ -1,6 +1,6 @@
+ [Unit]
+ Description=Entity Manager
+-After=dbus.service
++After=dbus.service xyz.openbmc_project.FruDevice.service
+ 
+ [Service]
+ ExecStartPre=/bin/mkdir -p /var/configuration
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Chicony-R550-PSU.json b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Chicony-R550-PSU.json
new file mode 100755
index 0000000..877cd50
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Chicony-R550-PSU.json
@@ -0,0 +1,157 @@
+[
+     {
+        "Exposes": [
+            {
+                "Address": "0x58",
+                "Bus": "$bus",
+                "Name": "PSU0",
+                "Labels": ["pin", "pout1", "vin", "vout1", "iin", "iout1", "temp1", "fan1"],
+                "pin_Max": 1500,
+                "pin_Min": 0,
+                "pout1_Max": 1500,
+                "pout1_Min": 0,
+                "vin_Max": 300,
+                "vin_Min": 0,
+                "vout1_Max": 20,
+                "vout1_Min": 0,
+                "iin_Max": 15,
+                "iin_Min": 0,
+                "iout1_Max": 90,
+                "iout1_Min": 0,
+                "temp1_Max": 127,
+                "temp1_Min": -127,
+                "fan1_Max": 30000,
+                "fan1_Min": 0,
+                "PowerStates": [
+                    {
+                        "Label": "pin",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "pout1",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "vin",
+                        "PowerState": "Always"
+                    },
+                    {
+                        "Label": "vout1",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "iin",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "iout1",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "temp1",
+                        "PowerState": "Always"
+                    },
+                    {
+                        "Label": "fan1",
+                        "PowerState": "Always"
+                    }
+                ],
+                "Thresholds": [
+                    {
+                        "Direction": "greater than",
+                        "Label": "pin",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 605
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "pout1",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 550
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "vin",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 264
+                    },
+                    {
+                        "Direction": "less than",
+                        "Label": "vin",
+                        "Name": "lower non critical",
+                        "Severity": 0,
+                        "Value": 90
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "vout1",
+                        "Name": "upper critical",
+                        "Severity": 1,
+                        "Value": 12.809
+                    },
+                    {
+                        "Direction": "less than",
+                        "Label": "vout1",
+                        "Name": "lower critical",
+                        "Severity": 1,
+                        "Value": 11.59
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "iout1",
+                        "Name": "upper critical",
+                        "Severity": 1,
+                        "Value": 63.75
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "iout1",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 46.75
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "temp1",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 55
+                    },
+                    {
+                        "Direction": "less than",
+                        "Label": "temp1",
+                        "Name": "lower non critical",
+                        "Severity": 0,
+                        "Value": 0
+                    },
+                    {
+                        "Direction": "less than",
+                        "Label": "fan1",
+                        "Name": "lower critical",
+                        "Severity": 1,
+                        "Value": 1500
+                    }
+                ],
+                "Type": "pmbus"
+            },
+            {
+                "Address": "$address",
+                "Bus": "$bus",
+                "Name": "Chicony R550 PSU FRU",
+                "Type": "EEPROM"
+            }
+        ],
+        "Name": "Chicony R550 PSU 1",
+        "Probe": "xyz.openbmc_project.FruDevice({'PRODUCT_PRODUCT_NAME': '.*R550*'})",
+        "Type": "PowerSupply",
+        "xyz.openbmc_project.Inventory.Decorator.Asset": {
+            "Manufacturer": "$BOARD_MANUFACTURER",
+            "Model": "$BOARD_PRODUCT_NAME",
+            "PartNumber": "$BOARD_PART_NUMBER",
+            "SerialNumber": "$BOARD_SERIAL_NUMBER"
+        }
+    }
+]
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Common-PSU.json b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Common-PSU.json
new file mode 100755
index 0000000..e1a6ef1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Common-PSU.json
@@ -0,0 +1,27 @@
+[
+     {
+        "Exposes": [
+            {
+                "Address": "0x58",
+                "Bus": "$bus",
+                "Name": "PSU0",
+                "Type": "pmbus"
+            },
+            {
+                "Address": "$address",
+                "Bus": "$bus",
+                "Name": "Common PSU FRU",
+                "Type": "EEPROM"
+            }
+        ],
+        "Name": "Common PSU 1",
+		"Probe": "xyz.openbmc_project.FruDevice({'BUS' : 7, 'ADDRESS' : 80})",
+        "Type": "PowerSupply",
+        "xyz.openbmc_project.Inventory.Decorator.Asset": {
+            "Manufacturer": "$BOARD_MANUFACTURER",
+            "Model": "$BOARD_PRODUCT_NAME",
+            "PartNumber": "$BOARD_PART_NUMBER",
+            "SerialNumber": "$BOARD_SERIAL_NUMBER"
+        }
+    }
+]
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-500AB-PSU.json b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-500AB-PSU.json
new file mode 100755
index 0000000..c156c2d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-500AB-PSU.json
@@ -0,0 +1,27 @@
+[
+     {
+        "Exposes": [
+            {
+                "Address": "0x58",
+                "Bus": "$bus",
+                "Name": "PSU0",
+                "Type": "pmbus"
+            },
+            {
+                "Address": "$address",
+                "Bus": "$bus",
+                "Name": "Delta DPS-500AB PSU FRU",
+                "Type": "EEPROM"
+            }
+        ],
+        "Name": "Delta DPS-500AB PSU 1",
+		"Probe": "xyz.openbmc_project.FruDevice({'PRODUCT_PRODUCT_NAME': '.*DPS-500*'})",
+        "Type": "PowerSupply",
+        "xyz.openbmc_project.Inventory.Decorator.Asset": {
+            "Manufacturer": "$BOARD_MANUFACTURER",
+            "Model": "$BOARD_PRODUCT_NAME",
+            "PartNumber": "$BOARD_PART_NUMBER",
+            "SerialNumber": "$BOARD_SERIAL_NUMBER"
+        }
+    }
+]
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-550AB-PSU.json b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-550AB-PSU.json
new file mode 100755
index 0000000..771b65f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-550AB-PSU.json
@@ -0,0 +1,157 @@
+[
+     {
+        "Exposes": [
+            {
+                "Address": "0x58",
+                "Bus": "$bus",
+                "Name": "PSU0",
+                "Labels": ["pin", "pout1", "vin", "vout1", "iin", "iout1", "temp1", "fan1"],
+                "pin_Max": 1500,
+                "pin_Min": 0,
+                "pout1_Max": 1500,
+                "pout1_Min": 0,
+                "vin_Max": 300,
+                "vin_Min": 0,
+                "vout1_Max": 20,
+                "vout1_Min": 0,
+                "iin_Max": 15,
+                "iin_Min": 0,
+                "iout1_Max": 90,
+                "iout1_Min": 0,
+                "temp1_Max": 127,
+                "temp1_Min": -127,
+                "fan1_Max": 30000,
+                "fan1_Min": 0,
+                "PowerStates": [
+                    {
+                        "Label": "pin",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "pout1",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "vin",
+                        "PowerState": "Always"
+                    },
+                    {
+                        "Label": "vout1",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "iin",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "iout1",
+                        "PowerState": "On"
+                    },
+                    {
+                        "Label": "temp1",
+                        "PowerState": "Always"
+                    },
+                    {
+                        "Label": "fan1",
+                        "PowerState": "Always"
+                    }
+                ],
+                "Thresholds": [
+                    {
+                        "Direction": "greater than",
+                        "Label": "pin",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 652
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "pout1",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 550
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "vin",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 264
+                    },
+                    {
+                        "Direction": "less than",
+                        "Label": "vin",
+                        "Name": "lower non critical",
+                        "Severity": 0,
+                        "Value": 90
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "vout1",
+                        "Name": "upper critical",
+                        "Severity": 1,
+                        "Value": 12.811
+                    },
+                    {
+                        "Direction": "less than",
+                        "Label": "vout1",
+                        "Name": "lower critical",
+                        "Severity": 1,
+                        "Value": 11.59
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "iout1",
+                        "Name": "upper critical",
+                        "Severity": 1,
+                        "Value": 67.5
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "iout1",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 49.5
+                    },
+                    {
+                        "Direction": "greater than",
+                        "Label": "temp1",
+                        "Name": "upper non critical",
+                        "Severity": 0,
+                        "Value": 55
+                    },
+                    {
+                        "Direction": "less than",
+                        "Label": "temp1",
+                        "Name": "lower non critical",
+                        "Severity": 0,
+                        "Value": 0
+                    },
+                    {
+                        "Direction": "less than",
+                        "Label": "fan1",
+                        "Name": "lower critical",
+                        "Severity": 1,
+                        "Value": 2500
+                    }
+                ],
+                "Type": "pmbus"
+            },
+            {
+                "Address": "$address",
+                "Bus": "$bus",
+                "Name": "Delta DPS-550AB PSU FRU",
+                "Type": "EEPROM"
+            }
+        ],
+        "Name": "Delta DPS-550AB PSU 1",
+        "Probe": "xyz.openbmc_project.FruDevice({'PRODUCT_PRODUCT_NAME': '.*DPS-550*'})",
+        "Type": "PowerSupply",
+        "xyz.openbmc_project.Inventory.Decorator.Asset": {
+            "Manufacturer": "$BOARD_MANUFACTURER",
+            "Model": "$BOARD_PRODUCT_NAME",
+            "PartNumber": "$BOARD_PART_NUMBER",
+            "SerialNumber": "$BOARD_SERIAL_NUMBER"
+        }
+    }
+]
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-650AB-PSU.json b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-650AB-PSU.json
new file mode 100755
index 0000000..6d7064f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Delta-DPS-650AB-PSU.json
@@ -0,0 +1,27 @@
+[
+     {
+        "Exposes": [
+            {
+                "Address": "0x58",
+                "Bus": "$bus",
+                "Name": "PSU0",
+                "Type": "pmbus"
+            },
+            {
+                "Address": "$address",
+                "Bus": "$bus",
+                "Name": "Delta DPS-650AB PSU FRU",
+                "Type": "EEPROM"
+            }
+        ],
+        "Name": "Delta DPS-650AB PSU 1",
+		"Probe": "xyz.openbmc_project.FruDevice({'PRODUCT_PRODUCT_NAME': '.*DPS-650*'})",
+        "Type": "PowerSupply",
+        "xyz.openbmc_project.Inventory.Decorator.Asset": {
+            "Manufacturer": "$BOARD_MANUFACTURER",
+            "Model": "$BOARD_PRODUCT_NAME",
+            "PartNumber": "$BOARD_PART_NUMBER",
+            "SerialNumber": "$BOARD_SERIAL_NUMBER"
+        }
+    }
+]
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Intel-V710-NIC.json b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Intel-V710-NIC.json
new file mode 100755
index 0000000..5423dad
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/Intel-V710-NIC.json
@@ -0,0 +1,34 @@
+{
+    "Exposes": [
+        {
+            "Address": "0x51",
+            "Bus": "17",
+            "Name": "Intel XL710 NIC",
+            "Type": "EEPROM"
+        },
+        {
+            "Address": "0x1f",
+            "Bus": 17,
+            "Name": "NIC_Temp",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Label": "temp1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 105
+                }
+            ],
+            "Type": "TMP75"
+        }
+    ],
+    "Name": "Intel V710 NIC",
+    "Probe": "xyz.openbmc_project.FruDevice({'BOARD_PRODUCT_NAME': '.*XL710*'})",
+    "Type": "Board",
+    "xyz.openbmc_project.Inventory.Decorator.Asset": {
+        "Manufacturer": "$PRODUCT_MANUFACTURER",
+        "Model": "$PRODUCT_PRODUCT_NAME",
+        "PartNumber": "$PRODUCT_PART_NUMBER",
+        "SerialNumber": "$PRODUCT_SERIAL_NUMBER"
+    }
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/blacklist.json b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/blacklist.json
new file mode 100755
index 0000000..2a1cb06
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/blacklist.json
@@ -0,0 +1,3 @@
+{
+    "buses": [0,1,2,3,4,5,8,9,10,11,12,13,14,15,16,18,19,20,21,22,23,24,25]
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/s5549-Baseboard.json b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/s5549-Baseboard.json
new file mode 100755
index 0000000..903dc2c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager/s5549-Baseboard.json
@@ -0,0 +1,1262 @@
+{
+    "Exposes": [
+        {
+            "Address": "0x8",
+            "Class": "METemp",
+            "Name": "PCH_Temp",
+            "PowerState": "On",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 90
+                }
+            ],
+            "Type": "IpmbSensor"
+        },
+        {
+            "Address": "0x30",
+            "Bus": 0,
+            "CpuID": 1,
+            "Name": "CPU0 Temp",
+            "Labels": [
+                {
+                    "Die" : "CPU0_Temp",
+                    "DIMM_A1" : "CPU0_MC0_DIMM_A",
+                    "DIMM_B1" : "CPU0_MC0_DIMM_B",
+                    "DIMM_C1" : "CPU0_MC0_DIMM_C",
+                    "DIMM_D1" : "CPU0_MC1_DIMM_D",
+                    "DIMM_E1" : "CPU0_MC1_DIMM_E",
+                    "DIMM_F1" : "CPU0_MC1_DIMM_F",
+                    "Tjmax" : "CPU0_DTS_Margin"
+                }
+            ],
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_A1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_B1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_C1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_D1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_E1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_F1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "Die",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 95
+                }
+            ],
+            "Type": "XeonCPU"
+        },
+        {
+            "Address": "0x31",
+            "Bus": 0,
+            "CpuID": 2,
+            "Name": "CPU1 Temp",
+            "Labels": [
+                {
+                    "Die" : "CPU1_Temp",
+                    "DIMM_A1" : "CPU1_MC0_DIMM_A",
+                    "DIMM_B1" : "CPU1_MC0_DIMM_B",
+                    "DIMM_C1" : "CPU1_MC0_DIMM_C",
+                    "DIMM_D1" : "CPU1_MC1_DIMM_D",
+                    "DIMM_E1" : "CPU1_MC1_DIMM_E",
+                    "DIMM_F1" : "CPU1_MC1_DIMM_F",
+                    "Tjmax" : "CPU1_DTS_Margin"
+                }
+            ],
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_A1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_B1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_C1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_D1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_E1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "DIMM_F1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 85
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "Die",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 95
+                }
+            ],
+            "Type": "XeonCPU"
+        },        
+        {
+            "Index": 0,
+            "Name": "PVCCIN_CPU0",
+            "PowerState": "On",
+            "ScaleFactor": 0.7505,
+            "MaxReading": 3,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.965
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 0.498
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 1,
+            "Name": "PVCCIO_CPU0",
+            "PowerState": "On",
+            "ScaleFactor": 1,
+            "MaxReading": 2,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.202
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 0.497
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 2,
+            "Name": "PVDDQ_CPU0",
+            "PowerState": "On",
+            "ScaleFactor": 1,
+            "MaxReading": 2,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.354
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 1.044
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 3,
+            "Name": "PVPP_CPU0",
+            "PowerState": "On",
+            "ScaleFactor": 0.5417,
+            "MaxReading": 5,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 2.808
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 2.197
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 4,
+            "Name": "PVCCIN_CPU1",
+            "PowerState": "On",
+            "ScaleFactor": 0.7505,
+            "MaxReading": 3,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.965
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 0.498
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 5,
+            "Name": "PVCCIO_CPU1",
+            "PowerState": "On",
+            "ScaleFactor": 1,
+            "MaxReading": 2,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.202
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 0.497
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 6,
+            "Name": "PVDDQ_CPU1",
+            "PowerState": "On",
+            "ScaleFactor": 1,
+            "MaxReading": 2,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.354
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 1.044
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 7,
+            "Name": "PVPP_CPU1",
+            "PowerState": "On",
+            "ScaleFactor": 0.5417,
+            "MaxReading": 5,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 2.808
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 2.197
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 8,
+            "Name": "P12V",
+            "PowerState": "On",
+            "ScaleFactor": 0.1122,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 12.978
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 10.458
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 9,
+            "Name": "P5V",
+            "PowerState": "On",
+            "ScaleFactor": 0.2667,
+            "MaxReading": 10,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 5.518
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 4.488
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 10,
+            "Name": "P3V3",
+            "PowerState": "On",
+            "ScaleFactor": 0.4052,
+            "MaxReading": 5,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 3.584
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 2.697
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 11,
+            "Name": "P3V3_AUX",
+            "PowerState": "Always",
+            "ScaleFactor": 0.4052,
+            "MaxReading": 5,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 3.584
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 2.697
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 12,
+            "Name": "P1V8_PCH_AUX",
+            "PowerState": "Always",
+            "ScaleFactor": 0.75,
+            "MaxReading": 3,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.993
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 1.495
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 13,
+            "Name": "PVNN_PCH_AUX",
+            "PowerState": "Always",
+            "ScaleFactor": 1,
+            "MaxReading": 2,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.195
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 0.799
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 14,
+            "Name": "P1V05_PCH_AUX",
+            "PowerState": "Always",
+            "ScaleFactor": 1,
+            "MaxReading": 2,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 1.246
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 0.85
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+            "Index": 15,
+            "Name": "RTC_BAT",
+            "PowerState": "Always",
+            "ScaleFactor": 0.3333,
+            "MaxReading": 5,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 3.482
+                },
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 2.3
+                }
+            ],
+            "Type": "ADC"
+        },
+        {
+
+            "Connector": {
+                "Name": "CPU Fan Connector 0",
+                "Pwm": 0,
+                "Tachs": [
+                    0
+                ]
+            },
+            "Index": 0,
+            "Name": "SYS_FAN_2",
+            "Thresholds": [
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 100
+                }
+            ],
+            "Type": "AspeedFan"
+        },
+        {
+            "Connector": {
+                "Name": "CPU Fan Connector 1",
+                "Pwm": 1,
+                "Tachs": [
+                    1
+                ]
+            },
+            "Index": 1,
+            "Name": "SYS_FAN_3",
+            "Thresholds": [
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 100
+                }
+            ],
+            "Type": "AspeedFan"
+        },
+        {
+            "Connector": {
+                "Name": "Sys FAN Connector 0",
+                "Pwm": 2,
+                "Tachs": [
+                    2
+                ]
+            },
+            "Index": 2,
+            "Name": "SYS_FAN_1",
+            "Thresholds": [
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 100
+                }
+            ],
+            "Type": "AspeedFan"
+        },
+        {
+            "Connector": {
+                "Name": "Sys FAN Connector 1",
+                "Pwm": 3,
+                "Tachs": [
+                    3
+                ]
+            },
+            "Index": 3,
+            "Name": "SYS_FAN_4",
+            "Thresholds": [
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 100
+                }
+            ],
+            "Type": "AspeedFan"
+        },
+        {
+            "Connector": {
+                "Name": "Sys FAN Connector 2",
+                "Pwm": 4,
+                "Tachs": [
+                    4
+                ]
+            },
+            "Index": 4,
+            "Name": "SYS_FAN_5",
+            "Thresholds": [
+                {
+                    "Direction": "less than",
+                    "Name": "lower critical",
+                    "Severity": 1,
+                    "Value": 100
+                }
+            ],
+            "Type": "AspeedFan"
+        },
+        {
+            "Address": "0x28",
+            "Bus": 0,
+            "Name": "SYS_Air_Inlet",
+            "Name1": "MB_Air_Inlet",
+            "Name2": "SYS_Air_Outlet",
+            "HysteresisVal": 3,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Label": "temp1",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 35
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "temp2",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 50
+                },
+                {
+                    "Direction": "greater than",
+                    "Label": "temp3",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 70
+                }
+            ],
+            "Type": "TMP75"
+        },
+        {
+            "Address": "0x1f",
+            "Bus": 14,
+            "Name": "OCP_TEMP",
+            "Name1": "NIC_Temp",
+            "OffsetValue": 23,
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Label": "temp2",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 105
+                }
+            ],
+            "Type": "TMP421"
+        },
+        {
+            "Address": "0x61",
+            "Bus": 4,
+            "Reg": "0x8d",
+            "Class": "MOSTemp",
+            "Name": "CPU0_MOS",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 110
+                }
+            ],
+            "Type": "MOSTempSensor"
+        },
+        {
+            "Address": "0x63",
+            "Bus": 4,
+            "Reg": "0x8d",
+            "Class": "MOSTemp",
+            "Name": "CPU1_MOS",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 110
+                }
+            ],
+            "Type": "MOSTempSensor"
+        },
+        {
+            "Address": "0x46",
+            "Bus": 4,
+            "Reg": "0x8d",
+            "Class": "MOSTemp",
+            "Name": "CPU0_DIMM_MOS_1",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 110
+                }
+            ],
+            "Type": "MOSTempSensor"
+        },
+        {
+            "Address": "0x47",
+            "Bus": 4,
+            "Reg": "0x8d",
+            "Class": "MOSTemp",
+            "Name": "CPU0_DIMM_MOS_2",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 110
+                }
+            ],
+            "Type": "MOSTempSensor"
+        },
+        {
+            "Address": "0x66",
+            "Bus": 4,
+            "Reg": "0x8d",
+            "Class": "MOSTemp",
+            "Name": "CPU1_DIMM_MOS_1",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 110
+                }
+            ],
+            "Type": "MOSTempSensor"
+        },
+        {
+            "Address": "0x67",
+            "Bus": 4,
+            "Reg": "0x8d",
+            "Class": "MOSTemp",
+            "Name": "CPU1_DIMM_MOS_2",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 110
+                }
+            ],
+            "Type": "MOSTempSensor"
+        },
+        {
+            "Address": "0x53",
+            "Bus": "22",
+            "Name": "NVMe 0 FRU",
+            "Type": "EEPROM"
+        },
+        {
+            "Address": "0x6A",
+            "Bus": "22",
+            "Name": "NVMe 0 Temp",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 70
+                }
+            ],
+            "Type": "NVME1000"
+        },
+        {
+            "Address": "0x53",
+            "Bus": "25",
+            "Name": "NVMe 1 FRU",
+            "Type": "EEPROM"
+        },
+        {
+            "Address": "0x6A",
+            "Bus": "25",
+            "Name": "NVMe 1 Temp",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 70
+                }
+            ],
+            "Type": "NVME1000"
+        },
+        {
+            "Address": "0x53",
+            "Bus": "23",
+            "Name": "NVMe 2 FRU",
+            "Type": "EEPROM"
+        },
+        {
+            "Address": "0x6A",
+            "Bus": "23",
+            "Name": "NVMe 2 Temp",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 70
+                }
+            ],
+            "Type": "NVME1000"
+        },
+        {
+            "Address": "0x6A",
+            "Bus": "20",
+            "Name": "NVMe 3 Temp",
+            "Thresholds": [
+                {
+                    "Direction": "greater than",
+                    "Name": "upper critical",
+                    "Severity": 1,
+                    "Value": 70
+                }
+            ],
+            "Type": "NVME1000"
+        },
+        {
+            "Address": "0x53",
+            "Bus": "20",
+            "Name": "NVMe 3 FRU",
+            "Type": "EEPROM"
+        },
+        {
+            "FailSafePercent": 25,
+            "MinThermalOutput": 25,
+            "CommandSet": 0,
+            "FloorDuty": 0,
+            "Name": "Pid 1",
+            "Type": "Pid.Zone"
+        },
+        {
+            "FailSafePercent": 25,
+            "MinThermalOutput": 25,
+            "CommandSet": 0,
+            "FloorDuty": 0,
+            "Name": "Pid 2",
+            "Type": "Pid.Zone"
+        },
+        {
+            "FailSafePercent": 25,
+            "MinThermalOutput": 25,
+            "CommandSet": 0,
+            "FloorDuty": 0,
+            "Name": "Pid 3",
+            "Type": "Pid.Zone"
+        },
+        {
+            "FailSafePercent": 25,
+            "MinThermalOutput": 25,
+            "CommandSet": 0,
+            "FloorDuty": 0,
+            "Name": "Pid 4",
+            "Type": "Pid.Zone"
+        },
+        {
+            "FailSafePercent": 25,
+            "MinThermalOutput": 25,
+            "CommandSet": 0,
+            "FloorDuty": 0,
+            "Name": "Pid 5",
+            "Type": "Pid.Zone"
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "CPU0_Temp"
+            ],
+            "Name": "FSC_CPU0",
+            "SetPointH": 5000,
+            "SetPointL": 10000,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 1",
+                "Pid 2",
+                "Pid 3"
+            ]
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "CPU1_Temp"
+            ],
+            "Name": "FSC_CPU1",
+            "SetPointH": 5000,
+            "SetPointL": 10000,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 2",
+                "Pid 4",
+                "Pid 5"
+            ]
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "CPU0_MC1_DIMM_D",
+                "CPU0_MC1_DIMM_E",
+                "CPU0_MC1_DIMM_F"
+            ],
+            "Name": "FSC_DIMM_DEF_CPU0",
+            "SetPointH": 72,
+            "SetPointL": 64,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 1",
+                "Pid 2"
+            ]
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "CPU0_MC0_DIMM_A",
+                "CPU0_MC0_DIMM_B",
+                "CPU0_MC0_DIMM_C"
+            ],
+            "Name": "FSC_DIMM_ABC_CPU0",
+            "SetPointH": 72,
+            "SetPointL": 64,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 3"
+            ]
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "CPU1_MC0_DIMM_A",
+                "CPU1_MC0_DIMM_B",
+                "CPU1_MC0_DIMM_C"
+            ],
+            "Name": "FSC_DIMM_ABC_CPU1",
+            "SetPointH": 72,
+            "SetPointL": 64,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 2",
+                "Pid 4"
+            ]
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "CPU1_MC1_DIMM_D",
+                "CPU1_MC1_DIMM_E",
+                "CPU1_MC1_DIMM_F"
+            ],
+            "Name": "FSC_DIMM_DEF_CPU1",
+            "SetPointH": 72,
+            "SetPointL": 64,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 5"
+            ]
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "PCH_Temp"
+            ],
+            "Name": "FSC_PCH",
+            "SetPointH": 77,
+            "SetPointL": 69,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 1",
+                "Pid 3"
+            ]
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "NIC_Temp"
+            ],
+            "Name": "FSC_OCP_NIC",
+            "SetPointH": 85,
+            "SetPointL": 77,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 1",
+                "Pid 2"
+            ]
+        },
+        {
+            "Class": "temp",
+            "Inputs": [
+                "SYS_Air_Inlet",
+                "NVMe 0 Temp",
+                "NVMe 1 Temp",
+                "NVMe 2 Temp",
+                "NVMe 3 Temp"
+            ],
+            "Name": "FSC_NVMe",
+            "SetPointH": 65,
+            "SetPointL": 62,
+            "OutLimitMax": 70,
+            "NegativeHysteresis": 0,
+            "Output": [
+                25.0,
+                30.0
+            ],
+            "PositiveHysteresis": 0,
+            "Reading": [
+                29.0,
+                30.0
+            ],
+            "Type": "Fsc",
+            "Zones": [
+                "Pid 1",
+                "Pid 2",
+                "Pid 3",
+                "Pid 4",
+                "Pid 5"
+            ]
+        },
+        {
+            "Class": "fan",
+            "FFGainCoefficient": 1.0,
+            "FFOffCoefficient": 0.0,
+            "ICoefficient": 0.0,
+            "ILimitMax": 0.0,
+            "ILimitMin": 0.0,
+            "Inputs": [
+                "SYS_FAN_2"
+            ],
+            "Name": "FSC_SYS_FAN_2",
+            "OutLimitMax": 100.0,
+            "OutLimitMin": 25.0,
+            "Outputs": [
+                "Pwm 1"
+            ],
+            "PCoefficient": 0.0,
+            "SlewNeg": 0.0,
+            "SlewPos": 0.0,
+            "Type": "Pid",
+            "Zones": [
+                "Pid 1"
+            ]
+        },
+        {
+            "Class": "fan",
+            "FFGainCoefficient": 1.0,
+            "FFOffCoefficient": 0.0,
+            "ICoefficient": 0.0,
+            "ILimitMax": 0.0,
+            "ILimitMin": 0.0,
+            "Inputs": [
+                "SYS_FAN_3"
+            ],
+            "Name": "FSC_SYS_FAN_3",
+            "OutLimitMax": 100.0,
+            "OutLimitMin": 25.0,
+            "Outputs": [
+                "Pwm 2"
+            ],
+            "PCoefficient": 0.0,
+            "SlewNeg": 0.0,
+            "SlewPos": 0.0,
+            "Type": "Pid",
+            "Zones": [
+                "Pid 2"
+            ]
+        },
+        {
+            "Class": "fan",
+            "FFGainCoefficient": 1.0,
+            "FFOffCoefficient": 0.0,
+            "ICoefficient": 0.0,
+            "ILimitMax": 0.0,
+            "ILimitMin": 0.0,
+            "Inputs": [
+                "SYS_FAN_1"
+            ],
+            "Name": "FSC_SYS_FAN_1",
+            "OutLimitMax": 100.0,
+            "OutLimitMin": 25.0,
+            "Outputs": [
+                "Pwm 3"
+            ],
+            "PCoefficient": 0.0,
+            "SlewNeg": 0.0,
+            "SlewPos": 0.0,
+            "Type": "Pid",
+            "Zones": [
+                "Pid 3"
+            ]
+        },
+        {
+            "Class": "fan",
+            "FFGainCoefficient": 1.0,
+            "FFOffCoefficient": 0.0,
+            "ICoefficient": 0.0,
+            "ILimitMax": 0.0,
+            "ILimitMin": 0.0,
+            "Inputs": [
+                "SYS_FAN_4"
+            ],
+            "Name": "FSC_SYS_FAN_4",
+            "OutLimitMax": 100.0,
+            "OutLimitMin": 25.0,
+            "Outputs": [
+                "Pwm 4"
+            ],
+            "PCoefficient": 0.0,
+            "SlewNeg": 0.0,
+            "SlewPos": 0.0,
+            "Type": "Pid",
+            "Zones": [
+                "Pid 4"
+            ]
+        },
+        {
+            "Class": "fan",
+            "FFGainCoefficient": 1.0,
+            "FFOffCoefficient": 0.0,
+            "ICoefficient": 0.0,
+            "ILimitMax": 0.0,
+            "ILimitMin": 0.0,
+            "Inputs": [
+                "SYS_FAN_5"
+            ],
+            "Name": "FSC_SYS_FAN_5",
+            "OutLimitMax": 100.0,
+            "OutLimitMin": 25.0,
+            "Outputs": [
+                "Pwm 5"
+            ],
+            "PCoefficient": 0.0,
+            "SlewNeg": 0.0,
+            "SlewPos": 0.0,
+            "Type": "Pid",
+            "Zones": [
+                "Pid 5"
+            ]
+        }        
+    ],
+    "Name": "s5549 Baseboard",
+    "Probe": "xyz.openbmc_project.FruDevice({'BOARD_PRODUCT_NAME': '.*E3331*'})",
+    "Type": "Board",
+    "xyz.openbmc_project.Inventory.Decorator.Asset": {
+        "ChassisType": "$CHASSIS_TYPE",
+        "ChassisPartNumber": "$CHASSIS_PART_NUMBER",
+        "ChassisSerial": "$CHASSIS_SERIAL_NUMBER",
+        "ChassisExtra": "$CHASSIS_INFO_AM1",
+        "BoardMfgDate": "$BOARD_MANUFACTURE_DATE",
+        "BoardMfg": "$BOARD_MANUFACTURER",
+        "BoardProduct": "$BOARD_PRODUCT_NAME",
+        "BoardSerial": "$BOARD_SERIAL_NUMBER",
+        "BoardPartNumber": "$BOARD_PRODUCT_NAME",
+        "ProductName": "$PRODUCT_PRODUCT_NAME",
+        "ProductPartNumber": "$PRODUCT_PART_NUMBER",
+        "ProductVersion": "$PRODUCT_VERSION",
+        "ProductSerial": "$PRODUCT_SERIAL_NUMBER"
+    }
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager_git.bbappend
new file mode 100755
index 0000000..8904381
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-manager_git.bbappend
@@ -0,0 +1,20 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://s5549-Baseboard.json \
+            file://Chicony-R550-PSU.json \
+            file://Delta-DPS-500AB-PSU.json \
+            file://Delta-DPS-550AB-PSU.json \
+            file://Delta-DPS-650AB-PSU.json \
+            file://Common-PSU.json \
+            file://blacklist.json \
+            file://0001-Support-baseboard-fru-reading.patch \
+            file://0004-fix-fsc-to-settable-interface.patch \
+            file://0005-remove-NVME-P4000.json.patch \
+            file://0006-Set-the-EntityManager-service-booting-after-FruDevic.patch \
+            "
+
+do_install_append(){
+	install -d ${D}/usr/share/entity-manager/configurations
+	install -m 0444 ${WORKDIR}/*.json ${D}/usr/share/entity-manager/configurations
+	install -m 0444 ${WORKDIR}/blacklist.json ${D}/usr/share/entity-manager
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan.bb b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan.bb
new file mode 100755
index 0000000..71014ad
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan.bb
@@ -0,0 +1,24 @@
+DESCRIPTION = "Entity rescan"
+PR = "r1"
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+inherit systemd
+inherit obmc-phosphor-systemd
+
+S = "${WORKDIR}/"
+SRC_URI = "file://entity_rescan.sh \
+           file://entity-rescan.service \
+           "
+
+DEPENDS = "systemd"
+RDEPENDS_${PN} = "bash"
+
+SYSTEMD_PACKAGES = "${PN}"
+SYSTEMD_SERVICE_${PN} = "entity-rescan.service"
+
+do_install() {
+    install -d ${D}/usr/sbin
+    install -m 0755 ${S}entity_rescan.sh ${D}/${sbindir}/
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan/entity-rescan.service b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan/entity-rescan.service
new file mode 100755
index 0000000..0d982a0
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan/entity-rescan.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Rescan Entity for Entity Manager
+Wants=xyz.openbmc_project.State.BMC.service
+After=xyz.openbmc_project.State.BMC.service
+Requires=phosphor-ipmi-host.service
+After=phosphor-ipmi-host.service
+
+[Service]
+Type=simple
+ExecStart=/usr/bin/env entity_rescan.sh
+SyslogIdentifier=entity_rescan
+
+[Install]
+WantedBy=multi-user.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan/entity_rescan.sh b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan/entity_rescan.sh
new file mode 100755
index 0000000..b8cde17
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/configuration/entity-rescan/entity_rescan.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+
+echo "Check the entity from entity manager"
+
+P3V3_AUX=$(busctl get-property xyz.openbmc_project.ADCSensor /xyz/openbmc_project/sensors/voltage/P3V3_AUX xyz.openbmc_project.Sensor.Value Value| cut -d' ' -f2)
+
+PSU0_INPUT_POWER=$(busctl get-property xyz.openbmc_project.PSUSensor /xyz/openbmc_project/sensors/voltage/PSU0_Input_Voltage  xyz.openbmc_project.Sensor.Value Value| cut -d' ' -f2)
+
+if [ -z $P3V3_AUX ] && [ -z $PSU0_INPUT_POWER ]; then
+    echo "Rescan for entity manager"
+    $(busctl call xyz.openbmc_project.EntityManager /xyz/openbmc_project/EntityManager xyz.openbmc_project.EntityManager ReScan)
+fi
+
+exit 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/0001-Support-start-preparing-and-stop-commnad-configurati.patch b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/0001-Support-start-preparing-and-stop-commnad-configurati.patch
new file mode 100755
index 0000000..0fb617b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/0001-Support-start-preparing-and-stop-commnad-configurati.patch
@@ -0,0 +1,93 @@
+From 99e68f8bd50a0cf33743db65712512fddf74e235 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 22 Sep 2020 19:27:54 +0800
+Subject: [PATCH] Support start preparing and stop commnad configuration
+
+---
+ socket-handler.c | 49 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 49 insertions(+)
+ mode change 100644 => 100755 socket-handler.c
+
+diff --git a/socket-handler.c b/socket-handler.c
+old mode 100644
+new mode 100755
+index be7daa4..0c41533
+--- a/socket-handler.c
++++ b/socket-handler.c
+@@ -54,6 +54,19 @@ struct socket_handler {
+ 	int			n_clients;
+ };
+ 
++struct Exec {
++	const char			*command;
++	const char			*address;
++	const char			*byte;
++	const char			*startPreValue;
++	const char			*stopVaule;
++	char				execStartPre[128];
++	char				execStop[128];
++	bool				enable;
++};
++
++struct Exec exec = { .enable = true };
++
+ static struct timeval const socket_handler_timeout = {
+ 	.tv_sec = 0,
+ 	.tv_usec = SOCKET_HANDLER_PKT_US_TIMEOUT
+@@ -69,6 +82,11 @@ static void client_close(struct client *client)
+ 	struct socket_handler *sh = client->sh;
+ 	int idx;
+ 
++	if(exec.enable)
++	{
++		system(exec.execStop);
++	}
++
+ 	close(client->fd);
+ 	if (client->poller)
+ 		console_poller_unregister(sh->console, client->poller);
+@@ -274,6 +292,11 @@ static enum poller_ret socket_poll(struct handler *handler,
+ 	struct client *client;
+ 	int fd, n;
+ 
++	if(exec.enable)
++	{
++		system(exec.execStartPre);
++	}
++
+ 	if (!(events & POLLIN))
+ 		return POLLER_OK;
+ 
+@@ -308,6 +331,32 @@ static int socket_init(struct handler *handler, struct console *console,
+ 	struct sockaddr_un addr;
+ 	int rc;
+ 
++	exec.command = config_get_value(config, "exec");
++	if (!exec.command)
++		exec.enable = false;
++
++	exec.address = config_get_value(config, "exec-address");
++	if (!exec.address)
++		exec.enable = false;
++
++	exec.byte = config_get_value(config, "exec-byte");
++	if (!exec.byte)
++		exec.enable = false;
++
++	exec.startPreValue = config_get_value(config, "exec-start-pre-value");
++	if (!exec.startPreValue)
++		exec.enable = false;
++
++	exec.stopVaule = config_get_value(config, "exec-stop-vaule");
++	if (!exec.stopVaule)
++		exec.enable = false;
++
++	if(exec.enable)
++	{
++		sprintf(&exec.execStartPre[0], "%s %s %s %s", exec.command, exec.address, exec.byte, exec.startPreValue);
++		sprintf(&exec.execStop[0], "%s %s %s %s", exec.command, exec.address, exec.byte, exec.stopVaule);
++	}
++
+ 	sh->console = console;
+ 	sh->clients = NULL;
+ 	sh->n_clients = 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/0002-Add-timestamps-to-SOL-buffer.patch b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/0002-Add-timestamps-to-SOL-buffer.patch
new file mode 100755
index 0000000..62e005c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/0002-Add-timestamps-to-SOL-buffer.patch
@@ -0,0 +1,102 @@
+From e72a7fb24a33745d245ea95a092c94775a782917 Mon Sep 17 00:00:00 2001
+From: Varun Sampat <vsampat@twitter.com>
+Date: Wed, 28 Oct 2020 18:14:44 -0400
+Subject: [PATCH] Add timestamps to SOL buffer
+
+---
+ console-server.h |  1 +
+ log-handler.c    |  2 +-
+ util.c           | 51 +++++++++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 53 insertions(+), 1 deletion(-)
+
+diff --git a/console-server.h b/console-server.h
+index d6822c5..711dd7e 100644
+--- a/console-server.h
++++ b/console-server.h
+@@ -144,6 +144,7 @@ extern const char *console_socket_path_readable;
+ 
+ /* utils */
+ int write_buf_to_fd(int fd, const uint8_t *buf, size_t len);
++int write_buf_to_log(int fd, const uint8_t *buf, size_t len);
+ 
+ #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+ 
+diff --git a/log-handler.c b/log-handler.c
+index 275cc81..49bd0f8 100644
+--- a/log-handler.c
++++ b/log-handler.c
+@@ -93,7 +93,7 @@ static int log_data(struct log_handler *lh, uint8_t *buf, size_t len)
+ 			return rc;
+ 	}
+ 
+-	rc = write_buf_to_fd(lh->fd, buf, len);
++	rc = write_buf_to_log(lh->fd, buf, len);
+ 	if (rc)
+ 		return rc;
+ 
+diff --git a/util.c b/util.c
+index d6e037a..a6c7461 100644
+--- a/util.c
++++ b/util.c
+@@ -16,6 +16,7 @@
+ 
+ #include <err.h>
+ #include <unistd.h>
++#include <time.h>
+ 
+ #include "console-server.h"
+ 
+@@ -35,3 +36,53 @@ int write_buf_to_fd(int fd, const uint8_t *buf, size_t len)
+ 	return 0;
+ }
+ 
++int write_buf_to_log(int fd, const uint8_t *buf, size_t len)
++{
++        size_t pos;
++        size_t count;
++        ssize_t rc, rc2;
++        time_t curr_time;
++        struct tm * timestruct;
++        int newline_found;
++        char timestring[35] = {'\0'};
++
++        pos = 0, count = 0, newline_found = 0;
++        while( pos < len) {
++                count = 0;
++                newline_found = 0;
++
++                while (( buf[pos+count] != '\n' ) && ((pos + count) < len))
++                        count++;
++
++                if ((buf[pos+count] == '\n') && ((pos+count) < len)) {
++                        newline_found = 1;
++			//Increment count by 1 to include the newline in the fd write
++                        count++;
++                }
++
++                rc = write(fd, buf + pos, count);
++                if (rc <= 0) {
++                        warn("Write error");
++                        return -1;
++                }
++
++                pos += rc;
++                time ( &curr_time );
++                timestruct = localtime ( &curr_time );
++
++                if(newline_found) {
++                        memset(timestring, '\0', sizeof(timestring));
++                        strcat(timestring, "[");
++			// Decrease the time string by 1 below to ignore the newline at the end
++                        strncat(timestring, asctime(timestruct),strlen(asctime (timestruct))-1);
++                        strcat(timestring, "]: ");
++                        rc2 = write(fd, timestring, strlen(asctime (timestruct))+3);
++                        if (rc2 <= 0) {
++                                warn("Write error");
++                                return -1;
++                        }
++                }
++        }
++        return 0;
++}
++
diff --git a/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/obmc-console-ssh@.service b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/obmc-console-ssh@.service
new file mode 100755
index 0000000..1771a8d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/obmc-console-ssh@.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Phosphor Host Console SSH Per-Connection
+Wants=obmc-console@{OBMC_CONSOLE_HOST_TTY}.service
+
+[Service]
+Environment="DROPBEAR_RSAKEY_DIR=/etc/dropbear"
+EnvironmentFile={envfiledir}/dropbear
+ExecStartPre=/sbin/devmem 0x1e78909c 32 0x01450000
+ExecStop=/sbin/devmem 0x1e78909c 32 0x01400000
+ExecStart=-/usr/bin/env dropbear -i -r ${{DROPBEAR_RSAKEY_DIR}}/dropbear_rsa_host_key -c "/usr/bin/env obmc-console-client" $DROPBEAR_EXTRA_ARGS
+SyslogIdentifier=dropbear
+ExecReload={base_bindir}/kill -HUP $MAINPID
+StandardInput=socket
+KillMode=process
diff --git a/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/obmc-console.conf b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/obmc-console.conf
new file mode 100755
index 0000000..6ed8faa
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console/obmc-console.conf
@@ -0,0 +1,8 @@
+local-tty = ttyS2
+local-tty-baud = 115200
+logsize = 5242880
+exec= /sbin/devmem
+exec-address = 0x1e78909c
+exec-byte = 32
+exec-start-pre-value = 0x01450000
+exec-stop-vaule = 0x01400000
diff --git a/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console_%.bbappend b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console_%.bbappend
new file mode 100755
index 0000000..a02d20b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/console/obmc-console_%.bbappend
@@ -0,0 +1,8 @@
+FILESEXTRAPATHS_prepend_s5549 := "${THISDIR}/${PN}:"
+OBMC_CONSOLE_HOST_TTY = "ttyS2"
+
+SRC_URI += "file://obmc-console-ssh@.service \
+            file://0001-Support-start-preparing-and-stop-commnad-configurati.patch \
+            file://0002-Add-timestamps-to-SOL-buffer.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0002-Add-interface-for-caterr-logging.patch b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0002-Add-interface-for-caterr-logging.patch
new file mode 100755
index 0000000..7c67504
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0002-Add-interface-for-caterr-logging.patch
@@ -0,0 +1,46 @@
+From b621ad429662ae7b652cf13bccb34ff9ace6abf8 Mon Sep 17 00:00:00 2001
+From: jeannie <jeannie@localhost.localdomain>
+Date: Fri, 22 Mar 2019 12:24:34 +0800
+Subject: [PATCH] Add interface for caterr logging
+
+---
+ xyz/openbmc_project/Control/Processor.interface.yaml | 20 ++++++++++++++++++++
+ .../Control/Processor/CPUError.errors.yaml           |  3 +++
+ 2 files changed, 23 insertions(+)
+ create mode 100644 xyz/openbmc_project/Control/Processor.interface.yaml
+ create mode 100644 xyz/openbmc_project/Control/Processor/CPUError.errors.yaml
+
+diff --git a/xyz/openbmc_project/Control/Processor.interface.yaml b/xyz/openbmc_project/Control/Processor.interface.yaml
+new file mode 100644
+index 0000000..d5c35bc
+--- /dev/null
++++ b/xyz/openbmc_project/Control/Processor.interface.yaml
+@@ -0,0 +1,19 @@
++description: >
++    This defines processor status
++
++properties:
++    - name: ProcessorStatus
++      type: enum[self.State]
++      description: >
++          The upper bound of the critical threshold.
++enumerations:
++    - name: State
++      description: >
++        The current state of the processor.
++      values:
++        - name: NORMAL
++          description: >
++            Processor in normal state.
++        - name: CATERR
++          description: >
++            Processor in CATTERR state.
+diff --git a/xyz/openbmc_project/Control/Processor/CPUError.errors.yaml b/xyz/openbmc_project/Control/Processor.errors.yaml
+new file mode 100644
+index 0000000..04ef73e
+--- /dev/null
++++ b/xyz/openbmc_project/Control/Processor.errors.yaml
+@@ -0,0 +1,3 @@
++#xyz.openbmc_project.Control.Processor.CATERR
++- name: CATERR
++  description: cpu CATERR occur. 
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0003-Add-SOL-PATTERN-Interface-for-SOL-Processing.patch b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0003-Add-SOL-PATTERN-Interface-for-SOL-Processing.patch
new file mode 100755
index 0000000..e7871cd
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0003-Add-SOL-PATTERN-Interface-for-SOL-Processing.patch
@@ -0,0 +1,37 @@
+From d5248e892236599753fc6ddac6da1560cdab16ea Mon Sep 17 00:00:00 2001
+From: "jeannie.wu" <jeannie.wu@mic.com.tw>
+Date: Tue, 9 Apr 2019 11:48:20 +0800
+Subject: [PATCH] Add SOL PATTERN Interface for SOL Processing
+
+---
+ xyz/openbmc_project/OEM/SOLPattern.interface.yaml | 21 +++++++++++++
+ 1 file changed, 21 insertions(+)
+ create mode 100644 xyz/openbmc_project/OEM/SOLPattern.interface.yaml
+
+diff --git a/xyz/openbmc_project/OEM/SOLPattern.interface.yaml b/xyz/openbmc_project/OEM/SOLPattern.interface.yaml
+new file mode 100644
+index 0000000..f8470c0
+--- /dev/null
++++ b/xyz/openbmc_project/OEM/SOLPattern.interface.yaml
+@@ -0,0 +1,21 @@
++description: >
++    Implement to provide SOL pattern attributes for sol processing.
++
++properties:
++    - name: PatternString
++      type: string
++      description: >
++         Patten String for search processing.
++    - name: MatchCount
++      type: int64
++      description: >
++         Patten match buffer number.
++    - name: CriticalThreshold
++      type: int64
++      description: >
++         The critical threshold fro matchcount.
++    - name: NonCriticalThreshold
++      type: int64
++      description: >
++         The non-critical threshold fro matchcount.
++# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0004-Add-interface-for-AC-restore-always-on-policy.patch b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0004-Add-interface-for-AC-restore-always-on-policy.patch
new file mode 100755
index 0000000..c8a056a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0004-Add-interface-for-AC-restore-always-on-policy.patch
@@ -0,0 +1,54 @@
+From d3edb09dbe6a32b9ee42552f36b0f0932e539fa7 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 23 Mar 2020 09:50:42 +0800
+Subject: [PATCH] Add interface for AC restore always-on policy
+
+---
+ .../Control/Power/RestorePolicy.interface.yaml     | 24 ++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+ mode change 100644 => 100755 xyz/openbmc_project/Control/Power/RestorePolicy.interface.yaml
+
+diff --git a/xyz/openbmc_project/Control/Power/RestorePolicy.interface.yaml b/xyz/openbmc_project/Control/Power/RestorePolicy.interface.yaml
+old mode 100644
+new mode 100755
+index 1f90937..a2e79ac
+--- a/xyz/openbmc_project/Control/Power/RestorePolicy.interface.yaml
++++ b/xyz/openbmc_project/Control/Power/RestorePolicy.interface.yaml
+@@ -9,6 +9,16 @@ properties:
+       description: >
+           The policy to adopt after the BMC reset.
+ 
++    - name: PowerRestoreDelay
++      type: uint32
++      description: >
++          The delay for setting always-on.
++
++    - name: PowerRestoreAlwaysOnPolicy
++      type: enum[self.AlwaysOnPolicy]
++      description: >
++          The policy to adopt after the BMC reset and using always-on policy.
++
+ enumerations:
+     - name: Policy
+       description: >
+@@ -24,3 +34,17 @@ enumerations:
+           description: >
+             Restore power to last requested state recorded before the BMC was
+             reset.
++
++    - name: AlwaysOnPolicy
++      description: >
++        Possible power restoration always-on policies.
++      values:
++        - name: Immediately
++          description: >
++            Without delay time for bmc power on
++        - name: Random
++          description: >
++            Set a random delay time for bmc power on.
++        - name: Fixed
++          description: >
++            Set a fixed delay time for bmc power on.
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0005-Add-interface-for-setting-specified-service-status.patch b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0005-Add-interface-for-setting-specified-service-status.patch
new file mode 100755
index 0000000..9d02dbb
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0005-Add-interface-for-setting-specified-service-status.patch
@@ -0,0 +1,28 @@
+From 78ce469465cecf834c1dcdddc04078eeb99b30d8 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 9 Apr 2020 15:43:30 +0800
+Subject: [PATCH] Add interface for setting specified service status
+
+---
+ xyz/openbmc_project/OEM/ServiceStatus.interface.yaml | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+ create mode 100755 xyz/openbmc_project/OEM/ServiceStatus.interface.yaml
+
+diff --git a/xyz/openbmc_project/OEM/ServiceStatus.interface.yaml b/xyz/openbmc_project/OEM/ServiceStatus.interface.yaml
+new file mode 100755
+index 0000000..cbb4559
+--- /dev/null
++++ b/xyz/openbmc_project/OEM/ServiceStatus.interface.yaml
+@@ -0,0 +1,9 @@
++description: >
++    Implement to provide status attributes for specified service.
++
++properties:
++    - name: WebService
++      type: boolean
++      description: >
++         Setting of bmc web 
++# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0006-Set-watchdog-initialized-flag-true-as-default.patch b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0006-Set-watchdog-initialized-flag-true-as-default.patch
new file mode 100755
index 0000000..181bb19
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0006-Set-watchdog-initialized-flag-true-as-default.patch
@@ -0,0 +1,22 @@
+From 2c49771b63ac6cabe4a2a0cbc8336c2fa1c0f9c3 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 20 May 2020 14:27:36 +0800
+Subject: [PATCH] Set watchdog initialized flag true as default
+
+---
+ xyz/openbmc_project/State/Watchdog.interface.yaml | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/xyz/openbmc_project/State/Watchdog.interface.yaml b/xyz/openbmc_project/State/Watchdog.interface.yaml
+index da95d4c..c2e17b5 100644
+--- a/xyz/openbmc_project/State/Watchdog.interface.yaml
++++ b/xyz/openbmc_project/State/Watchdog.interface.yaml
+@@ -22,7 +22,7 @@ properties:
+       type: boolean
+       description: >
+           Whether the host has configured the watchdog yet.
+-      default: false
++      default: True
+     - name: Enabled
+       type: boolean
+       description: >
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0007-Add-interface-for-DCMI-power.patch b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0007-Add-interface-for-DCMI-power.patch
new file mode 100755
index 0000000..211c2e1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0007-Add-interface-for-DCMI-power.patch
@@ -0,0 +1,54 @@
+From 70c2aa7a9b4f217da8315c034ee49427e6e1cfe6 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Fri, 29 May 2020 14:01:36 +0800
+Subject: [PATCH] Add interface for DCMI power
+
+---
+ .../Control/Power/Cap.interface.yaml               | 30 ++++++++++++++++++++++
+ 1 file changed, 30 insertions(+)
+ mode change 100644 => 100755 xyz/openbmc_project/Control/Power/Cap.interface.yaml
+
+diff --git a/xyz/openbmc_project/Control/Power/Cap.interface.yaml b/xyz/openbmc_project/Control/Power/Cap.interface.yaml
+old mode 100644
+new mode 100755
+index 2994b14..2514305
+--- a/xyz/openbmc_project/Control/Power/Cap.interface.yaml
++++ b/xyz/openbmc_project/Control/Power/Cap.interface.yaml
+@@ -13,3 +13,33 @@ properties:
+       description: >
+           Power cap enable.  Set to true to enable the PowerCap, false
+           to disable it.
++
++    - name: ExceptionAction
++      type: enum[self.Action]
++      description: >
++          Power exception action. The action for power exception.
++
++    - name: CorrectionTime
++      type: uint32
++      description: >
++          Power correction Time. The timeout time for power exception action.
++
++    - name: SamplingPeriod
++      type: uint16
++      description: >
++          Power sampling period. The time period for power value collect.
++
++enumerations:
++    - name: Action
++      description: >
++        The desired action for correction time timeout
++      values:
++        - name: 'None'
++          description: >
++            Correction time timeout do nothing
++        - name: 'OffAndLog'
++          description: >
++            Correction time timeout should be off and generate SEL event
++        - name: 'Log'
++          description: >
++            Correction time timeout should generate SEL event
+\ No newline at end of file
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0008-Set-watchdog-initialized-action-to-None-as-default.patch b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0008-Set-watchdog-initialized-action-to-None-as-default.patch
new file mode 100755
index 0000000..c91d573
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0008-Set-watchdog-initialized-action-to-None-as-default.patch
@@ -0,0 +1,25 @@
+From 678d550c1cdcfde9d1f621c0346107a94562fdde Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 21 Jul 2020 18:16:13 +0800
+Subject: [PATCH]  Set watchdog initialized action to None as default
+
+---
+ xyz/openbmc_project/State/Watchdog.interface.yaml | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/xyz/openbmc_project/State/Watchdog.interface.yaml b/xyz/openbmc_project/State/Watchdog.interface.yaml
+index c2e17b5..27c192e 100644
+--- a/xyz/openbmc_project/State/Watchdog.interface.yaml
++++ b/xyz/openbmc_project/State/Watchdog.interface.yaml
+@@ -32,7 +32,7 @@ properties:
+       type: enum[self.Action]
+       description: >
+           The action the watchdog should perform when it expires.
+-      default: 'HardReset'
++      default: 'None'
+     - name: Interval
+       type: uint64
+       description: >
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0009-Add-the-version-ID-parameter-to-software-version-int.patch b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0009-Add-the-version-ID-parameter-to-software-version-int.patch
new file mode 100755
index 0000000..bd14a27
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces/0009-Add-the-version-ID-parameter-to-software-version-int.patch
@@ -0,0 +1,30 @@
+From cb4fd5082b4aebeea5660e70744a3ab936b44b48 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 28 Oct 2020 16:59:37 +0800
+Subject: [PATCH] Add the version ID parameter to software version interface
+
+---
+ xyz/openbmc_project/Software/Version.interface.yaml | 4 ++++
+ 1 file changed, 4 insertions(+)
+ mode change 100644 => 100755 xyz/openbmc_project/Software/Version.interface.yaml
+
+diff --git a/xyz/openbmc_project/Software/Version.interface.yaml b/xyz/openbmc_project/Software/Version.interface.yaml
+old mode 100644
+new mode 100755
+index 345e5b5..0afe922
+--- a/xyz/openbmc_project/Software/Version.interface.yaml
++++ b/xyz/openbmc_project/Software/Version.interface.yaml
+@@ -15,6 +15,10 @@ properties:
+       description: >
+         The purpose of the version.  As in, what can it be used for or
+         applied to?
++    - name: VersionId
++      type: string
++      description: >
++        The version identifier for same version.
+ enumerations:
+     - name: VersionPurpose
+       description: >
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces_git.bbappend
new file mode 100755
index 0000000..7cbee63
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-interfaces_git.bbappend
@@ -0,0 +1,12 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0002-Add-interface-for-caterr-logging.patch \
+            file://0003-Add-SOL-PATTERN-Interface-for-SOL-Processing.patch \
+            file://0004-Add-interface-for-AC-restore-always-on-policy.patch \
+            file://0005-Add-interface-for-setting-specified-service-status.patch \
+            file://0006-Set-watchdog-initialized-flag-true-as-default.patch \
+            file://0007-Add-interface-for-DCMI-power.patch \
+            file://0008-Set-watchdog-initialized-action-to-None-as-default.patch \
+            file://0009-Add-the-version-ID-parameter-to-software-version-int.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-monitor-config.bbappend b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-monitor-config.bbappend
new file mode 100755
index 0000000..49bcc42
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/dbus/phosphor-dbus-monitor-config.bbappend
@@ -0,0 +1 @@
+PHOSPHOR_DBUS_MONITOR_CONFIGS_append = "mct-event-policy-native"
diff --git a/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel.bb b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel.bb
new file mode 100755
index 0000000..ed9f482
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel.bb
@@ -0,0 +1,29 @@
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+FILESEXTRAPATHS_append := "${THISDIR}/files:"
+
+inherit systemd
+inherit obmc-phosphor-systemd
+
+S = "${WORKDIR}/"
+
+SRC_URI = "file://bmc-sel.sh \
+           file://obmc-bmc-sel.service \
+           file://psu-sel.sh \
+           file://psu-sel.service \
+           "
+
+DEPENDS = "systemd"
+RDEPENDS_${PN} = "bash"
+
+SYSTEMD_PACKAGES = "${PN}"
+SYSTEMD_SERVICE_${PN} = "obmc-bmc-sel.service \
+                         psu-sel.service \
+                        "
+
+do_install() {
+    install -d ${D}/usr/sbin
+    install -m 0755 ${S}bmc-sel.sh ${D}/${sbindir}/
+    install -m 0755 ${S}psu-sel.sh ${D}/${sbindir}/
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/bmc-sel.sh b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/bmc-sel.sh
new file mode 100755
index 0000000..6ea7e9a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/bmc-sel.sh
@@ -0,0 +1,33 @@
+#!/bin/bash
+
+echo "Enter Check and generate SEL"
+
+SERVICE="xyz.openbmc_project.Logging.IPMI"
+OBJECT="/xyz/openbmc_project/Logging/IPMI"
+INTERFACE="xyz.openbmc_project.Logging.IPMI"
+METHOD="IpmiSelAdd"
+
+/sbin/fw_printenv | grep 'bmc_update'
+res=$?
+
+if [ $res -eq 0 ]; then
+    echo "Generate a SEL to record the occurrance of BMC FW update"
+    busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/versionchange/BMC_FW_UPDATE" 3 {0x07,0x00,0x00} yes 0x20
+
+    echo "Generate a SEL to record the occurrance of BMC reboot"
+    busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/mgtsubsyshealth/BMC_Reboot" 3 {0x02,0x00,0x00} yes 0x20
+
+    /sbin/fw_setenv bmc_update
+    exit 0;
+fi
+
+/sbin/fw_printenv | grep 'bmc_reboot'
+res=$?
+
+if [ $res -eq 0 ]; then
+    echo "Generate a SEL to record the occurrance of BMC reboot"
+    busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/mgtsubsyshealth/BMC_Reboot" 3 {0x02,0x00,0x00} yes 0x20
+    /sbin/fw_setenv bmc_reboot
+fi
+echo "Exit Check and generate SEL"
+exit 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/obmc-bmc-sel.service b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/obmc-bmc-sel.service
new file mode 100755
index 0000000..537f87b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/obmc-bmc-sel.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=Check and generate BMC SEL
+
+After=obmc-sync-pch-rtc.service
+[Service]
+Restart=no
+ExecStartPre=/bin/bash -c 'while [ ! -e /run/time_sync_done ]; do sleep 1; done'
+ExecStart=/usr/sbin/bmc-sel.sh
+SyslogIdentifier=bmc-sel
+TimeoutSec=infinity
+
+[Install]
+WantedBy={SYSTEMD_DEFAULT_TARGET}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/psu-sel.service b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/psu-sel.service
new file mode 100755
index 0000000..f2caef5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/psu-sel.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=Check and generate PSU SEL
+StopWhenUnneeded=false
+After=obmc-sync-pch-rtc.service
+After=xyz.openbmc_project.psufaultsensor.service
+
+[Service]
+ExecStartPre=/bin/bash -c 'while [ ! -e /run/time_sync_done ]; do sleep 1; done'
+ExecStart=/usr/sbin/psu-sel.sh
+SyslogIdentifier=psu-sel
+
+[Install]
+WantedBy=multi-user.target
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/psu-sel.sh b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/psu-sel.sh
new file mode 100755
index 0000000..8cf5720
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/event/bmc-sel/psu-sel.sh
@@ -0,0 +1,118 @@
+#!/bin/bash
+
+FaultSendLog=0
+WarningLog=0
+Fault=0
+Warning=0
+FaultCount=0
+WarningCount=0
+SERVICE="xyz.openbmc_project.Logging.IPMI"
+OBJECT="/xyz/openbmc_project/Logging/IPMI"
+INTERFACE="xyz.openbmc_project.Logging.IPMI"
+METHOD="IpmiSelAdd"
+
+while true; do
+
+    StatusWord=`i2cget -f -y 3 0x58 0x79 w`
+
+    #check VOUT fault or warning
+    if [ $(((StatusWord & 0x8000) >> 15)) -eq 1 ]; then
+        # read STATUS_VOUT 0x7a , check fault or warning
+        Status_Vout=`i2cget -f -y 3 0x58 0x7a`
+        if [ $((Status_Vout & 0x94)) -gt 0 ]; then
+            Fault=1
+            (( FaultCount++ ))
+        else
+            Warning=1
+            (( WarningCount++ ))
+        fi
+    fi
+
+    # check IOUT/POUT fault or warning
+    if [ $(((StatusWord & 0x4000) >> 14)) -eq 1 ]; then
+        # read STATUS_IOUT 0x7b , check fault or warning
+        Status_Iout=`i2cget -f -y 3 0x58 0x7b`
+        if [ $((Status_Iout & 0xd2)) -gt 0 ]; then
+            Fault=1
+            (( FaultCount++ ))
+        else
+            Warning=1
+            (( WarningCount++ ))
+        fi
+    fi
+    
+    # check VIN fault or warning
+    if [ $(((StatusWord & 0x2000) >> 13)) -eq 1 ]; then
+        # read STATUS_INPUT 0x7c , check fault or warning
+        Status_Input=`i2cget -f -y 3 0x58 0x7c`
+
+        if [ $((Status_Input & 0x94)) -gt 0 ]; then
+            Fault=1
+            (( FaultCount++ ))
+        else
+            Warning=1
+            (( WarningCount++ ))
+        fi
+    fi
+
+    #check FAN fault or warning
+    if [ $(((StatusWord & 0x400) >> 10)) -eq 1 ]; then
+        # read STATUS_FANS_1_2 0x81 , check fault or warning
+        Status_Fan12=`i2cget -f -y 3 0x58 0x81`
+        if [ $((Status_Fan12 & 0xc2)) -gt 0 ]; then
+            Fault=1
+            (( FaultCount++ ))
+        else
+            Warning=1
+            (( WarningCount++ ))
+        fi
+    fi
+
+    #check TEMPERATURE fault or warning
+    if [ $(((StatusWord & 0x4) >> 2)) -eq 1 ]; then
+        # read STATUS_TEMPERATURE 0x7d , check fault or warning
+        Status_Temp=`i2cget -f -y 3 0x58 0x7d`
+        if [ $((Status_Temp & 0x90)) -gt 0 ]; then
+            Fault=1
+            (( FaultCount++ ))
+        else
+            Warning=1
+            (( WarningCount++ ))
+        fi
+    fi
+
+    if [ $Fault == 0 ]; then
+        FaultCount=0
+    fi
+
+    if [ $Warning == 0 ]; then
+        WarningCount=0
+    fi
+
+    if [ $FaultSendLog == 0 ]; then
+        if [ $FaultCount -gt 3 ]; then
+            # send sel log , 01h : Power Supply Failure detected
+            busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/power_supply/PSU_STATUS" 3 {0x01,0x00,0x00} yes 0x20
+            FaultSendLog=1
+            FaultCount=0
+        fi
+    fi
+
+    if [ $WarningLog == 0 ]; then
+        if [ $WarningCount -gt 3 ]; then
+            # send sel log , 02h : Predictive Failure
+            busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/power_supply/PSU_STATUS" 3 {0x02,0x00,0x00} yes 0x20
+            WarningLog=1
+            WarningCount=0
+        fi
+    fi
+
+    if [ $((StatusWord & 0xe404)) == 0 ]; then
+        FaultSendLog=0
+        WarningLog=0
+    fi
+
+    Fault=0
+    Warning=0
+    sleep 1
+done
diff --git a/meta-mct/meta-s5549/recipes-phosphor/event/mct-event-policy-native.bb b/meta-mct/meta-s5549/recipes-phosphor/event/mct-event-policy-native.bb
new file mode 100755
index 0000000..d22422c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/event/mct-event-policy-native.bb
@@ -0,0 +1,14 @@
+SUMMARY = "Event policy for Mingder"
+PR = "r1"
+
+inherit native
+inherit phosphor-dbus-monitor
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+SRC_URI += "file://caterr_event.yaml"
+
+do_install() {
+        install -D ${WORKDIR}/caterr_event.yaml ${D}${config_dir}/caterr_event.yaml
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/event/mct-event-policy/caterr_event.yaml b/meta-mct/meta-s5549/recipes-phosphor/event/mct-event-policy/caterr_event.yaml
new file mode 100755
index 0000000..788c554
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/event/mct-event-policy/caterr_event.yaml
@@ -0,0 +1,50 @@
+- name: processor path
+  description: >
+    'processor error status path'
+  class: group
+  group: path
+  members:
+    - meta: STATE
+      path: /xyz/openbmc_project/sensors/gpio/CATERR
+
+- name: processor status
+  description: >
+    'Monitor processor status'
+  class: group
+  group: property
+  type: string
+  members:
+    - interface: xyz.openbmc_project.Control.Processor
+      meta: PROPERTY
+      property: ProcessorStatus
+    
+- name: watch processor status
+  description: >
+    'Trigger logic if processor status is updated'
+  class: watch
+  watch: property
+  paths: processor path
+  properties: processor status
+  callback: check processor status
+
+- name: check processor status
+  description: >
+    'If the Processor State is CATERR, need add CATERR log.'
+  class: condition
+  condition: count
+  paths: processor path
+  properties: processor status
+  callback: create caterr log
+  countop: '>'
+  countbound: 0
+  op: '=='
+  bound: xyz.openbmc_project.Control.Processor.State.CATERR
+
+- name: create caterr log
+  description: >
+    'Create a CATERR log.'
+  class: callback
+  callback: elog
+  paths: processor path
+  properties: processor status
+  error: xyz::openbmc_project::Control::Processor::Error::CATERR
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0001-remove-the-sesnor-data-scaling.patch b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0001-remove-the-sesnor-data-scaling.patch
new file mode 100755
index 0000000..74f391c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0001-remove-the-sesnor-data-scaling.patch
@@ -0,0 +1,27 @@
+From e97deec3cd69fbdc7dafda88f411c1ba1ae41267 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 8 Aug 2019 10:18:42 +0800
+Subject: [PATCH] remove the sesnor data scaling
+
+---
+ dbus/dbuspassive.cpp | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+ mode change 100644 => 100755 dbus/dbuspassive.cpp
+
+diff --git a/dbus/dbuspassive.cpp b/dbus/dbuspassive.cpp
+old mode 100644
+new mode 100755
+index c199563..4a77ccf
+--- a/dbus/dbuspassive.cpp
++++ b/dbus/dbuspassive.cpp
+@@ -154,8 +154,8 @@ int handleSensorValue(sdbusplus::message::message& msg, DbusPassive* owner)
+                 std::visit(VariantToDoubleVisitor(), valPropMap->second);
+ 
+             value *= std::pow(10, owner->getScale());
+-
+-            scaleSensorReading(owner->getMin(), owner->getMax(), value);
++            
++            //scaleSensorReading(owner->getMin(), owner->getMax(), value);
+ 
+             owner->setValue(value);
+         }
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0002-Fan-speed-control.patch b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0002-Fan-speed-control.patch
new file mode 100755
index 0000000..3cef043
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0002-Fan-speed-control.patch
@@ -0,0 +1,1100 @@
+From 44fab82353b6bf5b8bfec6becefb43cba616fe98 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Tue, 10 Dec 2019 10:13:38 +0800
+Subject: [PATCH] Fan speed control
+
+---
+ Makefile.am                     |   5 +-
+ conf.hpp                        |   4 +
+ dbus/dbusconfiguration.cpp      | 149 ++++++++++++++++-
+ dbus/dbuspassive.cpp            |   4 +-
+ dbus/dbuswrite.cpp              |  33 +++-
+ phosphor-pid-control.service.in |   5 +
+ pid/builder.cpp                 |  16 +-
+ pid/buildjson.cpp               |  48 +++++-
+ pid/ec/fsc.cpp                  |  44 +++++
+ pid/ec/fsc.hpp                  |  40 +++++
+ pid/fancontroller.cpp           |   2 +
+ pid/fsccontroller.cpp           | 361 ++++++++++++++++++++++++++++++++++++++++
+ pid/fsccontroller.hpp           |  60 +++++++
+ pid/zone.cpp                    |   1 +
+ sensors/builder.cpp             |   6 +-
+ 15 files changed, 763 insertions(+), 15 deletions(-)
+ mode change 100644 => 100755 Makefile.am
+ mode change 100644 => 100755 conf.hpp
+ mode change 100644 => 100755 dbus/dbusconfiguration.cpp
+ mode change 100644 => 100755 dbus/dbuswrite.cpp
+ mode change 100644 => 100755 phosphor-pid-control.service.in
+ mode change 100644 => 100755 pid/builder.cpp
+ mode change 100644 => 100755 pid/buildjson.cpp
+ create mode 100755 pid/ec/fsc.cpp
+ create mode 100755 pid/ec/fsc.hpp
+ create mode 100755 pid/fsccontroller.cpp
+ create mode 100755 pid/fsccontroller.hpp
+ mode change 100644 => 100755 pid/zone.cpp
+ mode change 100644 => 100755 sensors/builder.cpp
+
+diff --git a/Makefile.am b/Makefile.am
+old mode 100644
+new mode 100755
+index 45b26d4..2392da9
+--- a/Makefile.am
++++ b/Makefile.am
+@@ -76,8 +76,7 @@ libswampd_la_CXXFLAGS = \
+ 	$(SDBUSPLUS_CFLAGS) \
+ 	$(PHOSPHOR_DBUS_INTERFACES_CFLAGS) \
+ 	$(PHOSPHOR_LOGGING_CFLAGS) \
+-	$(CODE_COVERAGE_CXXFLAGS) \
+-	-flto
++	$(CODE_COVERAGE_CXXFLAGS)
+ 
+ libswampd_la_SOURCES = \
+ 	notimpl/readonly.cpp \
+@@ -97,10 +96,12 @@ libswampd_la_SOURCES = \
+ 	sensors/manager.cpp \
+ 	pid/ec/pid.cpp \
+ 	pid/ec/stepwise.cpp \
++	pid/ec/fsc.cpp \
+ 	pid/fancontroller.cpp \
+ 	pid/thermalcontroller.cpp \
+ 	pid/pidcontroller.cpp \
+ 	pid/stepwisecontroller.cpp \
++	pid/fsccontroller.cpp \
+ 	pid/builder.cpp \
+ 	pid/buildjson.cpp \
+ 	pid/zone.cpp \
+diff --git a/conf.hpp b/conf.hpp
+old mode 100644
+new mode 100755
+index 95bdeaa..03361e0
+--- a/conf.hpp
++++ b/conf.hpp
+@@ -2,6 +2,7 @@
+ 
+ #include "pid/ec/pid.hpp"
+ #include "pid/ec/stepwise.hpp"
++#include "pid/ec/fsc.hpp"
+ 
+ #include <map>
+ #include <string>
+@@ -38,6 +39,7 @@ struct ControllerInfo
+     {
+         ec::pidinfo pidInfo; // pid details
+         ec::StepwiseInfo stepwiseInfo;
++        ec::FscInfo fscInfo;
+     };
+ };
+ 
+@@ -53,6 +55,8 @@ struct ZoneConfig
+ 
+     /* If the sensors are in fail-safe mode, this is the percentage to use. */
+     double failsafePercent;
++    double commandSet;
++    double floorDuty;
+ };
+ 
+ using PIDConf = std::map<std::string, struct ControllerInfo>;
+diff --git a/dbus/dbusconfiguration.cpp b/dbus/dbusconfiguration.cpp
+old mode 100644
+new mode 100755
+index e68c852..b5ae8a3
+--- a/dbus/dbusconfiguration.cpp
++++ b/dbus/dbusconfiguration.cpp
+@@ -45,6 +45,8 @@ constexpr const char* pidZoneConfigurationInterface =
+     "xyz.openbmc_project.Configuration.Pid.Zone";
+ constexpr const char* stepwiseConfigurationInterface =
+     "xyz.openbmc_project.Configuration.Stepwise";
++constexpr const char* fscConfigurationInterface =
++    "xyz.openbmc_project.Configuration.Fsc";
+ constexpr const char* thermalControlIface =
+     "xyz.openbmc_project.Control.ThermalMode";
+ constexpr const char* sensorInterface = "xyz.openbmc_project.Sensor.Value";
+@@ -265,9 +267,10 @@ void createMatches(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer)
+     // this is a list because the matches can't be moved
+     static std::list<sdbusplus::bus::match::match> matches;
+ 
+-    const std::array<std::string, 4> interfaces = {
++    const std::array<std::string, 5> interfaces = {
+         thermalControlIface, pidConfigurationInterface,
+-        pidZoneConfigurationInterface, stepwiseConfigurationInterface};
++        pidZoneConfigurationInterface, stepwiseConfigurationInterface,
++        fscConfigurationInterface};
+ 
+     // this list only needs to be created once
+     if (!matches.empty())
+@@ -405,10 +408,11 @@ bool init(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer)
+                             "/xyz/openbmc_project/object_mapper",
+                             "xyz.openbmc_project.ObjectMapper", "GetSubTree");
+     mapper.append("/", 0,
+-                  std::array<const char*, 6>{objectManagerInterface,
++                  std::array<const char*, 7>{objectManagerInterface,
+                                              pidConfigurationInterface,
+                                              pidZoneConfigurationInterface,
+                                              stepwiseConfigurationInterface,
++                                             fscConfigurationInterface,
+                                              sensorInterface, pwmInterface});
+     std::unordered_map<
+         std::string, std::unordered_map<std::string, std::vector<std::string>>>
+@@ -447,7 +451,8 @@ bool init(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer)
+                 }
+                 if (interface == pidConfigurationInterface ||
+                     interface == pidZoneConfigurationInterface ||
+-                    interface == stepwiseConfigurationInterface)
++                    interface == stepwiseConfigurationInterface ||
++                    interface == fscConfigurationInterface)
+                 {
+                     owner.first = true;
+                 }
+@@ -495,6 +500,8 @@ bool init(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer)
+                 pathPair.second.find(pidZoneConfigurationInterface) !=
+                     pathPair.second.end() ||
+                 pathPair.second.find(stepwiseConfigurationInterface) !=
++                    pathPair.second.end() ||
++                pathPair.second.find(fscConfigurationInterface) !=
+                     pathPair.second.end())
+             {
+                 configurations.emplace(pathPair);
+@@ -576,6 +583,10 @@ bool init(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer)
+                                                   zone.at("MinThermalOutput"));
+             details.failsafePercent = std::visit(VariantToDoubleVisitor(),
+                                                  zone.at("FailSafePercent"));
++            details.commandSet = std::visit(VariantToDoubleVisitor(),
++                                                 zone.at("CommandSet"));
++            details.floorDuty = std::visit(VariantToDoubleVisitor(),
++                                                 zone.at("FloorDuty"));
+         }
+         auto findBase = configuration.second.find(pidConfigurationInterface);
+         if (findBase != configuration.second.end())
+@@ -812,6 +823,136 @@ bool init(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer)
+                 }
+             }
+         }
++        auto findFsc =
++            configuration.second.find(fscConfigurationInterface);
++        if (findFsc != configuration.second.end())
++        {
++            const auto& base = findFsc->second;
++            const std::vector<std::string>& zones =
++                std::get<std::vector<std::string>>(base.at("Zones"));
++            for (const std::string& zone : zones)
++            {
++                size_t index = getZoneIndex(zone, foundZones);
++                conf::PIDConf& conf = zoneConfig[index];
++
++                std::vector<std::string> inputs;
++                std::vector<std::string> sensorNames =
++                std::get<std::vector<std::string>>(base.at("Inputs"));
++
++                bool sensorFound = false;
++
++                for (const std::string& sensorName : sensorNames)
++                {
++
++                    std::string name = sensorName;
++                    // replace spaces with underscores to be legal on dbus
++                    std::replace(name.begin(), name.end(), ' ', '_');
++                    std::vector<std::pair<std::string, std::string>>
++                        sensorPathIfacefsc;
++
++                    if (!findSensors(sensors, name, sensorPathIfacefsc))
++                    {
++                        break;
++                    }
++
++                    for (const auto& sensorPathIfacePair : sensorPathIfacefsc)
++                    {
++                        size_t idx =
++                            sensorPathIfacePair.first.find_last_of("/") + 1;
++                        std::string shortName =
++                            sensorPathIfacePair.first.substr(idx);
++
++                        inputs.push_back(shortName);
++                        auto& config = sensorConfig[shortName];
++                        config.readPath = sensorPathIfacePair.first;
++                        config.type = "temp";
++                        // todo: maybe un-hardcode this if we run into slower
++                        // timeouts with sensors
++
++                        config.timeout = 0;
++                        sensorFound = true;
++                    }
++                }
++
++                if (!sensorFound)
++                {
++                    continue;
++                }
++
++                struct conf::ControllerInfo& info =
++                    conf[std::get<std::string>(base.at("Name"))];
++                info.inputs = std::move(inputs);
++
++                info.type = "fsc";
++                info.fscInfo.ts = 1.0; // currently unused
++                info.fscInfo.positiveHysteresis = 0.0;
++                info.fscInfo.negativeHysteresis = 0.0;
++
++                std::string subtype = std::get<std::string>(base.at("Class"));
++
++                //info.fscInfo.isCeiling = (subtype == "Ceiling");
++                auto findSPH = base.find("SetPointH");
++                auto findSPL = base.find("SetPointL");
++                if (findSPH != base.end())
++                {
++                    info.fscInfo.setPointH = std::visit(
++                        VariantToDoubleVisitor(), findSPH->second);
++                }
++                if (findSPL != base.end())
++                {
++                    info.fscInfo.setPointL = std::visit(
++                        VariantToDoubleVisitor(), findSPL->second);
++                }
++
++                info.fscInfo.outLimMax =
++                    std::visit(VariantToDoubleVisitor(), base.at("OutLimitMax"));
++
++                auto findPosHyst = base.find("PositiveHysteresis");
++                auto findNegHyst = base.find("NegativeHysteresis");
++                if (findPosHyst != base.end())
++                {
++                    info.fscInfo.positiveHysteresis = std::visit(
++                        VariantToDoubleVisitor(), findPosHyst->second);
++                }
++                if (findNegHyst != base.end())
++                {
++                    info.fscInfo.negativeHysteresis = std::visit(
++                        VariantToDoubleVisitor(), findNegHyst->second);
++                }
++                std::vector<double> readings =
++                    std::get<std::vector<double>>(base.at("Reading"));
++                if (readings.size() > ec::maxFscPoints)
++                {
++                    throw std::invalid_argument("Too many fsc points.");
++                }
++                if (readings.empty())
++                {
++                    throw std::invalid_argument(
++                        "Must have one fsc point.");
++                }
++                std::copy(readings.begin(), readings.end(),
++                          info.stepwiseInfo.reading);
++                if (readings.size() < ec::maxFscPoints)
++                {
++                    info.fscInfo.reading[readings.size()] =
++                        std::numeric_limits<double>::quiet_NaN();
++                }
++                std::vector<double> outputs =
++                    std::get<std::vector<double>>(base.at("Output"));
++                if (readings.size() != outputs.size())
++                {
++                    throw std::invalid_argument(
++                        "Outputs size must match readings");
++                }
++                std::copy(outputs.begin(), outputs.end(),
++                          info.fscInfo.output);
++                if (outputs.size() < ec::maxFscPoints)
++                {
++                    info.fscInfo.output[outputs.size()] =
++                        std::numeric_limits<double>::quiet_NaN();
++                }
++            }
++        }
+     }
+     if constexpr (DEBUG)
+     {
+diff --git a/dbus/dbuspassive.cpp b/dbus/dbuspassive.cpp
+index 4a77ccf..9693694 100755
+--- a/dbus/dbuspassive.cpp
++++ b/dbus/dbuspassive.cpp
+@@ -173,14 +173,14 @@ int handleSensorValue(sdbusplus::message::message& msg, DbusPassive* owner)
+         bool asserted = false;
+         if (criticalAlarmLow != msgData.end())
+         {
+-            asserted = std::get<bool>(criticalAlarmLow->second);
++            //asserted = std::get<bool>(criticalAlarmLow->second);
+         }
+ 
+         // checking both as in theory you could de-assert one threshold and
+         // assert the other at the same moment
+         if (!asserted && criticalAlarmHigh != msgData.end())
+         {
+-            asserted = std::get<bool>(criticalAlarmHigh->second);
++            //asserted = std::get<bool>(criticalAlarmHigh->second);
+         }
+         owner->setFailed(asserted);
+     }
+diff --git a/dbus/dbuswrite.cpp b/dbus/dbuswrite.cpp
+old mode 100644
+new mode 100755
+index 502b988..3ca7c41
+--- a/dbus/dbuswrite.cpp
++++ b/dbus/dbuswrite.cpp
+@@ -55,6 +55,10 @@ void DbusWritePercent::write(double value)
+     double offset = range * value;
+     double ovalue = offset + minimum;
+ 
++    double Value;
++    std::string::size_type pos;
++    std::string id, object;
++
+     if (oldValue == static_cast<int64_t>(ovalue))
+     {
+         return;
+@@ -76,7 +80,34 @@ void DbusWritePercent::write(double value)
+                         entry("WHAT=%s", ex.what()));
+     }
+ 
+-    oldValue = static_cast<int64_t>(ovalue);
++    // check fan sensor value
++    pos = path.find("Pwm_");
++    id = path.substr(pos+4);
++    object = "/xyz/openbmc_project/sensors/fan_pwm/Pwm_" + id;
++    const char *Object = object.c_str();
++
++    auto bus = sdbusplus::bus::new_default();
++    auto method = bus.new_method_call("xyz.openbmc_project.FanSensor", Object,
++                                            "org.freedesktop.DBus.Properties", "Get");
++    method.append("xyz.openbmc_project.Sensor.Value", "Value");
++    sdbusplus::message::variant<double> valuetmp;
++
++    try
++    {
++        auto reply = bus.call(method);
++        reply.read(valuetmp);
++    }
++    catch (const sdbusplus::exception::SdBusError& e)
++    {
++        std::cout << "fail to read " << object << " value " << std::endl;
++    }
++
++    Value = std::get<double>(valuetmp);
++
++    if (((int)(Value+0.5)) == (int)(value*100))
++    {
++        oldValue = static_cast<int64_t>(ovalue);
++    }
+     return;
+ }
+ 
+diff --git a/phosphor-pid-control.service.in b/phosphor-pid-control.service.in
+old mode 100644
+new mode 100755
+index aa29377..0c171cd
+--- a/phosphor-pid-control.service.in
++++ b/phosphor-pid-control.service.in
+@@ -1,5 +1,10 @@
+ [Unit]
+ Description=Phosphor-Pid-Control Margin-based Fan Control Daemon
++After=xyz.openbmc_project.EntityManager.service
++After=xyz.openbmc_project.ObjectMapper.service
++After=xyz.openbmc_project.fansensor.service
++After=xyz.openbmc_project.hwmontempsensor.service
++After=disable-sw2.service
+ 
+ [Service]
+ Restart=always
+diff --git a/pid/builder.cpp b/pid/builder.cpp
+old mode 100644
+new mode 100755
+index 1fbfbd4..97773d3
+--- a/pid/builder.cpp
++++ b/pid/builder.cpp
+@@ -21,6 +21,7 @@
+ #include "pid/fancontroller.hpp"
+ #include "pid/stepwisecontroller.hpp"
+ #include "pid/thermalcontroller.hpp"
++#include "pid/fsccontroller.hpp"
+ 
+ #include <iostream>
+ #include <memory>
+@@ -119,13 +120,24 @@ std::unordered_map<int64_t, std::unique_ptr<PIDZone>>
+                     zone.get(), name, inputs, info->stepwiseInfo);
+                 zone->addThermalPID(std::move(stepwise));
+             }
++            else if (info->type == "fsc")
++            {
++                for (const auto& i : info->inputs)
++                {
++                    inputs.push_back(i);
++                    zone->addThermalInput(i);
++                }
++                auto fsc = FscController::createFscController(
++                    zone.get(), name, inputs, info->fscInfo);
++                zone->addThermalPID(std::move(fsc));
++            }
+ 
+-            std::cerr << "inputs: ";
++            /*std::cerr << "inputs: ";
+             for (const auto& i : inputs)
+             {
+                 std::cerr << i << ", ";
+             }
+-            std::cerr << "\n";
++            std::cerr << "\n";*/
+         }
+ 
+         zone->emit_object_added();
+diff --git a/pid/buildjson.cpp b/pid/buildjson.cpp
+old mode 100644
+new mode 100755
+index 5e90c47..b392e2f
+--- a/pid/buildjson.cpp
++++ b/pid/buildjson.cpp
+@@ -51,7 +51,7 @@ void from_json(const json& j, conf::ControllerInfo& c)
+         p.at("negativeHysteresis").get_to(negativeHysteresisValue);
+     }
+ 
+-    if (c.type != "stepwise")
++    if ((c.type != "stepwise") && (c.type != "fsc"))
+     {
+         p.at("samplePeriod").get_to(c.pidInfo.ts);
+         p.at("proportionalCoeff").get_to(c.pidInfo.proportionalCoeff);
+@@ -68,6 +68,50 @@ void from_json(const json& j, conf::ControllerInfo& c)
+         c.pidInfo.positiveHysteresis = positiveHysteresisValue;
+         c.pidInfo.negativeHysteresis = negativeHysteresisValue;
+     }
++    else if (c.type == "fsc")
++    {
++        p.at("samplePeriod").get_to(c.fscInfo.ts);
++        p.at("setPointH").get_to(c.fscInfo.setPointH);
++        p.at("setPointL").get_to(c.fscInfo.setPointL);
++        p.at("outLim_max").get_to(c.fscInfo.outLimMax);
++
++        for (size_t i = 0; i < ec::maxFscPoints; i++)
++        {
++            c.fscInfo.reading[i] =
++            std::numeric_limits<double>::quiet_NaN();
++            c.fscInfo.output[i] = std::numeric_limits<double>::quiet_NaN();
++        }
++
++        auto reading = p.find("reading");
++        if (reading != p.end())
++        {
++            auto r = p.at("reading");
++            for (size_t i = 0; i < ec::maxFscPoints; i++)
++            {
++                auto n = r.find(std::to_string(i));
++                if (n != r.end())
++                {
++                    r.at(std::to_string(i)).get_to(c.fscInfo.reading[i]);
++                }
++            }
++        }
++
++        auto output = p.find("output");
++        if (output != p.end())
++        {
++            auto o = p.at("output");
++            for (size_t i = 0; i < ec::maxFscPoints; i++)
++            {
++                auto n = o.find(std::to_string(i));
++                if (n != o.end())
++                {
++                    o.at(std::to_string(i)).get_to(c.fscInfo.output[i]);
++                }
++            }
++        }
++        c.stepwiseInfo.positiveHysteresis = positiveHysteresisValue;
++        c.stepwiseInfo.negativeHysteresis = negativeHysteresisValue;
++    }
+     else
+     {
+         p.at("samplePeriod").get_to(c.stepwiseInfo.ts);
+@@ -135,6 +179,8 @@ std::pair<std::map<int64_t, conf::PIDConf>,
+         id = zone["id"];
+         thisZoneConfig.minThermalOutput = zone["minThermalOutput"];
+         thisZoneConfig.failsafePercent = zone["failsafePercent"];
++        thisZoneConfig.commandSet = zone["commandSet"];
++        thisZoneConfig.floorDuty = zone["floorDuty"];
+ 
+         auto pids = zone["pids"];
+         for (const auto& pid : pids)
+diff --git a/pid/ec/fsc.cpp b/pid/ec/fsc.cpp
+new file mode 100755
+index 0000000..345b20e
+--- /dev/null
++++ b/pid/ec/fsc.cpp
+@@ -0,0 +1,44 @@
++/*
++// Copyright (c) 2019
++//
++// Licensed under the Apache License, Version 2.0 (the "License");
++// you may not use this file except in compliance with the License.
++// You may obtain a copy of the License at
++//
++//      http://www.apache.org/licenses/LICENSE-2.0
++//
++// Unless required by applicable law or agreed to in writing, software
++// distributed under the License is distributed on an "AS IS" BASIS,
++// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++// See the License for the specific language governing permissions and
++// limitations under the License.
++*/
++
++#include "fsc.hpp"
++
++#include <cmath>
++#include <cstddef>
++#include <limits>
++
++namespace ec
++{
++double fsc(const ec::FscInfo& info, double input)
++{
++    double value = info.output[0];
++
++    for (size_t ii = 1; ii < ec::maxFscPoints; ii++)
++    {
++        if (std::isnan(info.reading[ii]))
++        {
++            break;
++        }
++        if (info.reading[ii] > input)
++        {
++            break;
++        }
++        value = info.output[ii];
++    }
++
++    return value;
++}
++} // namespace ec
+diff --git a/pid/ec/fsc.hpp b/pid/ec/fsc.hpp
+new file mode 100755
+index 0000000..7f687b2
+--- /dev/null
++++ b/pid/ec/fsc.hpp
+@@ -0,0 +1,40 @@
++/*
++// Copyright (c) 2019
++//
++// Licensed under the Apache License, Version 2.0 (the "License");
++// you may not use this file except in compliance with the License.
++// You may obtain a copy of the License at
++//
++//      http://www.apache.org/licenses/LICENSE-2.0
++//
++// Unless required by applicable law or agreed to in writing, software
++// distributed under the License is distributed on an "AS IS" BASIS,
++// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++// See the License for the specific language governing permissions and
++// limitations under the License.
++*/
++
++#pragma once
++
++#include <cstddef>
++#include <vector>
++
++namespace ec
++{
++constexpr size_t maxFscPoints = 5;
++
++struct FscInfo
++{
++    double ts; // sample time in seconds
++    double reading[maxFscPoints];
++    double output[maxFscPoints];
++    double positiveHysteresis;
++    double negativeHysteresis;
++    double setPointH;
++    double setPointL;
++    double outLimMax;
++};
++
++double fsc(const ec::FscInfo& info, double value);
++
++}
+diff --git a/pid/fancontroller.cpp b/pid/fancontroller.cpp
+index dd26d16..d43d753 100644
+--- a/pid/fancontroller.cpp
++++ b/pid/fancontroller.cpp
+@@ -116,6 +116,7 @@ void FanController::outputProc(double value)
+     double percent = value;
+ 
+     /* If doing tuning, don't go into failsafe mode. */
++#if 0
+     if (!tuningEnabled)
+     {
+         if (_owner->getFailSafeMode())
+@@ -127,6 +128,7 @@ void FanController::outputProc(double value)
+             }
+         }
+     }
++#endif
+ 
+     // value and kFanFailSafeDutyCycle are 10 for 10% so let's fix that.
+     percent /= 100;
+diff --git a/pid/fsccontroller.cpp b/pid/fsccontroller.cpp
+new file mode 100755
+index 0000000..3ed8468
+--- /dev/null
++++ b/pid/fsccontroller.cpp
+@@ -0,0 +1,361 @@
++/*
++// Copyright (c) 2019
++//
++// Licensed under the Apache License, Version 2.0 (the "License");
++// you may not use this file except in compliance with the License.
++// You may obtain a copy of the License at
++//
++//      http://www.apache.org/licenses/LICENSE-2.0
++//
++// Unless required by applicable law or agreed to in writing, software
++// distributed under the License is distributed on an "AS IS" BASIS,
++// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++// See the License for the specific language governing permissions and
++// limitations under the License.
++*/
++
++#include "fsccontroller.hpp"
++
++#include "ec/fsc.hpp"
++#include "errors/exception.hpp"
++#include "util.hpp"
++#include "zone.hpp"
++
++#include <algorithm>
++#include <chrono>
++#include <cmath>
++#include <iostream>
++#include <map>
++#include <memory>
++#include <thread>
++#include <vector>
++
++#include <sdbusplus/asio/object_server.hpp>
++#include <filesystem>
++
++extern std::map<int64_t, struct conf::ZoneConfig> zoneDetailsConfig;
++#define FAN_OBJECTPATH "/xyz/openbmc_project/sensors/fan_tach/SYS_FAN_"
++namespace fs = std::filesystem;
++
++#define FSC_SERVICE "xyz.openbmc_project.EntityManager"
++#define PID_OBJECTPATH "/xyz/openbmc_project/inventory/system/board/s5549_Baseboard/"
++#define PID_INTERFACE "xyz.openbmc_project.Configuration.Fsc"
++#define PROPERTY_INTERFACE "org.freedesktop.DBus.Properties"
++
++static void setProperty(sdbusplus::bus::bus& bus, const std::string& path,
++                 const std::string& property, const double value)
++{
++    auto method = bus.new_method_call(FSC_SERVICE, path.c_str(),
++                                      PROPERTY_INTERFACE, "Set");
++    method.append(PID_INTERFACE, property, sdbusplus::message::variant<double>(value));
++    bus.call_noreply(method);
++
++    return;
++}
++
++void FscController::process(void)
++{
++    // Get input value
++    double input = inputProc();
++
++    ec::FscInfo info = get_fsc_info();
++
++    double output;
++
++    double Value , fanfail=0, value=0;
++    std::string id, object, PATH, str;
++    char Object[100], Tcontrol[100], path[100];
++    size_t pos;
++    auto bus = sdbusplus::bus::new_default();
++    std::fstream file;
++
++    // dynamically detected CPU Thigh and Tlow value
++    pos = _id.find("FSC_CPU");
++    if(pos != std::string::npos)
++    {
++        if(std::isnan(tcontrol))
++        {
++            str = _id.substr(pos+7);
++            memset(path,0,sizeof(path));
++            snprintf(path,sizeof(path),"/sys/bus/peci/devices/peci-0/0-3%s/peci-cputemp.%s/hwmon",str.c_str(),str.c_str());
++
++            file.open(path,std::ios::in);
++            if(!file)
++            {
++                std::cout << path << " path doesn't exisit " << "\n";
++            }
++            else
++            {
++                file.close();
++
++                fs::path p1(path);
++                for( fs::directory_iterator it = fs::directory_iterator(p1);
++                        it != fs::directory_iterator(); ++ it )
++                {
++                    PATH = it->path();
++                }
++
++                memset(path,0,sizeof(path));
++                snprintf(path,sizeof(path),"%s%s",PATH.c_str(),"/temp3_input");
++
++                file.open(path,std::ios::in);
++                if(!file)
++                {
++                    std::cout << " can't open " << path << " file to read Tcontrol value" << "\n";
++                }
++                else
++                {
++                    file.read(Tcontrol,sizeof(Tcontrol));
++                    value = strtol(Tcontrol,NULL,10);
++                    file.close();
++
++                    memset(Object,0,sizeof(Object));
++                    snprintf(Object,sizeof(Object),"%s%s",PID_OBJECTPATH,_id.c_str());
++
++                    // Make sure the Tcontrol reading is between 50 and 150
++                    if((value >= 50000) && (value <= 150000))
++                    {
++                        //calculate CPU Thigh(Tcontrol -5) and Tlow(Tcontrol -10) and update property
++                        info.setPointH = (value-5000)/1000;
++                        info.setPointL = (value-10000)/1000;
++                        setProperty(bus,Object,"SetPointH",info.setPointH);
++                        setProperty(bus,Object,"SetPointL",info.setPointL);
++                        tcontrol = value;
++                        //std::cerr << "update " << _id.c_str() << " setPointH(" << info.setPointH << ") and setPointL(" << info.setPointL << ")" << '\n';
++                    }
++                }
++            }
++        }
++    }
++
++    // check FAN sensors reading
++    for (size_t z = 1; z <= 5; z++)
++    {
++        memset(Object,0,sizeof(Object));
++        snprintf(Object,sizeof(Object),"%s%d",FAN_OBJECTPATH,z);
++
++        auto method = bus.new_method_call("xyz.openbmc_project.FanSensor", Object,
++                                        "org.freedesktop.DBus.Properties", "Get");
++        method.append("xyz.openbmc_project.Sensor.Value", "Value");
++        sdbusplus::message::variant<double> valuetmp;
++
++        try
++        {
++            auto reply = bus.call(method);
++            reply.read(valuetmp);
++        }
++        catch (const sdbusplus::exception::SdBusError& e)
++        {
++            std::cout << "fail to read " << object << " value " << std::endl;
++        }
++
++        Value = std::get<double>(valuetmp);
++        if (Value == 0)
++        {
++            fanfail++;
++        }
++    }
++
++    if (fanfail != 0)
++    {
++        if (maxDuty != 100)
++        {
++            maxDuty = 100;
++        }
++    }
++    else
++    {
++        if (maxDuty != info.outLimMax)
++        {
++            maxDuty = info.outLimMax;
++        }
++    }
++
++    if (std::isnan(lastOutput))
++    {
++        lastOutput = floorOutput;
++        output = lastOutput;
++        delayTime = 0;
++    }
++    else
++    {
++        if (zoneDetailsConfig[1].commandSet == 1)
++        {
++            if (floorOutput != zoneDetailsConfig[1].floorDuty)
++            {
++                floorOutput = zoneDetailsConfig[1].floorDuty;
++                lastOutput = floorOutput;
++            }
++        }
++        else
++        {
++            if (lastOutput <= floorOutput)
++            {
++                lastOutput = floorOutput;
++            }
++        }
++
++        output = lastOutput;
++        if (std::isnan(updateDir))
++        {
++            if (input > info.setPointH)
++            {
++                updateDir = 1;
++                output = lastOutput + (input - info.setPointH)*2;
++            }
++            lastInput = input;
++            delayTime = 0;
++        }
++        else
++        {
++            if ((updateDir == 1) && (delayTime >= 5))
++            {
++                if (input > info.setPointH)
++                {
++                    output = lastOutput + (input - info.setPointH)*2;
++                    if (output >= maxDuty)
++                    {
++                        output = maxDuty;
++                    }
++                    delayTime = 0;
++                }
++                else if (input < info.setPointL)
++                {
++                    updateDir = 2;
++                    output = lastOutput - (info.setPointL - input)*2;
++                    delayTime = 0;
++                }
++                lastInput = input;
++            }
++            else if ((updateDir == 2) && (delayTime >= 30))
++            {
++                if (input < info.setPointL)
++                {
++                    output = lastOutput - (info.setPointL - input)*2;
++                    if (output <= floorOutput)
++                    {
++                        output = floorOutput;
++                    }
++                    delayTime = 0;
++                }
++                else if (input > info.setPointH)
++                {
++                    updateDir = 1;
++                    output = lastOutput + (input - info.setPointH)*2;
++                    delayTime = 0;
++                }
++                lastInput = input;
++            }
++        }
++    }
++
++    if (delayTime > 100)
++    {
++        delayTime = 0;
++    }
++    else
++    {
++        delayTime += 1;
++    }
++
++    lastOutput = output;
++
++    // Output new value
++    outputProc(output);
++
++    return;
++}
++
++std::unique_ptr<Controller> FscController::createFscController(
++    ZoneInterface* owner, const std::string& id,
++    const std::vector<std::string>& inputs, const ec::FscInfo& initial)
++{
++    // FscController requires at least 1 input
++    if (inputs.empty())
++    {
++        throw ControllerBuildException("Fsc controller missing inputs");
++        return nullptr;
++    }
++
++    auto thermal = std::make_unique<FscController>(id, inputs, owner);
++
++    ec::FscInfo& info = thermal->get_fsc_info();
++
++    info = initial;
++
++    return thermal;
++}
++
++double FscController::inputProc(void)
++{
++    double value = std::numeric_limits<double>::lowest();
++    double sensorvalue[10];
++    size_t i=0;
++    double sFloorDuty;
++    ec::FscInfo info = get_fsc_info();
++    auto bus = sdbusplus::bus::new_default();
++
++    for (const auto& in : _inputs)
++    {
++        sensorvalue[i]=_owner->getCachedValue(in);
++        i++;
++    }
++
++    if (zoneDetailsConfig[1].commandSet == 0)
++    {
++        sFloorDuty = ec::fsc(info, sensorvalue[0]);
++
++        if (std::isnan(floorOutput))
++        {
++            floorOutput = sFloorDuty;
++            lastOutput = sFloorDuty;
++        }
++        else
++        {
++            if ((floorOutput-sFloorDuty) < 0)
++            {
++                if (lastOutput <= sFloorDuty)
++                {
++                    lastOutput = sFloorDuty;
++                }
++                floorOutput = sFloorDuty;
++            }
++            else if ((floorOutput-sFloorDuty) > 0)
++            {
++                if (lastOutput <= floorOutput)
++                {
++                    lastOutput = sFloorDuty;
++                }
++                floorOutput = sFloorDuty;
++            }
++        }
++    }
++    else
++    {
++        if (std::isnan(floorOutput))
++        {
++            floorOutput = zoneDetailsConfig[1].floorDuty;
++        }
++    }
++
++    if ( i > 1)
++    {
++        for (size_t j=1; j<i; j++)
++        {
++            value = std::max(value, sensorvalue[j]);
++        }
++    }
++    else
++    {
++        value = sensorvalue[0];
++    }
++
++    return value;
++}
++
++void FscController::outputProc(double value)
++{
++        _owner->addSetPoint(value);
++
++    return;
++}
+diff --git a/pid/fsccontroller.hpp b/pid/fsccontroller.hpp
+new file mode 100755
+index 0000000..f67cb0b
+--- /dev/null
++++ b/pid/fsccontroller.hpp
+@@ -0,0 +1,60 @@
++#pragma once
++
++#include "controller.hpp"
++#include "ec/fsc.hpp"
++#include "fan.hpp"
++
++#include <limits>
++#include <memory>
++#include <vector>
++
++class ZoneInterface;
++
++class FscController : public Controller
++{
++  public:
++    static std::unique_ptr<Controller>
++        createFscController(ZoneInterface* owner, const std::string& id,
++                                 const std::vector<std::string>& inputs,
++                                 const ec::FscInfo& initial);
++
++    FscController(const std::string& id,
++                       const std::vector<std::string>& inputs,
++                       ZoneInterface* owner) :
++        Controller(),
++        _owner(owner), _id(id), _inputs(inputs)
++    {
++    }
++
++    double inputProc(void) override;
++
++    void outputProc(double value) override;
++
++    void process(void) override;
++
++    std::string getID(void) override
++    {
++        return _id;
++    }
++
++    ec::FscInfo& get_fsc_info(void)
++    {
++        return _fsc_info;
++    }
++
++  protected:
++    ZoneInterface* _owner;
++
++  private:
++    // parameters
++    ec::FscInfo _fsc_info;
++    std::string _id;
++    std::vector<std::string> _inputs;
++    double lastInput = std::numeric_limits<double>::quiet_NaN();
++    double lastOutput = std::numeric_limits<double>::quiet_NaN();
++    double floorOutput = std::numeric_limits<double>::quiet_NaN();
++    double delayTime = std::numeric_limits<double>::quiet_NaN();
++    double updateDir = std::numeric_limits<double>::quiet_NaN();
++    double maxDuty = std::numeric_limits<double>::quiet_NaN();
++    double tcontrol = std::numeric_limits<double>::quiet_NaN();
++};
+diff --git a/pid/zone.cpp b/pid/zone.cpp
+old mode 100644
+new mode 100755
+index 6a63671..f27096a
+--- a/pid/zone.cpp
++++ b/pid/zone.cpp
+@@ -23,6 +23,7 @@
+ #include "pid/fancontroller.hpp"
+ #include "pid/stepwisecontroller.hpp"
+ #include "pid/thermalcontroller.hpp"
++#include "pid/fsccontroller.hpp"
+ #include "pid/tuning.hpp"
+ 
+ #include <algorithm>
+diff --git a/sensors/builder.cpp b/sensors/builder.cpp
+old mode 100644
+new mode 100755
+index 4da1cf2..879255f
+--- a/sensors/builder.cpp
++++ b/sensors/builder.cpp
+@@ -53,8 +53,8 @@ SensorManager
+         std::string name = it.first;
+         const struct conf::SensorConfig* info = &it.second;
+ 
+-        std::cerr << "Sensor: " << name << " " << info->type << " ";
+-        std::cerr << info->readPath << " " << info->writePath << "\n";
++        //std::cerr << "Sensor: " << name << " " << info->type << " ";
++        //std::cerr << info->readPath << " " << info->writePath << "\n";
+ 
+         IOInterfaceType rtype = getReadInterfaceType(info->readPath);
+         IOInterfaceType wtype = getWriteInterfaceType(info->writePath);
+@@ -153,7 +153,7 @@ SensorManager
+         {
+             // These sensors are read-only, but only for this application
+             // which only writes to fan sensors.
+-            std::cerr << info->type << " readPath: " << info->readPath << "\n";
++            //std::cerr << info->type << " readPath: " << info->readPath << "\n";
+ 
+             if (IOInterfaceType::EXTERNAL == rtype)
+             {
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0003-fix-Tjmax-change-don-t-take-effect-issue.patch b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0003-fix-Tjmax-change-don-t-take-effect-issue.patch
new file mode 100755
index 0000000..424fd62
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0003-fix-Tjmax-change-don-t-take-effect-issue.patch
@@ -0,0 +1,25 @@
+From e71c50359eb846650e4437ebca874e6ad0b67ebe Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 21 Jul 2020 18:35:45 +0800
+Subject: [PATCH 1/1] fix Tjmax change don't take effect issue
+
+---
+ pid/fsccontroller.cpp | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/pid/fsccontroller.cpp b/pid/fsccontroller.cpp
+index 3ed8468..9a92bb5 100755
+--- a/pid/fsccontroller.cpp
++++ b/pid/fsccontroller.cpp
+@@ -118,6 +118,8 @@ void FscController::process(void)
+                         //calculate CPU Thigh(Tcontrol -5) and Tlow(Tcontrol -10) and update property
+                         info.setPointH = (value-5000)/1000;
+                         info.setPointL = (value-10000)/1000;
++                        _fsc_info.setPointH = info.setPointH;
++                        _fsc_info.setPointL = info.setPointL; 
+                         setProperty(bus,Object,"SetPointH",info.setPointH);
+                         setProperty(bus,Object,"SetPointL",info.setPointL);
+                         tcontrol = value;
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0004-Fix-the-pid-coredump-issue.patch b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0004-Fix-the-pid-coredump-issue.patch
new file mode 100755
index 0000000..84db15c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0004-Fix-the-pid-coredump-issue.patch
@@ -0,0 +1,201 @@
+From 624ad75be22e0afc066e08b91d6bac3df98bc28d Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 18 Aug 2020 09:50:20 +0800
+Subject: [PATCH] Fix the pid coredump issue
+
+Create flag for enable or disable pid loop
+Add patch "catch the execption during buildSensors" by manual.
+Add patch "dbusconfiguration: Filter InterfacesAdded Match" by manual.
+---
+ dbus/dbusconfiguration.cpp | 43 ++++++++++++++++++++++++++++++++++++++++---
+ main.cpp                   | 31 ++++++++++++++++++++++++++++++-
+ pid/pidloop.cpp            |  6 ++++++
+ util.hpp                   |  2 +-
+ 4 files changed, 77 insertions(+), 5 deletions(-)
+ mode change 100644 => 100755 main.cpp
+ mode change 100644 => 100755 pid/pidloop.cpp
+
+diff --git a/dbus/dbusconfiguration.cpp b/dbus/dbusconfiguration.cpp
+index b5ae8a3..7bb2018 100755
+--- a/dbus/dbusconfiguration.cpp
++++ b/dbus/dbusconfiguration.cpp
+@@ -36,6 +36,7 @@ static constexpr bool DEBUG = false; // enable to print found configuration
+ extern std::map<std::string, struct conf::SensorConfig> sensorConfig;
+ extern std::map<int64_t, conf::PIDConf> zoneConfig;
+ extern std::map<int64_t, struct conf::ZoneConfig> zoneDetailsConfig;
++extern bool pidControlLoopEnable;
+ 
+ constexpr const char* pidConfigurationInterface =
+     "xyz.openbmc_project.Configuration.Pid";
+@@ -52,6 +53,9 @@ constexpr const char* thermalControlIface =
+ constexpr const char* sensorInterface = "xyz.openbmc_project.Sensor.Value";
+ constexpr const char* pwmInterface = "xyz.openbmc_project.Control.FanPwm";
+ 
++using Association = std::tuple<std::string, std::string, std::string>;
++using Associations = std::vector<Association>;
++
+ namespace thresholds
+ {
+ constexpr const char* warningInterface =
+@@ -235,13 +239,46 @@ std::vector<std::string> getSelectedProfiles(sdbusplus::bus::bus& bus)
+     return ret;
+ }
+ 
+-int eventHandler(sd_bus_message*, void* context, sd_bus_error*)
++int eventHandler(sd_bus_message* m, void* context, sd_bus_error*)
+ {
+ 
+-    if (context == nullptr)
++    if (context == nullptr || m == nullptr)
+     {
+         throw std::runtime_error("Invalid match");
+     }
++
++    // we skip associations because the mapper populates these, not the sensors
++    const std::array<const char*, 1> skipList = {
++        "xyz.openbmc_project.Association"};
++
++    sdbusplus::message::message message(m);
++    if (std::string(message.get_member()) == "InterfacesAdded")
++    {
++        sdbusplus::message::object_path path;
++        std::unordered_map<
++            std::string,
++            std::unordered_map<std::string, std::variant<Associations, bool>>>
++            data;
++
++        message.read(path, data);
++
++        for (const char* skip : skipList)
++        {
++            auto find = data.find(skip);
++            if (find != data.end())
++            {
++                data.erase(find);
++                if (data.empty())
++                {
++                    return 1;
++                }
++            }
++        }
++    }
++
++    //Disable running process for pid loop.
++    pidControlLoopEnable = false;
++
+     boost::asio::steady_timer* timer =
+         static_cast<boost::asio::steady_timer*>(context);
+ 
+@@ -256,7 +293,7 @@ int eventHandler(sd_bus_message*, void* context, sd_bus_error*)
+         }
+ 
+         std::cout << "New configuration detected, reloading\n.";
+-        restartControlLoops();
++        tryRestartControlLoops();
+     });
+ 
+     return 1;
+diff --git a/main.cpp b/main.cpp
+old mode 100644
+new mode 100755
+index be0691d..078e229
+--- a/main.cpp
++++ b/main.cpp
+@@ -69,6 +69,8 @@ static sdbusplus::asio::connection
+ static sdbusplus::asio::connection
+     passiveBus(io, sdbusplus::bus::new_system().release());
+ 
++bool pidControlLoopEnable;
++
+ void restartControlLoops()
+ {
+     static SensorManager mgmr;
+@@ -119,10 +121,37 @@ void restartControlLoops()
+     {
+         auto& timer = timers.emplace_back(io);
+         std::cerr << "pushing zone " << i.first << "\n";
++        pidControlLoopEnable = true;
+         pidControlLoop(i.second.get(), timer);
+     }
+ }
+ 
++void tryRestartControlLoops()
++{
++    int count = 0;
++    for (count = 0; count <= 5; count++)
++    {
++        try
++        {
++            restartControlLoops();
++            break;
++        }
++        catch (const std::exception& e)
++        {
++            std::cerr << count
++                      << " Failed during restartControlLoops, try again: "
++                      << e.what() << "\n";
++            if (count >= 5)
++            {
++                throw std::runtime_error(e.what());
++            }
++        }
++        std::this_thread::sleep_for(std::chrono::seconds(10));
++    }
++
++    return;
++}
++
+ int main(int argc, char* argv[])
+ {
+     loggingPath = "";
+@@ -155,7 +184,7 @@ int main(int argc, char* argv[])
+      * it.
+      */
+ 
+-    restartControlLoops();
++    tryRestartControlLoops();
+ 
+     io.run();
+     return 0;
+diff --git a/pid/pidloop.cpp b/pid/pidloop.cpp
+old mode 100644
+new mode 100755
+index 56bf8bd..61bf6b8
+--- a/pid/pidloop.cpp
++++ b/pid/pidloop.cpp
+@@ -27,6 +27,8 @@
+ #include <thread>
+ #include <vector>
+ 
++extern bool pidControlLoopEnable;
++
+ static void processThermals(PIDZone* zone)
+ {
+     // Get the latest margins.
+@@ -62,6 +64,10 @@ void pidControlLoop(PIDZone* zone, boost::asio::steady_timer& timer, bool first,
+                 return; // timer being canceled, stop loop
+             }
+ 
++            if(!pidControlLoopEnable)
++            {
++                return;
++            }
+             /*
+              * This should sleep on the conditional wait for the listen thread
+              * to tell us it's in sync.  But then we also need a timeout option
+diff --git a/util.hpp b/util.hpp
+index e40b61f..f3ef5fa 100644
+--- a/util.hpp
++++ b/util.hpp
+@@ -30,7 +30,7 @@ IOInterfaceType getWriteInterfaceType(const std::string& path);
+ 
+ IOInterfaceType getReadInterfaceType(const std::string& path);
+ 
+-void restartControlLoops(void);
++void tryRestartControlLoops();
+ 
+ /*
+  * Given a configuration structure, fill out the information we use within the
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0005-fix-typo-of-fan-control.patch b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0005-fix-typo-of-fan-control.patch
new file mode 100755
index 0000000..4cab2d0
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0005-fix-typo-of-fan-control.patch
@@ -0,0 +1,53 @@
+From e865d7105d2aa2669e9cb9652094f00262d0a90c Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Tue, 18 Aug 2020 18:35:46 +0800
+Subject: [PATCH] fix typo of fan control
+
+---
+ dbus/dbusconfiguration.cpp | 10 +++++++---
+ pid/buildjson.cpp          |  4 ++--
+ 2 files changed, 9 insertions(+), 5 deletions(-)
+
+diff --git a/dbus/dbusconfiguration.cpp b/dbus/dbusconfiguration.cpp
+index 7bb2018..97b98f2 100755
+--- a/dbus/dbusconfiguration.cpp
++++ b/dbus/dbusconfiguration.cpp
+@@ -941,8 +941,12 @@ bool init(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer)
+                         VariantToDoubleVisitor(), findSPL->second);
+                 }
+ 
+-                info.fscInfo.outLimMax =
+-                    std::visit(VariantToDoubleVisitor(), base.at("OutLimitMax"));
++                auto findOutLimitMax = base.find("OutLimitMax");
++                if (findOutLimitMax != base.end())
++                {
++                    info.fscInfo.outLimMax = std::visit(
++                        VariantToDoubleVisitor(), findOutLimitMax->second);
++                }
+ 
+                 auto findPosHyst = base.find("PositiveHysteresis");
+                 auto findNegHyst = base.find("NegativeHysteresis");
+@@ -968,7 +972,7 @@ bool init(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer)
+                         "Must have one fsc point.");
+                 }
+                 std::copy(readings.begin(), readings.end(),
+-                          info.stepwiseInfo.reading);
++                          info.fscInfo.reading);
+                 if (readings.size() < ec::maxFscPoints)
+                 {
+                     info.fscInfo.reading[readings.size()] =
+diff --git a/pid/buildjson.cpp b/pid/buildjson.cpp
+index b392e2f..9aac20c 100755
+--- a/pid/buildjson.cpp
++++ b/pid/buildjson.cpp
+@@ -109,8 +109,8 @@ void from_json(const json& j, conf::ControllerInfo& c)
+                 }
+             }
+         }
+-        c.stepwiseInfo.positiveHysteresis = positiveHysteresisValue;
+-        c.stepwiseInfo.negativeHysteresis = negativeHysteresisValue;
++        c.fscInfo.positiveHysteresis = positiveHysteresisValue;
++        c.fscInfo.negativeHysteresis = negativeHysteresisValue;
+     }
+     else
+     {
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0006-fixed-increase-and-decrease-refresh-time.patch b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0006-fixed-increase-and-decrease-refresh-time.patch
new file mode 100755
index 0000000..ffb4e02
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/0006-fixed-increase-and-decrease-refresh-time.patch
@@ -0,0 +1,107 @@
+From 1204b69b8d10ac7bb8637a7dfb987f7d3fc363b1 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Mon, 14 Sep 2020 14:24:02 +0800
+Subject: [PATCH] fixed increase and decrease refresh time
+
+---
+ pid/fsccontroller.cpp | 26 +++++++++++++-------------
+ pid/fsccontroller.hpp |  2 +-
+ 2 files changed, 14 insertions(+), 14 deletions(-)
+
+diff --git a/pid/fsccontroller.cpp b/pid/fsccontroller.cpp
+index 9a92bb5..0fb0087 100755
+--- a/pid/fsccontroller.cpp
++++ b/pid/fsccontroller.cpp
+@@ -177,7 +177,7 @@ void FscController::process(void)
+     {
+         lastOutput = floorOutput;
+         output = lastOutput;
+-        delayTime = 0;
++        count = 0;
+     }
+     else
+     {
+@@ -206,58 +206,58 @@ void FscController::process(void)
+                 output = lastOutput + (input - info.setPointH)*2;
+             }
+             lastInput = input;
+-            delayTime = 0;
++            count = 0;
+         }
+         else
+         {
+-            if ((updateDir == 1) && (delayTime >= 5))
++            if (updateDir == 1)
+             {
+-                if (input > info.setPointH)
++                if ((input > info.setPointH) && (count >= 2))
+                 {
+                     output = lastOutput + (input - info.setPointH)*2;
+                     if (output >= maxDuty)
+                     {
+                         output = maxDuty;
+                     }
+-                    delayTime = 0;
++                    count = 0;
+                 }
+                 else if (input < info.setPointL)
+                 {
+                     updateDir = 2;
+                     output = lastOutput - (info.setPointL - input)*2;
+-                    delayTime = 0;
++                    count = 0;
+                 }
+                 lastInput = input;
+             }
+-            else if ((updateDir == 2) && (delayTime >= 30))
++            else if (updateDir == 2)
+             {
+-                if (input < info.setPointL)
++                if ((input < info.setPointL) && (count >= 14))
+                 {
+                     output = lastOutput - (info.setPointL - input)*2;
+                     if (output <= floorOutput)
+                     {
+                         output = floorOutput;
+                     }
+-                    delayTime = 0;
++                    count = 0;
+                 }
+                 else if (input > info.setPointH)
+                 {
+                     updateDir = 1;
+                     output = lastOutput + (input - info.setPointH)*2;
+-                    delayTime = 0;
++                    count = 0;
+                 }
+                 lastInput = input;
+             }
+         }
+     }
+ 
+-    if (delayTime > 100)
++    if (count > 100)
+     {
+-        delayTime = 0;
++        count = 0;
+     }
+     else
+     {
+-        delayTime += 1;
++        count += 1;
+     }
+ 
+     lastOutput = output;
+diff --git a/pid/fsccontroller.hpp b/pid/fsccontroller.hpp
+index f67cb0b..a06c88c 100755
+--- a/pid/fsccontroller.hpp
++++ b/pid/fsccontroller.hpp
+@@ -53,7 +53,7 @@ class FscController : public Controller
+     double lastInput = std::numeric_limits<double>::quiet_NaN();
+     double lastOutput = std::numeric_limits<double>::quiet_NaN();
+     double floorOutput = std::numeric_limits<double>::quiet_NaN();
+-    double delayTime = std::numeric_limits<double>::quiet_NaN();
++    double count = std::numeric_limits<double>::quiet_NaN();
+     double updateDir = std::numeric_limits<double>::quiet_NaN();
+     double maxDuty = std::numeric_limits<double>::quiet_NaN();
+     double tcontrol = std::numeric_limits<double>::quiet_NaN();
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/phosphor-pid-control.service b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/phosphor-pid-control.service
new file mode 100755
index 0000000..115bf1b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control/phosphor-pid-control.service
@@ -0,0 +1,17 @@
+[Unit]
+Description=Phosphor-Pid-Control Margin-based Fan Control Daemon
+Requires=multi-user.target
+Wants=obmc-power-on@0.target
+After=obmc-power-on@0.target
+Conflicts=obmc-host-stop@0.target
+Conflicts=obmc-chassis-poweroff@0.target
+
+[Service]
+Restart=always
+ExecStart={bindir}/swampd
+RestartSec=5
+StartLimitInterval=0
+Type=simple
+
+[Install]
+WantedBy=obmc-chassis-poweron@0.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control_%.bbappend b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control_%.bbappend
new file mode 100755
index 0000000..689ab79
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control_%.bbappend
@@ -0,0 +1,12 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+inherit obmc-phosphor-systemd
+SYSTEMD_SERVICE_${PN} = "phosphor-pid-control.service"
+EXTRA_OECONF = "--enable-configure-dbus=yes"
+
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI = "git://github.com/openbmc/phosphor-pid-control.git"
+SRCREV = "a7ec8350d17b70153cebe666d3fbe88bddd02a1a"
+
+FILES_${PN} = "${bindir}/swampd ${bindir}/setsensor"
diff --git a/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control_git.bbappend
new file mode 100755
index 0000000..2a52321
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/fans/phosphor-pid-control_git.bbappend
@@ -0,0 +1,10 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-remove-the-sesnor-data-scaling.patch \
+            file://0002-Fan-speed-control.patch \
+            file://0003-fix-Tjmax-change-don-t-take-effect-issue.patch \
+            file://0004-Fix-the-pid-coredump-issue.patch \
+            file://0005-fix-typo-of-fan-control.patch \
+            file://0006-fixed-increase-and-decrease-refresh-time.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/Makefile.am b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/Makefile.am
new file mode 100755
index 0000000..532fca3
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/Makefile.am
@@ -0,0 +1,7 @@
+sbin_PROGRAMS = gpio-initial
+
+gpio_initial_SOURCES = gpio-initial.cpp
+gpio_initial_LDFLAGS = $(SYSTEMD_LIBS) \
+                       -lgpiod \
+                       -lobmcmisc
+gpio_initial_CFLAGS = $(SYSTEMD_CFLAGS)
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/bootstrap.sh b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/bootstrap.sh
new file mode 100755
index 0000000..bb06e73
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/bootstrap.sh
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+AUTOCONF_FILES="Makefile.in aclocal.m4 ar-lib autom4te.cache compile \
+        config.guess config.h.in config.sub configure depcomp install-sh \
+        ltmain.sh missing *libtool test-driver"
+
+case $1 in
+    clean)
+        test -f Makefile && make maintainer-clean
+        test -f linux/bt-bmc.h && rm -rf linux/bt-bmc.h
+        test -d linux && find linux -type d -empty | xargs -r rm -rf
+        for file in ${AUTOCONF_FILES}; do
+            find -name "$file" | xargs -r rm -rf
+        done
+        exit 0
+        ;;
+esac
+
+autoreconf -i
+echo 'Run "./configure ${CONFIGURE_FLAGS} && make"'
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/configure.ac b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/configure.ac
new file mode 100755
index 0000000..208d2ef
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/configure.ac
@@ -0,0 +1,33 @@
+# Initialization
+AC_PREREQ([2.69])
+AC_INIT([gpio-initial], [1.0])
+AC_LANG([C++])
+AC_CONFIG_HEADERS([config.h])
+AM_INIT_AUTOMAKE([subdir-objects -Wall -Werror foreign dist-xz])
+AM_SILENT_RULES([yes])
+
+# Checks for programs.
+AC_PROG_CC
+AM_PROG_AR
+AC_PROG_INSTALL
+AC_PROG_MAKE_SET
+
+# Checks for libraries.
+PKG_CHECK_MODULES([SYSTEMD], [libsystemd >= 221])
+AX_CXX_COMPILE_STDCXX_17([noext])
+
+# Checks for header files.
+AC_CHECK_HEADER(systemd/sd-bus.h, ,[AC_MSG_ERROR([Could not find systemd/sd-bus.h...systemd developement package required])])
+
+# Checks for typedefs, structures, and compiler characteristics.
+AX_APPEND_COMPILE_FLAGS([-Wall -Werror], [CFLAGS])
+
+# Checks for library functions.
+LT_INIT # Removes 'unrecognized options: --with-libtool-sysroot'
+
+# Create configured output
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
+
+
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial-config.json b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial-config.json
new file mode 100755
index 0000000..2d77b43
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial-config.json
@@ -0,0 +1,56 @@
+[
+    {
+        "LineName": "BMC_EUP_LOT6",
+        "Direction": "Output",
+        "Value":0,
+        "PIN":"GPIOA2"
+    },
+    {
+        "LineName": "PHY_RST",
+        "Direction": "Output",
+        "Value":1,
+        "PIN":"GPIOD5"
+    },
+    {
+        "LineName": "CLR_CMOS",
+        "Direction": "Output",
+        "Value":1,
+        "PIN":"GPIOD7"
+    },
+    {
+        "LineName": "PCH_NMI",
+        "Direction": "Output",
+        "Value":0,
+        "PIN":"GPIOF0"
+    },
+    {
+        "LineName": "BAT_MON",
+        "Direction": "Output",
+        "Value":0,
+        "PIN":"GPIOG4"
+    },
+    {
+        "LineName": "BIOS_SPI_SW",
+        "Direction": "Output",
+        "Value":0,
+        "PIN":"GPIOG7"
+    },
+    {
+        "LineName": "SYS_FAULT1",
+        "Direction": "Output",
+        "Value":1,
+        "PIN":"GPIOH3"
+    },
+    {
+        "LineName": "SYS_FAULT2",
+        "Direction": "Output",
+        "Value":1,
+        "PIN":"GPIOH6"
+    },
+    {
+        "LineName": "FLASH_SEC_OVRD",
+        "Direction": "Output",
+        "Value":1,
+        "PIN":"GPIOQ6"
+    }
+]
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.cpp b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.cpp
new file mode 100755
index 0000000..41f430a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.cpp
@@ -0,0 +1,88 @@
+#include "gpio-initial.hpp"
+
+static constexpr bool DEBUG = false;
+
+namespace GPIO{
+
+void setInput(std::string lineName)
+{
+    int value;
+    struct gpiod_line *line = nullptr;;
+
+    line = gpiod_line_find(lineName.c_str());
+    if (gpiod_line_request_input(line,"set-inptut") < 0)
+    {
+        std::cerr << "Error request line\n";
+    }
+    gpiod_line_release(line);
+}
+
+void setOutput(std::string lineName,int setValue)
+{
+    int value;
+    struct gpiod_line *line = nullptr;;
+
+    line = gpiod_line_find(lineName.c_str());
+    if (gpiod_line_request_output(line,"set-output",setValue) < 0)
+    {
+        std::cerr << "Error request line\n";
+    }
+    gpiod_line_release(line);
+}
+}
+
+int main(int argc, char *argv[])
+{
+
+    std::ifstream gpioInitialConfig(gpioInitialConfigPath);
+
+    if(!gpioInitialConfig)
+    {
+        std::cerr << "GPIO initial config file not found. PATH:" << gpioInitialConfigPath << std::endl;
+        return 0;
+    }
+
+    auto gpioConfig = nlohmann::json::parse(gpioInitialConfig, nullptr, false);
+
+    if(gpioConfig.is_discarded())
+    {
+        std::cerr << "Syntax error in " << gpioInitialConfigPath << "\n";
+        return 0;
+    }
+
+    for (auto& object : gpioConfig)
+    {
+        if constexpr (DEBUG){
+            std::cerr << LINE_NAME << " : " << object[LINE_NAME] << "\n";
+            std::cerr << DIRECTION << " : " << object[DIRECTION] << "\n";
+            std::cerr << VALUE << " : " << object[VALUE] << "\n";
+        }
+
+        if(object[LINE_NAME].is_null() || object[DIRECTION].is_null() || object[VALUE].is_null())
+        {
+            continue;
+        }
+        if(object[DIRECTION]=="Input")
+        {
+            GPIO::setInput(object[LINE_NAME]);
+        }
+        if(object[DIRECTION]=="Output")
+        {
+            GPIO::setOutput(object[LINE_NAME],object[VALUE]);
+        }
+        // TODO: GPIOs should be used as interrupt feature
+    }
+
+    uint32_t registerBuffer = 0;
+    if (read_register(0x1E7800E0,&registerBuffer) < 0)
+    {
+        std::cerr<<"Failed to read register \n";
+    }
+    else
+    {
+        registerBuffer |= (1UL << 24);
+        write_register(0x1E7800E0, registerBuffer);
+    }
+
+    return 0;
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.hpp b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.hpp
new file mode 100755
index 0000000..6ba958c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.hpp
@@ -0,0 +1,27 @@
+#pragma once
+
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <gpiod.h>
+#include <nlohmann/json.hpp>
+#include <openbmc/libmisc.h>
+
+constexpr auto LINE_NAME = "LineName";
+constexpr auto DIRECTION = "Direction";
+constexpr auto VALUE = "Value";
+
+const static std::string gpioInitialConfigPath = "/usr/share/gpio-initial/gpio-initial-config.json";
+
+/** @brief Set the specificed pin direction to input.
+ *
+ *  @param[in] lineName - line name from GPIO in DTS.
+ */
+void setInput(std::string lineName);
+
+/** @brief Set the specificed pin direction to output.
+ *
+ *  @param[in] lineName - line name from GPIO in DTS.
+ *  @param[in] setValue - Setting output voltage.
+ */
+void setOutput(std::string lineName,int setValue);
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.service b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.service
new file mode 100755
index 0000000..4d61960
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.service
@@ -0,0 +1,10 @@
+[Unit]
+Description=Initial GPIO Settings
+
+[Service]
+ExecStart=/usr/sbin/gpio-initial
+Type=simple
+SyslogIdentifier=gpio-initial
+
+[Install]
+WantedBy=sysinit.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.sh b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.sh
new file mode 100755
index 0000000..c4d1f1e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/files/gpio-initial.sh
@@ -0,0 +1,247 @@
+#! /bin/sh
+
+# GROUP A-Z
+GPIO_A0=0
+GPIO_A1=1
+GPIO_A2=2
+GPIO_A3=3
+GPIO_A4=4
+GPIO_A5=5
+GPIO_A6=6
+GPIO_A7=7
+GPIO_B0=8
+GPIO_B1=9
+GPIO_B2=10
+GPIO_B3=11
+GPIO_B4=12
+GPIO_B5=13
+GPIO_B6=14
+GPIO_B7=15
+GPIO_C0=16
+GPIO_C1=17
+GPIO_C2=18
+GPIO_C3=19
+GPIO_C4=20
+GPIO_C5=21
+GPIO_C6=22
+GPIO_C7=23
+GPIO_D0=24
+GPIO_D1=25
+GPIO_D2=26
+GPIO_D3=27
+GPIO_D4=28
+GPIO_D5=29
+GPIO_D6=30
+GPIO_D7=31
+GPIO_E0=32
+GPIO_E1=33
+GPIO_E2=34
+GPIO_E3=35
+GPIO_E4=36
+GPIO_E5=37
+GPIO_E6=38
+GPIO_E7=39
+GPIO_F0=40
+GPIO_F1=41
+GPIO_F2=42
+GPIO_F3=43
+GPIO_F4=44
+GPIO_F5=45
+GPIO_F6=46
+GPIO_F7=47
+GPIO_G0=48
+GPIO_G1=49
+GPIO_G2=50
+GPIO_G3=51
+GPIO_G4=52
+GPIO_G5=53
+GPIO_G6=54
+GPIO_G7=55
+GPIO_H0=56
+GPIO_H1=57
+GPIO_H2=58
+GPIO_H3=59
+GPIO_H4=60
+GPIO_H5=61
+GPIO_H6=62
+GPIO_H7=63
+GPIO_I0=64
+GPIO_I1=65
+GPIO_I2=66
+GPIO_I3=67
+GPIO_I4=68
+GPIO_I5=69
+GPIO_I6=70
+GPIO_I7=71
+GPIO_J0=72
+GPIO_J1=73
+GPIO_J2=74
+GPIO_J3=75
+GPIO_J4=76
+GPIO_J5=77
+GPIO_J6=78
+GPIO_J7=79
+GPIO_K0=80
+GPIO_K1=81
+GPIO_K2=82
+GPIO_K3=83
+GPIO_K4=84
+GPIO_K5=85
+GPIO_K6=86
+GPIO_K7=87
+GPIO_L0=88
+GPIO_L1=89
+GPIO_L2=90
+GPIO_L3=91
+GPIO_L4=92
+GPIO_L5=93
+GPIO_L6=94
+GPIO_L7=95
+GPIO_M0=96
+GPIO_M1=97
+GPIO_M2=98
+GPIO_M3=99
+GPIO_M4=100
+GPIO_M5=101
+GPIO_M6=102
+GPIO_M7=103
+GPIO_N0=104
+GPIO_N1=105
+GPIO_N2=106
+GPIO_N3=107
+GPIO_N4=108
+GPIO_N5=109
+GPIO_N6=110
+GPIO_N7=111
+GPIO_O0=112
+GPIO_O1=113
+GPIO_O2=114
+GPIO_O3=115
+GPIO_O4=116
+GPIO_O5=117
+GPIO_O6=118
+GPIO_O7=119
+GPIO_P0=120
+GPIO_P1=121
+GPIO_P2=122
+GPIO_P3=123
+GPIO_P4=124
+GPIO_P5=125
+GPIO_P6=126
+GPIO_P7=127
+GPIO_Q0=128
+GPIO_Q1=129
+GPIO_Q2=130
+GPIO_Q3=131
+GPIO_Q4=132
+GPIO_Q5=133
+GPIO_Q6=134
+GPIO_Q7=135
+GPIO_R0=136
+GPIO_R1=137
+GPIO_R2=138
+GPIO_R3=139
+GPIO_R4=140
+GPIO_R5=141
+GPIO_R6=142
+GPIO_R7=143
+GPIO_S0=144
+GPIO_S1=145
+GPIO_S2=146
+GPIO_S3=147
+GPIO_S4=148
+GPIO_S5=149
+GPIO_S6=150
+GPIO_S7=151
+GPIO_T0=152
+GPIO_T1=153
+GPIO_T2=154
+GPIO_T3=155
+GPIO_T4=156
+GPIO_T5=157
+GPIO_T6=158
+GPIO_T7=159
+GPIO_U0=160
+GPIO_U1=161
+GPIO_U2=162
+GPIO_U3=163
+GPIO_U4=164
+GPIO_U5=165
+GPIO_U6=166
+GPIO_U7=167
+GPIO_V0=168
+GPIO_V1=169
+GPIO_V2=170
+GPIO_V3=171
+GPIO_V4=172
+GPIO_V5=173
+GPIO_V6=174
+GPIO_V7=175
+GPIO_W0=176
+GPIO_W1=177
+GPIO_W2=178
+GPIO_W3=179
+GPIO_W4=180
+GPIO_W5=181
+GPIO_W6=182
+GPIO_W7=183
+GPIO_X0=184
+GPIO_X1=185
+GPIO_X2=186
+GPIO_X3=187
+GPIO_X4=188
+GPIO_X5=189
+GPIO_X6=190
+GPIO_X7=191
+GPIO_Y0=192
+GPIO_Y1=193
+GPIO_Y2=194
+GPIO_Y3=195
+GPIO_Y4=196
+GPIO_Y5=197
+GPIO_Y6=198
+GPIO_Y7=199
+GPIO_Z0=200
+GPIO_Z1=201
+GPIO_Z2=202
+GPIO_Z3=203
+GPIO_Z4=204
+GPIO_Z5=205
+GPIO_Z6=206
+GPIO_Z7=207
+
+# GROUP AA
+GPIO_AA0=208
+GPIO_AA1=209
+GPIO_AA2=210
+GPIO_AA3=211
+GPIO_AA4=212
+GPIO_AA5=213
+GPIO_AA6=214
+GPIO_AA7=215
+
+# GROUP AB
+GPIO_AB0=216
+GPIO_AB1=217
+GPIO_AB2=218
+GPIO_AB3=219
+
+# GROUP AC
+GPIO_AC0=220
+GPIO_AC1=221
+GPIO_AC2=222
+GPIO_AC3=223
+GPIO_AC4=224
+GPIO_AC5=225
+GPIO_AC6=226
+GPIO_AC7=227
+
+set -x
+
+# TO set pin using sysfs
+GPIO_EXPORT_PATH="/sys/class/gpio/export"
+GPIO_BASE=`cat /sys/bus/platform/devices/1e780000.gpio/gpio/*/base`
+
+echo $[$GPIO_BASE+$GPIO_F2] > $GPIO_EXPORT_PATH
+
+exit 0
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio-init/gpio-initial.bb b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/gpio-initial.bb
new file mode 100755
index 0000000..dde1d00
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio-init/gpio-initial.bb
@@ -0,0 +1,48 @@
+SUMMARY = "GPIO initialize"
+DESCRIPTION = "Implement the initialization for GPIO"
+PR = "r1"
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+FILESEXTRAPATHS_append := "${THISDIR}/files:"
+
+inherit autotools pkgconfig
+inherit systemd
+inherit obmc-phosphor-systemd
+
+S = "${WORKDIR}/"
+
+SRC_URI = "file://bootstrap.sh \
+           file://configure.ac \
+           file://Makefile.am \
+           file://gpio-initial.cpp \
+           file://gpio-initial.hpp \
+           file://gpio-initial-config.json \
+           file://gpio-initial.sh \
+           file://gpio-initial.service \
+           "
+
+DEPENDS = "systemd"
+DEPENDS += "autoconf-archive-native"
+DEPENDS += "libgpiod"
+DEPENDS += "nlohmann-json"
+DEPENDS += "obmc-libmisc"
+
+
+RDEPENDS_${PN} = "bash"
+RDEPENDS_${PN} = "libgpiod"
+RDEPENDS_${PN} += "obmc-libmisc"
+
+SYSTEMD_PACKAGES = "${PN}"
+SYSTEMD_SERVICE_${PN} = "gpio-initial.service"
+
+FILES_${PN} += "${datadir}/gpio-initial/*"
+
+do_install() {
+    autotools_do_install
+
+    install -d ${D}/usr/sbin
+    install -d ${D}/usr/share/gpio-initial
+    install -m 0755 ${S}gpio-initial.sh ${D}/${sbindir}/
+    install -m 0755 ${S}gpio-initial-config.json ${D}/${datadir}/gpio-initial/
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor.bb b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor.bb
new file mode 100755
index 0000000..e96b141
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor.bb
@@ -0,0 +1,37 @@
+DESCRIPTION = "Button Monitor"
+PR = "r1"
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+inherit obmc-phosphor-systemd
+inherit cmake
+inherit systemd
+
+
+S = "${WORKDIR}/"
+SRC_URI = "file://power-button-monitor.cpp \
+           file://power-button-monitor.hpp \
+           file://power-button-monitor.service \
+           file://reset-button-monitor.cpp \
+           file://reset-button-monitor.hpp \
+           file://reset-button-monitor.service \
+           file://util.hpp \
+           file://CMakeLists.txt \
+           "
+
+DEPENDS += "boost"
+DEPENDS += "systemd"
+
+RDEPENDS_${PN} += "libsystemd"
+RDEPENDS_${PN} += "bash"
+
+SYSTEMD_SERVICE_${PN} += "power-button-monitor.service"
+SYSTEMD_SERVICE_${PN} += "reset-button-monitor.service"
+
+
+do_install() {
+    install -d ${D}/usr/sbin
+    install -m 0755 power-button-monitor ${D}/${sbindir}/
+    install -m 0755 reset-button-monitor ${D}/${sbindir}/
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/CMakeLists.txt b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/CMakeLists.txt
new file mode 100755
index 0000000..a8cfc07
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/CMakeLists.txt
@@ -0,0 +1,34 @@
+cmake_minimum_required (VERSION 3.5 FATAL_ERROR)
+
+set (CMAKE_CXX_STANDARD 17)
+set (CMAKE_CXX_STANDARD_REQUIRED ON)
+
+
+project(power-button-monitor)
+
+add_executable(power-button-monitor power-button-monitor.cpp)
+target_link_libraries (power-button-monitor -lsystemd)
+
+project(reset-button-monitor)
+
+add_executable(reset-button-monitor reset-button-monitor.cpp)
+target_link_libraries (reset-button-monitor -lsystemd)
+
+
+# Strip binary for release builds
+if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
+    if (NOT CMAKE_BUILD_TYPE MATCHES Debug)
+        string (REGEX REPLACE "ar$" "gcc-ar" CMAKE_AR ${CMAKE_AR})
+        string (
+            REGEX
+            REPLACE "ranlib$" "gcc-ranlib" CMAKE_RANLIB ${CMAKE_RANLIB}
+        )
+        set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -flto -fno-fat-lto-objects")
+
+        set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} \
+        -fvisibility=hidden \
+        -fvisibility-inlines-hidden \
+        -Wl,--exclude-libs,ALL")
+    endif (NOT CMAKE_BUILD_TYPE MATCHES Debug)
+endif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.cpp b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.cpp
new file mode 100755
index 0000000..7c60ed7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.cpp
@@ -0,0 +1,130 @@
+#include "power-button-monitor.hpp"
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <iostream>
+#include <string>
+
+#define _POSIX_C_SOURCE 200809L
+#define POLL_TIMEOUT 1
+#define MAX_BUFFER 64
+
+#define DEBUG 0
+
+int main(int argc, char *argv[])
+{
+    struct pollfd fdset[2];
+    char *buf[MAX_BUFFER];
+    int gpioFd, timeout, rc;
+    int nfds = 2;
+    bool initWorkaround = true;
+
+    Button button;
+    button.gpioBase = findGpioBase();
+    button.gpioE2 = button.gpioBase + 34;
+
+    if(DEBUG){
+        std::cerr << "Power Button monitor start\n";
+    }
+
+    while(1){
+        gpioFd = gpioFdOpen(button.gpioE2);
+
+        if(gpioFd < 0){
+            setGpioExport(button.gpioE2);
+            usleep(500000);
+            continue;
+        }
+
+        timeout = POLL_TIMEOUT;
+
+        while (1) {
+            memset((void*)fdset, 0, sizeof(fdset));
+
+            fdset[0].fd = STDIN_FILENO;
+            fdset[0].events = POLLIN;
+            fdset[1].fd = gpioFd;
+            fdset[1].events = POLLPRI;
+
+            rc = poll(fdset, nfds, timeout);
+
+            if (rc < 0) {
+                if(DEBUG){
+                    std::cerr << "Power button Poll failed\n";
+                }
+                break;
+            }
+
+            if(button.buttonStatus && buttonTimeout(button.wait,POLL_TIMEOUT)){
+                //Power waiting timer
+                button.wait = getCurrentTimeWithMs();
+                buttonWaiting(&button);
+            }
+
+            if(fdset[1].revents & POLLPRI) {
+                lseek(fdset[1].fd, 0, SEEK_SET);
+                read(fdset[1].fd, buf, MAX_BUFFER);
+
+                // To avoid first times input file's value
+                if(initWorkaround){
+                    initWorkaround=false;
+                    continue;
+                }
+
+                button.buttonValue = ((unsigned int) buf[0])%2;
+
+                if(button.buttonValue){
+                    buttonRelease(&button);
+                }
+                else{
+                    buttonPress(&button);
+                }
+            }
+
+            fflush(stdout);
+            usleep(50000);
+        }
+
+        close(gpioFd);
+    }
+
+    return 0;
+}
+
+
+void buttonPress(Button *button)
+{
+    if(DEBUG){
+        std::cerr << "Power Button Press\n";
+    }
+
+    if(!button->buttonStatus){
+        button->start = getCurrentTimeWithMs();
+        button->wait = getCurrentTimeWithMs();
+
+        // To set Power button press and release by software
+        system("/usr/bin/gpioset `gpiofind PWRBTN_OUT`=0");
+
+        button->buttonStatus = true;
+    }
+}
+
+void buttonRelease(Button *button)
+{
+    if(DEBUG){
+        std::cerr << "Power Button Release\n";
+    }
+
+    if(button->buttonStatus){
+        button->buttonStatus = false;
+        system("/usr/bin/gpioset `gpiofind PWRBTN_OUT`=1");
+    }
+}
+
+void buttonWaiting(Button *button)
+{
+    if(DEBUG){
+        std::cerr << "Power button poll waiting...\n";
+    }
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.hpp b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.hpp
new file mode 100755
index 0000000..b31a08a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.hpp
@@ -0,0 +1,33 @@
+#pragma once
+
+#include "util.hpp"
+
+typedef struct{
+    unsigned int buttonValue = 0;
+    unsigned int gpioBase = 0;
+    unsigned int gpioE2 = 0;
+    unsigned int counter = 0;
+    bool buttonStatus = false;
+    double start, finish, wait, duration;
+}Button;
+
+/*
+ * @desc Button's action when button press
+ * @param button - intput button with parameter
+ * @return null
+ */
+void buttonPress(Button *button);
+
+/*
+ * @desc Button's action when button release
+ * @param button - intput button with parameter
+ * @return null
+ */
+void buttonRelease(Button *button);
+
+/*
+ * @desc Button's action when button timeout for a period
+ * @param button - intput button with parameter
+ * @return null
+ */
+void buttonWaiting(Button *button);
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.service
new file mode 100755
index 0000000..c42d42f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/power-button-monitor.service
@@ -0,0 +1,12 @@
+[Unit]
+Description="Power Button Monitor"
+Wants=gpio-initial.service
+After=gpio-initial.service
+
+[Service]
+Restart=always
+ExecStart=/usr/sbin/power-button-monitor
+SyslogIdentifier=power-button-monitor
+
+[Install]
+RequiredBy={SYSTEMD_DEFAULT_TARGET}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.cpp b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.cpp
new file mode 100755
index 0000000..b35b57d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.cpp
@@ -0,0 +1,130 @@
+#include "reset-button-monitor.hpp"
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <iostream>
+#include <string>
+
+#define _POSIX_C_SOURCE 200809L
+#define POLL_TIMEOUT 1
+#define MAX_BUFFER 64
+
+#define DEBUG 0
+
+int main(int argc, char *argv[])
+{
+    struct pollfd fdset[2];
+    char *buf[MAX_BUFFER];
+    int gpioFd, timeout, rc;
+    int nfds = 2;
+    bool initWorkaround = true;
+
+    Button button;
+    button.gpioBase = findGpioBase();
+    button.gpioE0 = button.gpioBase + 32;
+
+    if(DEBUG){
+        std::cerr << "Reset Button monitor start\n";
+    }
+
+    while(1){
+        gpioFd = gpioFdOpen(button.gpioE0);
+
+        if(gpioFd < 0){
+            setGpioExport(button.gpioE0);
+            usleep(500000);
+            continue;
+        }
+
+        timeout = POLL_TIMEOUT;
+
+        while (1) {
+            memset((void*)fdset, 0, sizeof(fdset));
+
+            fdset[0].fd = STDIN_FILENO;
+            fdset[0].events = POLLIN;
+            fdset[1].fd = gpioFd;
+            fdset[1].events = POLLPRI;
+
+            rc = poll(fdset, nfds, timeout);
+
+            if (rc < 0) {
+                if(DEBUG){
+                    std::cerr << "Reset button Poll failed\n";
+                }
+                break;
+            }
+
+            if(button.buttonStatus && buttonTimeout(button.wait,POLL_TIMEOUT)){
+                //Reset waiting timer
+                button.wait = getCurrentTimeWithMs();
+                buttonWaiting(&button);
+            }
+
+            if(fdset[1].revents & POLLPRI) {
+                lseek(fdset[1].fd, 0, SEEK_SET);
+                read(fdset[1].fd, buf, MAX_BUFFER);
+
+                // To avoid first times input file's value
+                if(initWorkaround){
+                    initWorkaround=false;
+                    continue;
+                }
+
+                button.buttonValue = ((unsigned int) buf[0])%2;
+
+                if(button.buttonValue){
+                    buttonRelease(&button);
+                }
+                else{
+                    buttonPress(&button);
+                }
+            }
+
+            fflush(stdout);
+            usleep(50000);
+        }
+
+        close(gpioFd);
+    }
+
+    return 0;
+}
+
+
+void buttonPress(Button *button)
+{
+    if(DEBUG){
+        std::cerr << "Reset Button Press\n";
+    }
+
+    if(!button->buttonStatus){
+        button->start = getCurrentTimeWithMs();
+        button->wait = getCurrentTimeWithMs();
+
+        // To set reset button press and release by software
+        system("/usr/bin/gpioset `gpiofind RSTBTN_OUT`=0");
+
+        button->buttonStatus = true;
+    }
+}
+
+void buttonRelease(Button *button)
+{
+    if(DEBUG){
+        std::cerr << "Reset Button Release\n";
+    }
+
+    if(button->buttonStatus){
+        button->buttonStatus = false;
+        system("/usr/bin/gpioset `gpiofind RSTBTN_OUT`=1");
+    }
+}
+
+void buttonWaiting(Button *button)
+{
+    if(DEBUG){
+        std::cerr << "Reset button poll waiting...\n";
+    }
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.hpp b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.hpp
new file mode 100755
index 0000000..963174a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.hpp
@@ -0,0 +1,33 @@
+#pragma once
+
+#include "util.hpp"
+
+typedef struct{
+    unsigned int buttonValue = 0;
+    unsigned int gpioBase = 0;
+    unsigned int gpioE0 = 0;
+    unsigned int counter = 0;
+    bool buttonStatus = false;
+    double start, finish, wait, duration;
+}Button;
+
+/*
+ * @desc Button's action when button press
+ * @param button - intput button with parameter
+ * @return null
+ */
+void buttonPress(Button *button);
+
+/*
+ * @desc Button's action when button release
+ * @param button - intput button with parameter
+ * @return null
+ */
+void buttonRelease(Button *button);
+
+/*
+ * @desc Button's action when button timeout for a period
+ * @param button - intput button with parameter
+ * @return null
+ */
+void buttonWaiting(Button *button);
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.service
new file mode 100755
index 0000000..f3b2193
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/reset-button-monitor.service
@@ -0,0 +1,12 @@
+[Unit]
+Description="Reset Button Monitor"
+Wants=gpio-initial.service
+After=gpio-initial.service
+
+[Service]
+Restart=always
+ExecStart=/usr/sbin/reset-button-monitor
+SyslogIdentifier=reset-button-monitor
+
+[Install]
+RequiredBy={SYSTEMD_DEFAULT_TARGET}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/util.hpp b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/util.hpp
new file mode 100755
index 0000000..f08651f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-monitor/util.hpp
@@ -0,0 +1,188 @@
+#pragma once
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <math.h>
+#include <inttypes.h>
+#include <string.h>
+#include <fcntl.h>
+#include <poll.h>
+
+#define MAX_BUFFER 64 //Maximum size for char array
+
+/*
+ * @desc Find gpio base number in aspeed kernel's gpio path
+ * @param null
+ * @return success: gpio base number fail: zero
+ */
+unsigned int findGpioBase()
+{
+    unsigned int result = 0;
+    char buf[MAX_BUFFER];
+    FILE *fp;
+
+    if ((fp = popen("ls /sys/bus/platform/devices/1e780000.gpio/gpio |  grep -i gpiochip | cut -c 9-", "r")) == NULL){
+        return result;
+    }
+
+    fgets(buf, sizeof(buf), fp);
+    pclose(fp);
+
+    sscanf(buf, "%d", &result);
+
+    return result;
+}
+
+/*
+ * @desc Export gpio using sysfs path
+ * @param gpio - gpio number
+ * @return true: export success false: export fail
+ */
+bool setGpioExport(unsigned int gpio)
+{
+    unsigned int result = 0;
+    FILE * fp;
+    char buf[MAX_BUFFER];
+
+    sprintf(buf, "echo %d > /sys/class/gpio/export",gpio);
+
+    if ((fp = popen(buf, "r")) == NULL){
+        return false;
+    }
+
+    pclose(fp);
+
+    return true;
+}
+
+/*
+ * @desc Get gpio current value using sysfs path
+ * @param gpio - gpio number
+ * @return success: gpio current value fail: zero
+ */
+unsigned int getGpioValue(unsigned int gpio)
+{
+    unsigned int result = 0;
+    FILE * fp;
+    char buf[MAX_BUFFER];
+    char valuePath[MAX_BUFFER];
+
+    sprintf(valuePath, "cat /sys/class/gpio/gpio%d/value",gpio);
+
+    if ((fp = popen(valuePath, "r")) == NULL){
+        return result;
+    }
+
+    fgets(buf, sizeof(buf), fp);
+    pclose(fp);
+
+    sscanf(buf, "%d", &result);
+
+    return result;
+}
+
+/*
+ * @desc Set gpio current value using sysfs path
+ * @param gpio - gpio number
+ * @return true: get success false: get fail
+ */
+bool setGpioValue(unsigned int set,unsigned int gpio)
+{
+    unsigned int result = 0;
+    FILE * fp;
+    char unlockPath[MAX_BUFFER];
+
+    sprintf(unlockPath, "echo %d > /sys/class/gpio/gpio%d/value",set,gpio);
+
+    if ((fp = popen(unlockPath, "r")) == NULL){
+        return false;
+    }
+
+    pclose(fp);
+
+    return true;
+}
+
+/*
+ * @desc Get power good current value in dbus using bus control
+ * @param null
+ * @return success: power good current value fail: zero
+ */
+unsigned int getPowerGoodValue()
+{
+    unsigned int result = 0;
+    char buf[MAX_BUFFER];
+    FILE *fp;
+
+    if ((fp = popen("busctl get-property org.openbmc.control.Power /org/openbmc/control/power0 org.openbmc.control.Power pgood | cut -d' ' -f2", "r")) == NULL){
+        return result;
+    }
+
+    fgets(buf, sizeof(buf), fp);
+    pclose(fp);
+
+    sscanf(buf, "%d", &result);
+
+    return result;
+}
+
+/*
+ * @desc Get current timestamp in milliseconds
+ * @param null
+ * @return current timestamp in milliseconds
+ */
+double getCurrentTimeWithMs()
+{
+    time_t s;
+    long ms;
+    struct timespec spec;
+
+    clock_gettime(CLOCK_REALTIME, &spec);
+
+    s  = spec.tv_sec;
+    ms = round(spec.tv_nsec / 1.0e6); // Convert nanoseconds to milliseconds
+    if (ms > 999) {
+        s++;
+        ms = 0;
+    }
+
+    double  result = (intmax_t)s + ((double)ms/1000);
+
+    return result;
+}
+
+/*
+ * @desc Using open function for gpio value path in sysfs
+ * @param gpio - gpio number
+ * @return open's response code
+ */
+int gpioFdOpen(unsigned int gpio)
+{
+    int fd, len;
+    char buf[MAX_BUFFER];
+
+    len = snprintf(buf, sizeof(buf),"/sys/class/gpio/gpio%d/value", gpio);
+
+    fd = open(buf, O_RDONLY | O_NONBLOCK );
+
+    return fd;
+}
+
+/*
+ * @desc Check timerout for a period
+ * @param start - input time in period
+ * @param timeout - timeout time for a period
+ * @return true: timeout false: in period
+ */
+bool buttonTimeout(double start,int timeout)
+{
+    double current = getCurrentTimeWithMs();
+    double duration = (double)(current - start);
+
+    if(duration > (double)timeout){
+        return true;
+    }
+    return false;
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state.bb b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state.bb
new file mode 100755
index 0000000..ec6b5c9
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state.bb
@@ -0,0 +1,22 @@
+SUMMARY = "Button related trigger application"
+PR = "r1"
+
+inherit obmc-phosphor-systemd
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+DEPENDS += "virtual/obmc-gpio-monitor"
+RDEPENDS_${PN} += "virtual/obmc-gpio-monitor"
+
+S = "${WORKDIR}"
+SRC_URI += "file://toggle_identify_led.sh \
+            file://id-button-pressed.service \
+            "
+
+SYSTEMD_SERVICE_${PN} += "id-button-pressed.service"
+
+do_install() {
+    install -d ${D}${bindir}
+    install -m 0755 ${WORKDIR}/toggle_identify_led.sh ${D}${bindir}/toggle_identify_led.sh
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state/id-button-pressed.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state/id-button-pressed.service
new file mode 100755
index 0000000..f633fc3
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state/id-button-pressed.service
@@ -0,0 +1,10 @@
+[Unit]
+Description=ID Button Pressed Service
+Wants=mapper-wait@-xyz-openbmc_project-led-groups.service
+After=mapper-wait@-xyz-openbmc_project-led-groups.service
+StartLimitIntervalSec=0
+
+[Service]
+Type=oneshot
+ExecStart=/usr/bin/env toggle_identify_led.sh
+SyslogIdentifier=id-button
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state/toggle_identify_led.sh b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state/toggle_identify_led.sh
new file mode 100755
index 0000000..ce89e19
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/button-state/toggle_identify_led.sh
@@ -0,0 +1,21 @@
+#!/bin/sh
+# Toggle the state of identify LED Group
+
+SERVICE="xyz.openbmc_project.LED.Controller.identify"
+INTERFACE="xyz.openbmc_project.Led.Physical"
+object="/xyz/openbmc_project/led/physical/identify"
+PROPERTY="State"
+
+# Get current state
+object=$(busctl tree $SERVICE --list | grep identify)
+state=`busctl get-property $SERVICE $object $INTERFACE $PROPERTY | awk '{print $2}'`
+
+if [ "$state" == "\"xyz.openbmc_project.Led.Physical.Action.Off\"" ]; then
+    target='xyz.openbmc_project.Led.Physical.Action.On'
+else
+    target='xyz.openbmc_project.Led.Physical.Action.Off'
+fi
+
+# Set target state
+busctl set-property $SERVICE $object $INTERFACE $PROPERTY s $target
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state.bb b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state.bb
new file mode 100755
index 0000000..f7e7cff
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state.bb
@@ -0,0 +1,56 @@
+SUMMARY = "CPU related trigger application"
+PR = "r1"
+
+inherit obmc-phosphor-systemd
+inherit obmc-phosphor-ipmiprovider-symlink
+inherit pythonnative
+inherit systemd
+inherit obmc-phosphor-systemd
+inherit cmake
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+DEPENDS += "virtual/obmc-gpio-monitor"
+RDEPENDS_${PN} += "virtual/obmc-gpio-monitor"
+DEPENDS += "libpeci"
+
+S = "${WORKDIR}/"
+SRC_URI += " \
+            file://CMakeLists.txt\
+            file://LICENSE \
+            file://caterrHandler.cpp \
+            file://prochot_thermtrip_update.sh \
+            file://xyz.openbmc_project.caterr.service \
+            file://xyz.openbmc_project.prochot0.service \
+            file://xyz.openbmc_project.prochot0_deassert.service \
+            file://xyz.openbmc_project.prochot1.service \
+            file://xyz.openbmc_project.prochot1_deassert.service \
+            file://xyz.openbmc_project.thermtrip.service \
+            "
+
+DEPENDS += "sdbusplus sdbusplus-native"
+DEPENDS += "phosphor-logging"
+DEPENDS += "phosphor-dbus-interfaces phosphor-dbus-interfaces-native"
+DEPENDS += "sdbus++-native"
+
+do_install_append() {
+    install -d ${D}/usr/sbin
+    install -m 0755 ${WORKDIR}/prochot_thermtrip_update.sh ${D}/${sbindir}/
+}
+
+SYSTEMD_SERVICE_${PN} += "xyz.openbmc_project.caterr.service"
+SYSTEMD_SERVICE_${PN} += "xyz.openbmc_project.prochot0.service"
+SYSTEMD_SERVICE_${PN} += "xyz.openbmc_project.prochot0_deassert.service"
+SYSTEMD_SERVICE_${PN} += "xyz.openbmc_project.prochot1.service"
+SYSTEMD_SERVICE_${PN} += "xyz.openbmc_project.prochot1_deassert.service"
+SYSTEMD_SERVICE_${PN} += "xyz.openbmc_project.thermtrip.service"
+
+# linux-libc-headers guides this way to include custom uapi headers
+CFLAGS_append = " -I ${STAGING_KERNEL_DIR}/include/uapi"
+CFLAGS_append = " -I ${STAGING_KERNEL_DIR}/include"
+CXXFLAGS_append = " -I ${STAGING_KERNEL_DIR}/include/uapi"
+CXXFLAGS_append = " -I ${STAGING_KERNEL_DIR}/include"
+do_configure[depends] += "virtual/kernel:do_shared_workdir"
+
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/CMakeLists.txt b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/CMakeLists.txt
new file mode 100755
index 0000000..16a6010
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/CMakeLists.txt
@@ -0,0 +1,38 @@
+cmake_minimum_required(VERSION 3.6)
+project(caterrHandler)
+set (CMAKE_CXX_STANDARD 17)
+set (CMAKE_CXX_STANDARD_REQUIRED ON)
+set (
+    CMAKE_CXX_FLAGS
+    "${CMAKE_CXX_FLAGS} -lstdc++fs \
+    -Wall \
+    -Wextra \
+    -Wnon-virtual-dtor \
+    -Wold-style-cast \
+    -Wcast-align \
+    -Wunused \
+    -Woverloaded-virtual \
+    -Wpedantic \
+    -Wmisleading-indentation \
+    -Wduplicated-cond \
+    -Wduplicated-branches \
+    -Wlogical-op \
+    -Wnull-dereference \
+    -Wuseless-cast \
+    -Wdouble-promotion \
+    -Wformat=2 \
+    -Wno-sign-compare \
+     -Wno-reorder \
+    "
+  )
+
+set (LINK_LIBS -lsystemd stdc++fs sdbusplus peci)
+
+add_executable (caterrHandler caterrHandler.cpp)
+target_link_libraries(caterrHandler ${LINK_LIBS})
+
+install(TARGETS caterrHandler
+        RUNTIME DESTINATION bin
+        LIBRARY DESTINATION lib
+        ARCHIVE DESTINATION lib/static)
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/LICENSE b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/LICENSE
new file mode 100755
index 0000000..120e95d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2018 Intel Corporation
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/caterrHandler.cpp b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/caterrHandler.cpp
new file mode 100755
index 0000000..fe6cefa
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/caterrHandler.cpp
@@ -0,0 +1,145 @@
+#include <sdbusplus/bus.hpp>
+#include <sdbusplus/bus/match.hpp>
+#include <sdbusplus/message.hpp>
+#include <sdbusplus/vtable.hpp>
+#include <sdbusplus/server/interface.hpp>
+#include <peci.h>
+#include <systemd/sd-journal.h>
+#include <iostream>
+
+
+#define CATERR_OBJECTPATH_BASE "/xyz/openbmc_project/control/processor"
+#define CATERR_SERVICE "xyz.openbmc_project.Settings"
+#define CATERR_INTERFACE "xyz.openbmc_project.Control.Processor"
+#define PROPERTY_INTERFACE "org.freedesktop.DBus.Properties"
+
+static constexpr bool DEBUG = true;
+
+static constexpr char const* ipmiSELService =    "xyz.openbmc_project.Logging.IPMI";
+static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
+static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
+
+static constexpr char const *crashdumpService = "com.intel.crashdump";
+static constexpr char const *crashdumpPath = "/com/intel/crashdump";
+static constexpr char const *crashdumpIntf = "com.intel.crashdump.Stored";
+
+static constexpr char const* caterrSensorPath = "/xyz/openbmc_project/sensors/processor/CATERR";
+static constexpr char const* cpu0SensorPath = "/xyz/openbmc_project/sensors/processor/CPU0_State";
+static constexpr char const* cpu1SensorPath = "/xyz/openbmc_project/sensors/processor/CPU1_State";
+
+static const std::string ipmiSELAddMessage = "SEL Entry";
+static constexpr size_t selEvtDataMaxSize = 3;
+static const uint32_t intenalErrMask = 0x10100000; //internal CATERR or MSMI
+static const uint32_t ierrMask = 0x48480000; 
+static const uint32_t mcerrMask = 0x24240000; 
+
+int main()
+{
+
+    auto bus = sdbusplus::bus::new_default();
+#if 0      //ditch dbus property change
+    std::string state="xyz.openbmc_project.Control.Processor.State.CATERR"; 
+    auto method = bus.new_method_call(CATERR_SERVICE, CATERR_OBJECTPATH_BASE,
+                                      PROPERTY_INTERFACE, "Set");
+    method.append(CATERR_INTERFACE,"ProcessorStatus", sdbusplus::message::variant<std::string>(state));
+    bus.call_noreply(method);
+#endif 
+    //log SEL
+    uint16_t genId = 0x20;
+    bool assert=1;
+    std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
+    uint32_t mcaErrorSrc = 0xFFFFFFFF;
+
+    uint8_t cc = 0;
+    std::string errorType = "IERR";
+    std::string errorSenorPath;
+
+    //PECI fail, log CATERR SEL
+    if (peci_RdPkgConfig(0x30, PECI_MBX_INDEX_CPU_ID,PECI_PKG_ID_MACHINE_CHECK_STATUS, sizeof(uint32_t),
+                                reinterpret_cast<uint8_t*> (&mcaErrorSrc), &cc) != PECI_CC_SUCCESS)
+    
+    {
+        eventData[0] = static_cast<uint8_t>(0xb);  
+        errorSenorPath = caterrSensorPath;
+        sdbusplus::message::message writeSEL = bus.new_method_call(
+                        ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+        writeSEL.append(ipmiSELAddMessage,  errorSenorPath, eventData, assert, genId);
+                      
+        try
+        {
+            bus.call(writeSEL);
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            std::cerr << "call IpmiSelAdd failed\n";
+        }
+        return 0;
+    }
+    
+    sd_journal_print(LOG_ERR, "mcaErrorSrc = 0x%08x\n", mcaErrorSrc);    
+    //false postive, ignore it 
+    if ( 0 == mcaErrorSrc)
+    {
+        return 0;
+    }
+    //determine error socket
+    errorSenorPath = (mcaErrorSrc & intenalErrMask) ? cpu0SensorPath : cpu1SensorPath;
+                                                                    
+    
+    //log mcerr
+    if (mcaErrorSrc & mcerrMask)
+    {
+        eventData[0] = 0xc;
+        errorType = "MCERR";
+    
+        sdbusplus::message::message writeMcerrSEL = bus.new_method_call(
+                     ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+        writeMcerrSEL.append(ipmiSELAddMessage,  errorSenorPath, eventData, assert, genId);
+                      
+        try
+        {
+            bus.call(writeMcerrSEL);
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            std::cerr << "Failed to log MCERR SEL\n";
+        }     
+    }
+    
+    //log ierr
+    if (mcaErrorSrc & ierrMask)
+    {
+        eventData[0] = 0x00;
+        errorType = "IERR";
+    
+        sdbusplus::message::message writeIerrSEL = bus.new_method_call(
+                                ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+        writeIerrSEL.append(ipmiSELAddMessage,  errorSenorPath, eventData, assert, genId);
+                      
+        try
+        {
+            bus.call(writeIerrSEL);
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            std::cerr << "Failed to log IERR SEL\n";
+        }     
+    }
+                       
+    // Crashdump
+    sdbusplus::message::message crashdump = bus.new_method_call(
+             crashdumpService, crashdumpPath, crashdumpIntf, "GenerateStoredLog");
+    crashdump.append(errorType);
+    
+    try
+    {
+        bus.call_noreply(crashdump);
+    }
+    catch (sdbusplus::exception_t& e)
+    {
+        std::cerr<<"Failed to call crashdump\n";
+    }
+    
+    return 0;
+
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot0 b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot0
new file mode 100755
index 0000000..11c4d5d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot0
@@ -0,0 +1,6 @@
+DEVPATH=/dev/input/by-path/platform-gpio-keys-event
+KEY=62
+TARGET=xyz.openbmc_project.prochot0.service
+POLARITY=1
+EXTRA_ARGS=--continue
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot0_deassert b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot0_deassert
new file mode 100755
index 0000000..26f92d5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot0_deassert
@@ -0,0 +1,5 @@
+DEVPATH=/dev/input/by-path/platform-gpio-keys-event
+KEY=62
+TARGET=xyz.openbmc_project.prochot0_deassert.service
+POLARITY=0
+EXTRA_ARGS=--continue
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot1 b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot1
new file mode 100755
index 0000000..81bb049
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot1
@@ -0,0 +1,6 @@
+DEVPATH=/dev/input/by-path/platform-gpio-keys-event
+KEY=61
+TARGET=xyz.openbmc_project.prochot1.service
+POLARITY=1
+EXTRA_ARGS=--continue
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot1_deassert b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot1_deassert
new file mode 100755
index 0000000..02fe0f7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/obmc/gpio/prochot1_deassert
@@ -0,0 +1,5 @@
+DEVPATH=/dev/input/by-path/platform-gpio-keys-event
+KEY=61
+TARGET=xyz.openbmc_project.prochot1_deassert.service
+POLARITY=0
+EXTRA_ARGS=--continue
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/prochot_thermtrip_update.sh b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/prochot_thermtrip_update.sh
new file mode 100755
index 0000000..c639ff6
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/prochot_thermtrip_update.sh
@@ -0,0 +1,23 @@
+#!/bin/sh
+# Update prochot and thermtrip status
+
+type=$1
+event=$3
+
+if [ "$event" == "prochot" ]; then
+   offset=0x0A
+elif [ "$event" == "thermtrip" ]; then
+   offset=0x01
+fi
+
+SERVICE="xyz.openbmc_project.Logging.IPMI"
+OBJECT="/xyz/openbmc_project/Logging/IPMI"
+INTERFACE="xyz.openbmc_project.Logging.IPMI"
+METHOD="IpmiSelAdd"
+
+if [ "$type" == "assert" ]; then
+   busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/processor/$2" 3 {$offset,0x00,0xff} yes 0x20  
+else
+   busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/processor/$2" 3 {$offset,0x00,0xff} no 0x20
+fi
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.caterr.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.caterr.service
new file mode 100755
index 0000000..3607d1c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.caterr.service
@@ -0,0 +1,8 @@
+[Unit]
+Description=assert CATERR 
+
+[Service]
+Type=oneshot
+ExecStart=/usr/bin/caterrHandler
+SyslogIdentifier=caterr_assert
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot0.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot0.service
new file mode 100755
index 0000000..1148091
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot0.service
@@ -0,0 +1,10 @@
+[Unit]
+Description=assert Prochot0 
+StartLimitIntervalSec=6
+StartLimitBurst=1
+
+[Service]
+Type=oneshot
+ExecStart=/usr/bin/env prochot_thermtrip_update.sh assert CPU0_State prochot 
+SyslogIdentifier=prochot0_assert
+RemainAfterExit=true
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot0_deassert.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot0_deassert.service
new file mode 100755
index 0000000..5f1fce7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot0_deassert.service
@@ -0,0 +1,10 @@
+[Unit]
+Description=deassert Prochot0 
+StartLimitIntervalSec=6
+StartLimitBurst=1
+
+[Service]
+Type=oneshot
+ExecStart=/usr/bin/env prochot_thermtrip_update.sh deassert CPU0_State prochot
+SyslogIdentifier=prochot0_deassert
+RemainAfterExit=true
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot1.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot1.service
new file mode 100755
index 0000000..11057b5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot1.service
@@ -0,0 +1,10 @@
+[Unit]
+Description=assert Prochot1 
+StartLimitIntervalSec=6
+StartLimitBurst=1
+
+[Service]
+Type=oneshot
+ExecStart=/usr/bin/env prochot_thermtrip_update.sh assert CPU1_State prochot 
+SyslogIdentifier=prochot1_assert
+RemainAfterExit=true
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot1_deassert.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot1_deassert.service
new file mode 100755
index 0000000..624633d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.prochot1_deassert.service
@@ -0,0 +1,10 @@
+[Unit]
+Description=deassert Prochot1 
+StartLimitIntervalSec=6
+StartLimitBurst=1
+
+[Service]
+Type=oneshot
+ExecStart=/usr/bin/env prochot_thermtrip_update.sh deassert CPU1_State prochot
+SyslogIdentifier=prochot1_deassert
+RemainAfterExit=true
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.thermtrip.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.thermtrip.service
new file mode 100755
index 0000000..ace515f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/cpu-state/xyz.openbmc_project.thermtrip.service
@@ -0,0 +1,8 @@
+[Unit]
+Description=assert Thermtrip 
+
+[Service]
+Type=oneshot
+ExecStart=/usr/bin/env prochot_thermtrip_update.sh assert CPU_State thermtrip 
+SyslogIdentifier=thermtrip_assert
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0001-Support-GPIO-interrupt.patch b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0001-Support-GPIO-interrupt.patch
new file mode 100755
index 0000000..b67c848
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0001-Support-GPIO-interrupt.patch
@@ -0,0 +1,154 @@
+From 6f018f8e07af679dc21df3a5343ecffd27ff8844 Mon Sep 17 00:00:00 2001
+From: Jason <Jason_YX_Chang@wiwynn.com>
+Date: Fri, 10 Jan 2020 09:44:27 +0800
+Subject: [PATCH] Support GPIO interrupt
+
+---
+ gpio-util/meson.build |  2 +-
+ gpioMon.cpp           | 28 +++++++++++++++++++++-------
+ gpioMon.hpp           |  7 +++++--
+ gpioMonMain.cpp       |  5 +++--
+ presence/meson.build  |  2 +-
+ 5 files changed, 31 insertions(+), 13 deletions(-)
+
+diff --git a/gpio-util/meson.build b/gpio-util/meson.build
+index d14cbc3..dbad6c9 100644
+--- a/gpio-util/meson.build
++++ b/gpio-util/meson.build
+@@ -6,7 +6,7 @@ executable(
+     dependencies: [
+         phosphor_logging,
+     ],
+-    include_directories: '..',
++    include_directories: include_directories('..'),
+     implicit_include_directories: false,
+     install: true,
+ )
+diff --git a/gpioMon.cpp b/gpioMon.cpp
+index 2ab079a..176d371 100644
+--- a/gpioMon.cpp
++++ b/gpioMon.cpp
+@@ -18,6 +18,7 @@
+ 
+ #include <phosphor-logging/log.hpp>
+ #include <sdbusplus/bus.hpp>
++#include <iostream>
+ 
+ namespace phosphor
+ {
+@@ -68,17 +69,30 @@ void GpioMonitor::gpioEventHandler()
+     log<level::INFO>(logMessage.c_str());
+ 
+     /* Execute the target if it is defined. */
+-    if (!target.empty())
++    std::vector<std::string> targetsToStart;
++    if (gpioLineEvent.event_type == GPIOD_LINE_EVENT_RISING_EDGE)
+     {
+-        auto bus = sdbusplus::bus::new_default();
+-        auto method = bus.new_method_call(SYSTEMD_SERVICE, SYSTEMD_ROOT,
+-                                          SYSTEMD_INTERFACE, "StartUnit");
+-        method.append(target);
+-        method.append("replace");
++        targetsToStart = target["RISING"];
++    }
++    else
++    {
++        targetsToStart = target["FALLING"];
++    }
+ 
+-        bus.call_noreply(method);
++    if (!targetsToStart.empty())
++    {
++        auto bus = sdbusplus::bus::new_default();
++        for (auto &tar : targetsToStart)
++        {
++            auto method = bus.new_method_call(SYSTEMD_SERVICE, SYSTEMD_ROOT,
++                                              SYSTEMD_INTERFACE, "StartUnit");
++            method.append(tar);
++            method.append("replace");
++            bus.call_noreply(method);
++        }
+     }
+ 
++
+     /* if not required to continue monitoring then return */
+     if (!continueAfterEvent)
+     {
+diff --git a/gpioMon.hpp b/gpioMon.hpp
+index b07bb40..8c29741 100644
+--- a/gpioMon.hpp
++++ b/gpioMon.hpp
+@@ -4,6 +4,8 @@
+ 
+ #include <boost/asio/io_service.hpp>
+ #include <boost/asio/posix/stream_descriptor.hpp>
++#include <map>
++#include <vector>
+ 
+ namespace phosphor
+ {
+@@ -35,7 +37,8 @@ class GpioMonitor
+      *  @param[in] continueRun - Whether to continue after event occur
+      */
+     GpioMonitor(gpiod_line* line, gpiod_line_request_config& config,
+-                boost::asio::io_service& io, const std::string& target,
++                boost::asio::io_service& io, 
++                std::map<std::string, std::vector<std::string>> target,
+                 const std::string& lineMsg, bool continueRun) :
+         gpioLine(line),
+         gpioConfig(config), gpioEventDescriptor(io), target(target),
+@@ -55,7 +58,7 @@ class GpioMonitor
+     boost::asio::posix::stream_descriptor gpioEventDescriptor;
+ 
+     /** @brief Systemd unit to be started when the condition is met */
+-    const std::string target;
++    std::map<std::string, std::vector<std::string>> target;
+ 
+     /** @brief GPIO line name message */
+     std::string gpioLineMsg;
+diff --git a/gpioMonMain.cpp b/gpioMonMain.cpp
+index 4b8b052..251e0d5 100644
+--- a/gpioMonMain.cpp
++++ b/gpioMonMain.cpp
+@@ -21,6 +21,7 @@
+ #include <fstream>
+ #include <nlohmann/json.hpp>
+ #include <phosphor-logging/log.hpp>
++#include <iostream>
+ 
+ using namespace phosphor::logging;
+ 
+@@ -101,7 +102,7 @@ int main(int argc, char** argv)
+         bool flag = false;
+ 
+         /* target to start */
+-        std::string target;
++        std::map<std::string, std::vector<std::string>> target;
+ 
+         if (obj.find("LineName") == obj.end())
+         {
+@@ -170,7 +171,7 @@ int main(int argc, char** argv)
+          */
+         if (obj.find("Target") != obj.end())
+         {
+-            target = obj["Target"];
++                obj.at("Target").get_to(target);
+         }
+ 
+         /* Create a monitor object and let it do all the rest */
+diff --git a/presence/meson.build b/presence/meson.build
+index 1476e24..1e884e9 100644
+--- a/presence/meson.build
++++ b/presence/meson.build
+@@ -8,7 +8,7 @@ executable(
+         libevdev,
+         phosphor_logging,
+     ],
+-    include_directories: '..',
++    include_directories: include_directories('..'),
+     implicit_include_directories: false,
+     install: true,
+     link_with: [
+-- 
+2.24.1
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0002-init-host-status.patch b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0002-init-host-status.patch
new file mode 100755
index 0000000..c9a18d5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0002-init-host-status.patch
@@ -0,0 +1,68 @@
+From 4f3c781ee8568a0997e9ab8f4b12f9e994553c05 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Mon, 11 May 2020 17:34:51 +0800
+Subject: [PATCH 1/1] remove host state change in pgood monitor
+
+---
+ gpioMonMain.cpp | 35 +++++++++++++++++++++++++++++++++++
+ 1 file changed, 35 insertions(+)
+ mode change 100644 => 100755 gpioMonMain.cpp
+
+diff --git a/gpioMonMain.cpp b/gpioMonMain.cpp
+old mode 100644
+new mode 100755
+index 251e0d5..d56417f
+--- a/gpioMonMain.cpp
++++ b/gpioMonMain.cpp
+@@ -41,6 +41,37 @@ std::map<std::string, int> polarityMap = {
+ }
+ } // namespace phosphor
+ 
++static constexpr char const* PgService = "org.openbmc.control.Power";
++static constexpr char const* PgObj = "/org/openbmc/control/power0";
++static constexpr char const* PgIntf = "org.openbmc.control.Power";
++#define PROPERTY_INTERFACE "org.freedesktop.DBus.Properties"
++
++void pgoodhook(gpiod_line* line)
++{
++
++    if (gpiod_line_request_input(line, "gpio_monitor") < 0)
++    {
++         std::cerr << "Error request pgood\n";
++         return;
++    }
++
++    int resp = gpiod_line_get_value(line);
++
++    gpiod_line_release(line); 
++    auto bus = sdbusplus::bus::new_default();
++    std::cerr << "pgood:" << resp <<"\n";
++    auto method = bus.new_method_call(PgService, PgObj, PROPERTY_INTERFACE, "Set");
++    method.append(PgIntf, "pgood", sdbusplus::message::variant<int>((int)resp));
++    bus.call_noreply(method);
++
++    method = bus.new_method_call(PgService, PgObj, PROPERTY_INTERFACE, "Set");
++    method.append(PgIntf, "state", sdbusplus::message::variant<int>((int)resp));
++    bus.call_noreply(method);
++    
++    std::cerr << "pgood state init to: " << (int)resp << "\n";
++
++}
++
+ int main(int argc, char** argv)
+ {
+ 
+@@ -133,6 +164,10 @@ int main(int argc, char** argv)
+             std::string lineName = obj["LineName"];
+             lineMsg += lineName;
+             line = gpiod_line_find(lineName.c_str());
++            if(lineName.compare("PS_PWROK") == 0)
++            {
++                pgoodhook(line);
++            }
+         }
+ 
+         if (line == NULL)
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0003-Filter-the-debug-log-and-change-service-enable-metho.patch b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0003-Filter-the-debug-log-and-change-service-enable-metho.patch
new file mode 100755
index 0000000..e7c3682
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/0003-Filter-the-debug-log-and-change-service-enable-metho.patch
@@ -0,0 +1,40 @@
+From 66c873900169939852a3e47a6dbf10f22be20739 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 3 Sep 2020 14:09:56 +0800
+Subject: [PATCH] Filter the debug log and change service enable method
+
+---
+ monitor.cpp | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+ mode change 100644 => 100755 monitor.cpp
+
+diff --git a/monitor.cpp b/monitor.cpp
+old mode 100644
+new mode 100755
+index e2e912a..1bfb6b6
+--- a/monitor.cpp
++++ b/monitor.cpp
+@@ -35,7 +35,6 @@ using namespace phosphor::logging;
+ // Callback handler when there is an activity on the FD
+ int Monitor::processEvents(sd_event_source*, int, uint32_t, void* userData)
+ {
+-    log<level::INFO>("GPIO line altered");
+     auto monitor = static_cast<Monitor*>(userData);
+ 
+     monitor->analyzeEvent();
+@@ -77,10 +76,11 @@ void Monitor::analyzeEvent()
+                 // User supplied systemd unit
+                 if (!target.empty())
+                 {
++                    log<level::INFO>("GPIO line altered");
+                     auto bus = sdbusplus::bus::new_default();
+                     auto method =
+                         bus.new_method_call(SYSTEMD_SERVICE, SYSTEMD_ROOT,
+-                                            SYSTEMD_INTERFACE, "StartUnit");
++                                            SYSTEMD_INTERFACE, "RestartUnit");
+                     method.append(target);
+                     method.append("replace");
+ 
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/phosphor-gpio-monitor@.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/phosphor-gpio-monitor@.service
new file mode 100755
index 0000000..dabdee5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/phosphor-gpio-monitor@.service
@@ -0,0 +1,9 @@
+[Unit]
+Description=Phosphor GPIO %I monitor
+
+[Service]
+Restart=always
+EnvironmentFile={envfiledir}/obmc/gpio/%I
+ExecStart=/usr/bin/env phosphor-gpio-monitor --path=${{DEVPATH}} --key=${{KEY}} --polarity=${{POLARITY}} --target=${{TARGET}} ${{EXTRA_ARGS}}
+SyslogIdentifier=phosphor-gpio-monitor
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/phosphor-multi-gpio-monitor.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/phosphor-multi-gpio-monitor.service
new file mode 100755
index 0000000..c13e3eb
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/phosphor-multi-gpio-monitor.service
@@ -0,0 +1,22 @@
+[Unit]
+Description=Phosphor Multi GPIO monitor
+Before=phosphor-discover-system-state@0.service
+After=org.openbmc.control.Power@0.service
+Before=xyz.openbmc_project.adcsensor.service
+Before=xyz.openbmc_project.cpusensor.service
+Before=xyz.openbmc_project.hwmontempsensor.service
+Before=xyz.openbmc_project.ipmbsensor.service
+Before=xyz.openbmc_project.mnvmesensor.service
+Before=xyz.openbmc_project.psusensor.service
+Before=xyz.openbmc_project.fansensor.service
+
+[Service]
+Type=simple
+Restart=always
+RestartSec=5
+StartLimitInterval=0
+ExecStart=/usr/bin/phosphor-multi-gpio-monitor --config /usr/share/phosphor-gpio-monitor/phosphor-multi-gpio-monitor.json
+SyslogIdentifier=phosphor-multi-gpio-monitor
+
+[Install]
+WantedBy=multi-user.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/s5549_gpio.json b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/s5549_gpio.json
new file mode 100755
index 0000000..f96bf35
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor/s5549_gpio.json
@@ -0,0 +1,69 @@
+ [
+    {
+        "Name": "PowerGood",
+        "LineName": "PS_PWROK",
+        "EventMon": "BOTH",
+        "Continue": true,
+        "Target":
+        {
+            "FALLING": [
+                "SetPowerGoodPropertyOff.service"
+            ],
+            "RISING": [
+                "SetPowerGoodPropertyOn.service"
+            ]
+        }
+    },
+    {
+        "Name": "ThermalTrip",
+        "LineName": "THERMTRIP",
+        "EventMon": "FALLING",
+        "Continue": true,
+        "Target":
+        {
+            "FALLING": [
+                "xyz.openbmc_project.thermtrip.service"
+            ]
+        }
+    },
+    {
+        "Name": "CATERR",
+        "LineName": "CATERR",
+        "EventMon": "FALLING",
+        "Continue": true,
+        "Target":
+        {
+            "FALLING": [
+                "xyz.openbmc_project.caterr.service"
+            ]
+        }
+    },
+    {
+        "Name": "IdButton",
+        "LineName": "ID_BUTTON",
+        "EventMon": "FALLING",
+        "Continue": true,
+        "Target":
+        {
+            "FALLING": [
+                "id-button-pressed.service"
+            ]
+        }
+    },
+    {
+        "Name": "PROCHOT",
+        "LineName": "PROCHOT",
+        "EventMon": "BOTH",
+        "Continue": true,
+        "Target":
+        {
+            "FALLING": [
+                "xyz.openbmc_project.prochot0.service"
+            ],
+            "RISING": [
+                "xyz.openbmc_project.prochot0_deassert.service"
+            ]
+        }
+    }
+ ]
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor_git.bbappend
new file mode 100755
index 0000000..1ba90a5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/phosphor-gpio-monitor_git.bbappend
@@ -0,0 +1,19 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://phosphor-multi-gpio-monitor.service"
+SRC_URI += "file://phosphor-gpio-monitor@.service"
+SRC_URI += "file://s5549_gpio.json"
+SRC_URI += "file://0001-Support-GPIO-interrupt.patch \
+            file://0002-init-host-status.patch \
+            file://0003-Filter-the-debug-log-and-change-service-enable-metho.patch \
+           "
+
+FILES_${PN}-monitor += "${datadir}/phosphor-gpio-monitor/phosphor-multi-gpio-monitor.json"
+
+SYSTEMD_SERVICE_${PN}-monitor += "phosphor-multi-gpio-monitor.service"
+
+do_install_append(){
+    install -d ${D}/usr/share/phosphor-gpio-monitor
+    install -m 0444 ${WORKDIR}/*.json ${D}/usr/share/phosphor-gpio-monitor/phosphor-multi-gpio-monitor.json
+}
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state.bb b/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state.bb
new file mode 100755
index 0000000..5627817
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state.bb
@@ -0,0 +1,24 @@
+SUMMARY = "Power related trigger application"
+PR = "r1"
+
+inherit obmc-phosphor-systemd
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+DEPENDS += "virtual/obmc-gpio-monitor"
+RDEPENDS_${PN} += "virtual/obmc-gpio-monitor"
+
+S = "${WORKDIR}"
+SRC_URI += "file://setPowerProperty.sh \
+            file://SetPowerGoodPropertyOff.service \
+            file://SetPowerGoodPropertyOn.service \
+            "
+
+SYSTEMD_SERVICE_${PN} += "SetPowerGoodPropertyOff.service"
+SYSTEMD_SERVICE_${PN} += "SetPowerGoodPropertyOn.service"
+
+do_install() {
+    install -d ${D}${sbindir}
+    install -m 0755 ${WORKDIR}/setPowerProperty.sh ${D}/${sbindir}/setPowerProperty.sh
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/SetPowerGoodPropertyOff.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/SetPowerGoodPropertyOff.service
new file mode 100755
index 0000000..48abe99
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/SetPowerGoodPropertyOff.service
@@ -0,0 +1,6 @@
+[Unit]
+Description=Set Power Good Property Off
+
+[Service]
+Type=oneshot
+ExecStart=/usr/sbin/setPowerProperty.sh off
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/SetPowerGoodPropertyOn.service b/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/SetPowerGoodPropertyOn.service
new file mode 100755
index 0000000..047b6be
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/SetPowerGoodPropertyOn.service
@@ -0,0 +1,7 @@
+[Unit]
+Description=Set Power Good Property On
+
+[Service]
+Type=oneshot
+ExecStart=/usr/sbin/setPowerProperty.sh on
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/setPowerProperty.sh b/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/setPowerProperty.sh
new file mode 100755
index 0000000..7eeb37a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/gpio/power-state/setPowerProperty.sh
@@ -0,0 +1,47 @@
+#!/bin/sh
+
+bmcState=$(busctl get-property xyz.openbmc_project.State.BMC /xyz/openbmc_project/state/bmc0 xyz.openbmc_project.State.BMC CurrentBMCState|cut -d ' ' -f 2|cut -d . -f 6|cut -c -5)
+
+#offstatus=$(systemctl is-active host-poweroff.service)
+
+if [ "$1" == "on" ]; then
+    echo "pgood on"
+    busctl set-property "org.openbmc.control.Power" "/org/openbmc/control/power0" "org.openbmc.control.Power" "pgood" i 1
+    busctl set-property "org.openbmc.control.Power" "/org/openbmc/control/power0" "org.openbmc.control.Power" "state" i 1
+    if [ ! -d "/run/openbmc/" ]; then
+        mkdir /run/openbmc/
+    fi
+    touch /run/openbmc/chassis@0-on
+    touch /run/openbmc/host@0-on
+        	
+    if [ -f "/run/openbmc/ipmi-poweron" ]; then 
+	rm /run/openbmc/ipmi-poweron
+    else
+        echo "set host to on"
+
+        busctl set-property xyz.openbmc_project.State.Host /xyz/openbmc_project/state/host0 xyz.openbmc_project.State.Host CurrentHostState s "xyz.openbmc_project.State.Host.HostState.Running"
+        busctl set-property xyz.openbmc_project.State.Host /xyz/openbmc_project/state/host0 xyz.openbmc_project.State.Host RequestedHostTransition s "xyz.openbmc_project.State.Host.Transition.On"
+        # set chassis to on
+        busctl set-property xyz.openbmc_project.State.Chassis /xyz/openbmc_project/state/chassis0 xyz.openbmc_project.State.Chassis CurrentPowerState s "xyz.openbmc_project.State.Chassis.PowerState.On"
+        busctl set-property xyz.openbmc_project.State.Chassis /xyz/openbmc_project/state/chassis0 xyz.openbmc_project.State.Chassis RequestedPowerTransition s "xyz.openbmc_project.State.Chassis.Transition.On"
+    fi
+
+else
+    echo "pgood off"
+    busctl set-property "org.openbmc.control.Power" "/org/openbmc/control/power0" "org.openbmc.control.Power" "pgood" i 0
+    busctl set-property "org.openbmc.control.Power" "/org/openbmc/control/power0" "org.openbmc.control.Power" "state" i 0
+	rm -f /run/openbmc/chassis@0-on
+	rm -f /run/openbmc/host@0-on
+	rm -f /run/openbmc/host@0-request
+    
+    if [ -f "/run/openbmc/ipmi-poweroff" ]; then
+	rm /run/openbmc/ipmi-poweroff
+    else
+        echo "set host to off"
+	busctl set-property xyz.openbmc_project.State.Host /xyz/openbmc_project/state/host0 xyz.openbmc_project.State.Host CurrentHostState s "xyz.openbmc_project.State.Host.HostState.Off"
+        busctl set-property xyz.openbmc_project.State.Host /xyz/openbmc_project/state/host0 xyz.openbmc_project.State.Host RequestedHostTransition s "xyz.openbmc_project.State.Host.Transition.Off"
+        busctl set-property xyz.openbmc_project.State.Chassis /xyz/openbmc_project/state/chassis0 xyz.openbmc_project.State.Chassis CurrentPowerState s "xyz.openbmc_project.State.Chassis.PowerState.Off"
+        busctl set-property xyz.openbmc_project.State.Chassis /xyz/openbmc_project/state/chassis0 xyz.openbmc_project.State.Chassis RequestedPowerTransition s "xyz.openbmc_project.State.Chassis.Transition.Off"
+    fi
+fi
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/files/hbled_blink.sh b/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/files/hbled_blink.sh
new file mode 100755
index 0000000..f344d2e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/files/hbled_blink.sh
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+while [ 1 ]
+do
+	echo swmod_on > /sys/class/mct/hbled
+	sleep 0.5
+	echo swmod_off > /sys/class/mct/hbled
+	sleep 0.5
+done
diff --git a/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/files/obmc-hbled.service b/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/files/obmc-hbled.service
new file mode 100755
index 0000000..9f2ab31
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/files/obmc-hbled.service
@@ -0,0 +1,15 @@
+[Unit]
+Description=Heart beat LED control
+
+After=phosphor-ipmi-host.service
+[Service]
+Restart=always
+ExecStart=/usr/sbin/hbled_blink.sh
+SyslogIdentifier=hbled
+#Type=dbus
+#BusName=org.openbmc.HostIpmikcs
+TimeoutSec=infinity
+
+[Install]
+WantedBy={SYSTEMD_DEFAULT_TARGET}
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/hbled-ctrl.bb b/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/hbled-ctrl.bb
new file mode 100755
index 0000000..22ca5b8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/hbled-ctrl/hbled-ctrl.bb
@@ -0,0 +1,25 @@
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+FILESEXTRAPATHS_append := "${THISDIR}/files:"
+
+inherit systemd
+inherit obmc-phosphor-systemd
+
+S = "${WORKDIR}/"
+
+SRC_URI = "file://hbled_blink.sh \
+           file://obmc-hbled.service"
+
+
+
+DEPENDS = "systemd"
+RDEPENDS_${PN} = "bash"
+
+SYSTEMD_PACKAGES = "${PN}"
+SYSTEMD_SERVICE_${PN} = "obmc-hbled.service"
+
+do_install() {
+    install -d ${D}/usr/sbin
+    install -m 0755 ${S}hbled_blink.sh ${D}/${sbindir}/
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/images/obmc-phosphor-image.bbappend b/meta-mct/meta-s5549/recipes-phosphor/images/obmc-phosphor-image.bbappend
new file mode 100755
index 0000000..6b09ddb
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/images/obmc-phosphor-image.bbappend
@@ -0,0 +1,36 @@
+
+OBMC_IMAGE_EXTRA_INSTALL_append_s5549 = " libgpiod \
+                                          gpio-initial \
+                                          hbled-ctrl \
+                                          mct-powerctrl \
+                                          mct-default-action \
+                                          cpu-state \ 
+                                          phosphor-ipmi-ipmb \
+                                          entity-manager \
+                                          dbus-sensors \
+                                          obmc-ikvm \ 
+                                          intel-ipmi-oem \
+                                          phosphor-sel-logger \
+                                          phosphor-pid-control \
+                                          bios-update \
+                                          s5549-config \
+                                          memrw-utility \
+                                          system-watchdog \
+                                          phosphor-u-boot-mgr \
+                                          bmc-sel \
+                                          mct-ipmi-oem \
+                                          crashdump-bin \
+                                          button-monitor \
+                                          entity-rescan \
+                                          phosphor-post-code-manager \
+                                          phosphor-host-postd \
+                                          ethtool \
+                                          mct-dcmi-power \
+                                          gdb \
+                                          mct-register-monitor \
+                                          pattern-matching \
+                                          state-manager-recheck \
+                                          srvcfg-manager \
+                                          button-state \
+                                          power-state \
+                                        "
diff --git a/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs.bbappend b/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs.bbappend
new file mode 100755
index 0000000..a3248f6
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs.bbappend
@@ -0,0 +1 @@
+FILESEXTRAPATHS_prepend_s5549 := "${THISDIR}/${PN}:"
diff --git a/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs/obmc-shutdown.sh b/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs/obmc-shutdown.sh
new file mode 100755
index 0000000..ee28bcd
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs/obmc-shutdown.sh
@@ -0,0 +1,112 @@
+#!/bin/sh
+
+echo shutdown: "$@"
+
+export PS1=shutdown-sh#\ 
+# exec bin/sh
+
+# copy the necessary files for fw_setenv before umount partitions.
+cp /oldroot/sbin/fw_setenv /sbin
+cp /oldroot/etc/fw_env.config /etc/
+
+echo 'setenv bmc_reboot into uboot env var'
+mkdir /var/lock
+/sbin/fw_setenv bmc_reboot yes
+
+rm -rf /var/lock
+
+cd /
+if [ ! -e /proc/mounts ]
+then
+	mkdir -p /proc
+	mount  proc /proc -tproc
+	umount_proc=1
+else
+	umount_proc=
+fi
+
+# Remove an empty oldroot, that means we are not invoked from systemd-shutdown
+rmdir /oldroot 2>/dev/null
+
+# Move /oldroot/run to /mnt in case it has the underlying rofs loop mounted.
+# Ordered before /oldroot the overlay is unmounted before the loop mount
+mkdir -p /mnt
+mount --move /oldroot/run /mnt
+
+set -x
+for f in $( awk '/oldroot|mnt/ { print $2 }' < /proc/mounts | sort -r )
+do
+	umount $f
+done
+set +x
+
+update=/run/initramfs/update
+image=/run/initramfs/image-
+
+wdt="-t 1 -T 5"
+wdrst="-T 15"
+
+if ls $image* > /dev/null 2>&1
+then
+	if test -x $update
+	then
+		if test -c /dev/watchdog
+		then
+			echo Pinging watchdog ${wdt+with args $wdt}
+			watchdog $wdt -F /dev/watchdog &
+			wd=$!
+		else
+			wd=
+		fi
+		$update --clean-saved-files
+		remaining=$(ls $image*)
+		if test -n "$remaining"
+		then
+			echo 1>&2 "Flash update failed to flash these images:"
+			echo 1>&2 "$remaining"
+		else
+			echo "Flash update completed."
+		fi
+
+		if test -n "$wd"
+		then
+			kill -9 $wd
+			if test -n "$wdrst"
+			then
+				echo Resetting watchdog timeouts to $wdrst
+				watchdog $wdrst -F /dev/watchdog &
+				sleep 1
+				# Kill the watchdog daemon, setting a timeout
+				# for the remaining shutdown work
+				kill -9 $!
+			fi
+		fi
+	else
+		echo 1>&2 "Flash update requested but $update program missing!"
+	fi
+fi
+
+echo Remaining mounts:
+cat /proc/mounts
+
+test "$umount_proc" && umount /proc && rmdir /proc
+
+# tcsattr(tty, TIOCDRAIN, mode) to drain tty messages to console
+test -t 1 && stty cooked 0<&1
+
+# Execute the command systemd told us to ...
+if test -d /oldroot  && test "$1"
+then
+	if test "$1" = kexec
+	then
+		$1 -f -e
+	else
+		$1 -f
+	fi
+fi
+
+
+echo "Execute ${1-reboot} -f if all unmounted ok, or exec /init"
+
+export PS1=shutdown-sh#\ 
+exec /bin/sh
diff --git a/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs/obmc-update.sh b/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs/obmc-update.sh
new file mode 100755
index 0000000..07c4e45
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/initrdscripts/obmc-phosphor-initfs/obmc-update.sh
@@ -0,0 +1,285 @@
+#!/bin/sh
+
+echo update: "$@"
+
+echoerr() {
+	echo 1>&2 "ERROR: $@"
+}
+
+cd /
+if ! test -r /proc/mounts || ! test -f /proc/mounts
+then
+	mkdir -p /proc
+	mount -t proc proc proc
+fi
+if ! test -d /sys/class
+then
+	mkdir -p /sys
+	mount -t sysfs sys sys
+fi
+if ! test -c /dev/null
+then
+	mkdir -p /dev
+	mount -t devtmpfs dev dev
+fi
+
+# mtd number N with mtd name Name can be mounted via mtdN, or mtd:Name
+# (with a mtd aware fs) or by /dev/mtdblockN (with a mtd or block fs).
+mtdismounted() {
+	m=${1##mtd}
+	if grep -s "mtdblock$m " /proc/mounts || grep -s "mtd$m " /proc/mounts
+	then
+		return 0
+	fi
+	n=$(cat /sys/class/mtd/mtd$m/name)
+	if test -n "$n" && grep -s "mtd:$n " /proc/mounts
+	then
+		return 0
+	fi
+	return 1
+}
+
+# Detect child partitions when the whole flash is to be updated.
+# Ignore mtdNro and mtdblockN names in the class subsystem directory.
+childmtds() {
+	for m in /sys/class/mtd/$1/mtd*
+	do
+		m=${m##*/}
+		if test "${m%ro}" = "${m#mtdblock}"
+		then
+			echo $m
+		fi
+	done
+}
+
+toobig() {
+	if test $(stat -L -c "%s" "$1") -gt $(cat /sys/class/mtd/"$2"/size)
+	then
+		return 0
+	fi
+	return 1
+}
+
+findmtd() {
+	m=$(grep -xl "$1" /sys/class/mtd/*/name)
+	m=${m%/name}
+	m=${m##*/}
+	echo $m
+}
+
+blkid_fs_type() {
+	# Emulate util-linux's `blkid -s TYPE -o value $1`
+	# Example busybox blkid output:
+	#    # blkid /dev/mtdblock5
+	#    /dev/mtdblock5: TYPE="squashfs"
+	# Process output to extract TYPE value "squashfs".
+	blkid $1 | sed -e 's/^.*TYPE="//' -e 's/".*$//'
+}
+
+probe_fs_type() {
+	fst=$(blkid_fs_type $1)
+	echo ${fst:=jffs2}
+}
+
+rwfs=$(findmtd rwfs)
+
+rwdev=/dev/mtdblock${rwfs#mtd}
+rwopts=rw
+rorwopts=ro${rwopts#rw}
+
+rwdir=/run/initramfs/rw
+upper=$rwdir/cow
+save=/run/save/${upper##*/}
+
+mounted=
+doflash=y
+doclean=
+dosave=y
+dorestore=y
+toram=
+checksize=y
+checkmount=y
+
+whitelist=/run/initramfs/whitelist
+image=/run/initramfs/image-
+imglist=
+
+while test "$1" != "${1#-}"
+do
+	case "$1" in
+	--help)
+		cat <<HERE
+Usage: $0 [options] -- Write images in /run/initramfs to flash (/dev/mtd*)
+    --help                    Show this message
+    --no-flash                Don't attempt to write images to flash
+    --ignore-size             Don't compare image size to mtd device size
+    --ignore-mount            Don't check if destination is mounted
+    --save-files              Copy whitelisted files to save directory in RAM
+    --no-save-files           Don't copy whitelisted files to save directory
+    --copy-files              Copy files from save directory to rwfs mountpoint
+    --restore-files           Restore files from save directory to rwfs layer
+    --no-restore-files        Don't restore saved files from ram to rwfs layer
+    --clean-saved-files       Delete saved whitelisted files from RAM
+    --no-clean-saved-files    Retain saved whitelisted files in RAM
+HERE
+
+	    exit 0 ;;
+
+	--no-clean-saved-files)
+		doclean=
+		shift ;;
+	--clean-saved-files)
+		doclean=y
+		shift ;;
+	--no-save-files)
+		dosave=
+		shift ;;
+	--save-files)
+		dosave=y
+		shift ;;
+	--no-restore-files)
+		dorestore=
+		shift ;;
+	--restore-files)
+		dorestore=y
+		shift ;;
+	--no-flash)
+		doflash=
+		shift ;;
+	--ignore-size)
+		checksize=
+		shift ;;
+	--ignore-mount)
+		checkmount=
+		doflash=
+		shift ;;
+	--copy-files)
+		toram=y
+		shift ;;
+	*)
+		echoerr "Unknown option $1.  Try $0 --help."
+		exit 1 ;;
+	esac
+done
+
+if test "x$dosave" = xy
+then
+	if test ! -d $upper -a -n "$rwfs"
+	then
+		mkdir -p $rwdir
+		mount $rwdev $rwdir -t $(probe_fs_type $rwdev) -o $rorwopts
+		mounted=$rwdir
+	fi
+
+	while read f
+	do
+		# Entries shall start with /, no trailing /.. or embedded /../
+		if test "/${f#/}" != "$f" -o "${f%/..}" != "${f#*/../}"
+		then
+			echo 1>&2 "WARNING: Skipping bad whitelist entry $f."
+			continue
+		fi
+		if ! test -e "$upper/$f"
+		then
+			continue
+		fi
+		d="$save/$f"
+		while test "${d%/}" != "${d%/.}"
+		do
+			d="${d%/.}"
+			d="${d%/}"
+		done
+		mkdir -p "${d%/*}"
+		cp -rp "$upper/$f" "${d%/*}/"
+	done < $whitelist
+
+	if test -n "$mounted"
+	then
+		umount $mounted
+	fi
+fi
+
+imglist=$(echo $image*)
+if test "$imglist" = "$image*" -a ! -e "$imglist"
+then
+	# shell didn't expand the wildcard, so no files exist
+	echo "No images found to update."
+	imglist=
+fi
+
+for f in $imglist
+do
+	m=$(findmtd ${f#$image})
+	if test -z "$m"
+	then
+		echoerr "Unable to find mtd partition for ${f##*/}."
+		exit 1
+	fi
+	if test -n "$checksize" && toobig "$f" "$m"
+	then
+		echoerr "Image ${f##*/} too big for $m."
+		exit 1
+	fi
+	for s in $m $(childmtds $m)
+	do
+		if test -n "$checkmount" && mtdismounted $s
+		then
+			echoerr "Device $s is mounted, ${f##*/} is busy."
+			exit 1
+		fi
+	done
+done
+
+if test -n "$doflash"
+then
+	for f in $imglist
+	do
+		if test ! -s $f
+		then
+			echo "Skipping empty update of ${f#$image}."
+			rm $f
+			continue
+		fi
+		m=$(findmtd ${f#$image})
+		echo "Updating ${f#$image}..."
+		flashcp -v $f /dev/$m && rm $f
+	done
+    
+    #To record the version change SEL log next BMC boot
+    echo 'setenv bmc_update into uboot env var'
+    mkdir /var/lock
+    /sbin/fw_setenv bmc_update yes
+    rm -rf /var/lock
+fi
+
+if test -d $save -a "x$toram" = xy
+then
+	mkdir -p $upper
+	cp -rp $save/. $upper/
+fi
+
+if test -d $save -a "x$dorestore" = xy
+then
+	odir=$rwdir
+	rwdir=/run/rw
+	upper=$rwdir${upper#$odir}
+
+	mkdir -p $rwdir
+	mount $rwdev $rwdir -t $(probe_fs_type $rwdev) -o $rwopts
+	mkdir -p $upper
+	cp -rp $save/. $upper/
+	umount $rwdir
+	rmdir $rwdir
+fi
+
+if test "x$doclean" = xy
+then
+	rm -rf $save
+fi
+
+#remove the files for fw_setenv
+echo 'remove the files for fw_setenv'
+rm /etc/fw_env.config
+rm /sbin/fw_setenv
+
+exit
diff --git a/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0001-Support-rest-API-for-MCT-OEM.patch b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0001-Support-rest-API-for-MCT-OEM.patch
new file mode 100755
index 0000000..6da3ebe
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0001-Support-rest-API-for-MCT-OEM.patch
@@ -0,0 +1,62 @@
+From 75126145f1f228f6ded8dd5ee2a14a92fe78d040 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 28 Sep 2020 15:29:06 +0800
+Subject: [PATCH] Support rest API for MCT OEM
+
+---
+ CMakeLists.txt         | 6 ++++++
+ src/webserver_main.cpp | 5 +++++
+ 2 files changed, 11 insertions(+)
+ mode change 100644 => 100755 src/webserver_main.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 5266c5d..995b2b0 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -41,6 +41,11 @@ option (
+     ON
+ )
+ option (
++    BMCWEB_ENABLE_MCT_OEM_REST
++    "Enable MCT OEM REST APIs.  Paths are under '/'."
++    OFF
++)
++option (
+     BMCWEB_ENABLE_HOST_SERIAL_WEBSOCKET
+     "Enable host serial console WebSocket.  Path is '/console0'.  See
+     https://github.com/openbmc/docs/blob/master/console.md."
+@@ -445,6 +450,7 @@ target_compile_definitions (
+     $<$<BOOL:${BMCWEB_ENABLE_VM_NBDPROXY}>: -DBMCWEB_ENABLE_VM_NBDPROXY>
+     $<$<BOOL:${BMCWEB_ENABLE_DBUS_REST}>: -DBMCWEB_ENABLE_DBUS_REST>
+     $<$<BOOL:${BMCWEB_ENABLE_REDFISH}>: -DBMCWEB_ENABLE_REDFISH>
++    $<$<BOOL:${BMCWEB_ENABLE_MCT_OEM_REST}>: -DBMCWEB_ENABLE_MCT_OEM_REST>
+     $<$<BOOL:${BMCWEB_ENABLE_STATIC_HOSTING}>: -DBMCWEB_ENABLE_STATIC_HOSTING>
+     $<$<BOOL:${BMCWEB_ENABLE_HOST_SERIAL_WEBSOCKET}>:
+     -DBMCWEB_ENABLE_HOST_SERIAL_WEBSOCKET>
+diff --git a/src/webserver_main.cpp b/src/webserver_main.cpp
+old mode 100644
+new mode 100755
+index 0694b19..4410931
+--- a/src/webserver_main.cpp
++++ b/src/webserver_main.cpp
+@@ -19,6 +19,7 @@
+ #include <ssl_key_handler.hpp>
+ #include <vm_websocket.hpp>
+ #include <webassets.hpp>
++#include <mct_oem_rest.hpp>
+ 
+ #include <memory>
+ #include <string>
+@@ -93,6 +94,10 @@ int main(int /*argc*/, char** /*argv*/)
+     crow::obmc_vm::requestRoutes(app);
+ #endif
+ 
++#ifdef BMCWEB_ENABLE_MCT_OEM_REST
++    crow::mct_oem_rest::requestRoutes(app);
++#endif
++
+ #ifdef BMCWEB_ENABLE_IBM_MANAGEMENT_CONSOLE
+     crow::ibm_mc::requestRoutes(app);
+     crow::ibm_mc_lock::Lock::getInstance();
+-- 
+2.7.4
diff --git a/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0002-Fix-the-issue-for-update-bmcweb-recipe.patch b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0002-Fix-the-issue-for-update-bmcweb-recipe.patch
new file mode 100755
index 0000000..a4dcefe
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0002-Fix-the-issue-for-update-bmcweb-recipe.patch
@@ -0,0 +1,310 @@
+From a8dca95e6754ed42c50c8ef197ed805e477c0768 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 30 Sep 2020 16:05:26 +0800
+Subject: [PATCH] Fix the issue for update bmcweb recipe
+
+---
+ CMakeLists.txt                              |  6 +--
+ http/logging.h                              |  8 ++--
+ http/routing.h                              | 64 -----------------------------
+ include/obmc_console.hpp                    |  6 +--
+ redfish-core/include/node.hpp               | 17 ++------
+ redfish-core/include/server_sent_events.hpp |  4 +-
+ redfish-core/lib/account_service.hpp        | 16 --------
+ redfish-core/lib/redfish_sessions.hpp       |  4 +-
+ 8 files changed, 18 insertions(+), 107 deletions(-)
+ mode change 100644 => 100755 CMakeLists.txt
+ mode change 100644 => 100755 http/routing.h
+ mode change 100644 => 100755 include/obmc_console.hpp
+ mode change 100644 => 100755 redfish-core/include/node.hpp
+ mode change 100644 => 100755 redfish-core/include/server_sent_events.hpp
+ mode change 100644 => 100755 redfish-core/lib/account_service.hpp
+ mode change 100644 => 100755 redfish-core/lib/redfish_sessions.hpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+old mode 100644
+new mode 100755
+index 98ccb28..5266c5d
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -210,7 +210,7 @@ if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
+             -Wdouble-promotion \
+             -Wformat=2 \
+             -Wno-stringop-overflow \
+-            -Wunused-parameter \
++            -Wno-unused-parameter \
+         "
+         )
+     endif (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER 8.0)
+@@ -233,7 +233,7 @@ if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
+             -Wno-weak-vtables \
+             -Wno-documentation \
+             -Wno-padded \
+-            -Wunused-parameter \
++            -Wno-unused-parameter \
+             -Wcovered-switch-default \
+             -Wcomma \
+             -Wextra-semi \
+@@ -300,7 +300,7 @@ if (NOT ${YOCTO_DEPENDENCIES}) # Download and unpack googletest at configure
+     set (CMAKE_PREFIX_PATH ${CMAKE_BINARY_DIR}/prefix ${CMAKE_PREFIX_PATH})
+ endif ()
+ 
+-find_package (Boost 1.73 REQUIRED)
++find_package (Boost 1.71 REQUIRED)
+ message (BOOST_VERSION = ${Boost_VERSION})
+ include_directories (SYSTEM ${BOOST_SRC_DIR})
+ 
+diff --git a/http/logging.h b/http/logging.h
+index 4498c3d..524396f 100644
+--- a/http/logging.h
++++ b/http/logging.h
+@@ -40,9 +40,9 @@ class logger
+     }
+ 
+   public:
+-    logger([[maybe_unused]] const std::string& prefix,
+-           [[maybe_unused]] const std::string& filename,
+-           [[maybe_unused]] const size_t line, LogLevel levelIn) :
++    logger( const std::string& prefix,
++            const std::string& filename,
++            const size_t line, LogLevel levelIn) :
+         level(levelIn)
+     {
+ #ifdef BMCWEB_ENABLE_LOGGING
+@@ -64,7 +64,7 @@ class logger
+ 
+     //
+     template <typename T>
+-    logger& operator<<([[maybe_unused]] T const& value)
++    logger& operator<<( T const& value)
+     {
+         if (level >= get_current_log_level())
+         {
+diff --git a/http/routing.h b/http/routing.h
+old mode 100644
+new mode 100755
+index 1af1b2b..e43399a
+--- a/http/routing.h
++++ b/http/routing.h
+@@ -1296,77 +1296,13 @@ class Router
+                                      << " userRole = " << *userRolePtr;
+                 }
+ 
+-                bool* remoteUserPtr = nullptr;
+-                auto remoteUserIter = userInfo.find("RemoteUser");
+-                if (remoteUserIter != userInfo.end())
+-                {
+-                    remoteUserPtr = std::get_if<bool>(&remoteUserIter->second);
+-                }
+-                if (remoteUserPtr == nullptr)
+-                {
+-                    BMCWEB_LOG_ERROR
+-                        << "RemoteUser property missing or wrong type";
+-                    res.result(
+-                        boost::beast::http::status::internal_server_error);
+-                    res.end();
+-                    return;
+-                }
+-                bool remoteUser = *remoteUserPtr;
+-
+-                bool passwordExpired = false; // default for remote user
+-                if (!remoteUser)
+-                {
+-                    bool* passwordExpiredPtr = nullptr;
+-                    auto passwordExpiredIter =
+-                        userInfo.find("UserPasswordExpired");
+-                    if (passwordExpiredIter != userInfo.end())
+-                    {
+-                        passwordExpiredPtr =
+-                            std::get_if<bool>(&passwordExpiredIter->second);
+-                    }
+-                    if (passwordExpiredPtr != nullptr)
+-                    {
+-                        passwordExpired = *passwordExpiredPtr;
+-                    }
+-                    else
+-                    {
+-                        BMCWEB_LOG_ERROR
+-                            << "UserPasswordExpired property is expected for"
+-                               " local user but is missing or wrong type";
+-                        res.result(
+-                            boost::beast::http::status::internal_server_error);
+-                        res.end();
+-                        return;
+-                    }
+-                }
+-
+                 // Get the userprivileges from the role
+                 redfish::Privileges userPrivileges =
+                     redfish::getUserPrivileges(userRole);
+ 
+-                // Set isConfigureSelfOnly based on D-Bus results.  This
+-                // ignores the results from both pamAuthenticateUser and the
+-                // value from any previous use of this session.
+-                req.session->isConfigureSelfOnly = passwordExpired;
+-
+-                // Modifyprivileges if isConfigureSelfOnly.
+-                if (req.session->isConfigureSelfOnly)
+-                {
+-                    // Remove allprivileges except ConfigureSelf
+-                    userPrivileges = userPrivileges.intersection(
+-                        redfish::Privileges{"ConfigureSelf"});
+-                    BMCWEB_LOG_DEBUG << "Operation limited to ConfigureSelf";
+-                }
+-
+                 if (!rules[ruleIndex]->checkPrivileges(userPrivileges))
+                 {
+                     res.result(boost::beast::http::status::forbidden);
+-                    if (req.session->isConfigureSelfOnly)
+-                    {
+-                        redfish::messages::passwordChangeRequired(
+-                            res, "/redfish/v1/AccountService/Accounts/" +
+-                                     req.session->username);
+-                    }
+                     res.end();
+                     return;
+                 }
+diff --git a/include/obmc_console.hpp b/include/obmc_console.hpp
+old mode 100644
+new mode 100755
+index 29efbef..de5d0a5
+--- a/include/obmc_console.hpp
++++ b/include/obmc_console.hpp
+@@ -124,7 +124,7 @@ inline void requestRoutes(App& app)
+             }
+         })
+         .onclose([](crow::websocket::Connection& conn,
+-                    [[maybe_unused]] const std::string& reason) {
++                     const std::string& reason) {
+             sessions.erase(&conn);
+             if (sessions.empty())
+             {
+@@ -133,9 +133,9 @@ inline void requestRoutes(App& app)
+                 inputBuffer.shrink_to_fit();
+             }
+         })
+-        .onmessage([]([[maybe_unused]] crow::websocket::Connection& conn,
++        .onmessage([]( crow::websocket::Connection& conn,
+                       const std::string& data,
+-                      [[maybe_unused]] bool is_binary) {
++                       bool is_binary) {
+             inputBuffer += data;
+             doWrite();
+         });
+diff --git a/redfish-core/include/node.hpp b/redfish-core/include/node.hpp
+old mode 100644
+new mode 100755
+index 797160d..4ff3500
+--- a/redfish-core/include/node.hpp
++++ b/redfish-core/include/node.hpp
+@@ -53,7 +53,7 @@ class Node
+ {
+   public:
+     template <typename... Params>
+-    Node(App& app, std::string&& entityUrl, [[maybe_unused]] Params... paramsIn)
++    Node(App& app, std::string&& entityUrl,  Params... paramsIn)
+     {
+         crow::DynamicRule& get = app.routeDynamic(entityUrl.c_str());
+         getRule = &get;
+@@ -204,18 +204,9 @@ class Node
+         const std::string& userRole = req.userRole;
+         BMCWEB_LOG_DEBUG << "isAllowedWithoutConfigureSelf for the role "
+                          << req.userRole;
+-        Privileges effectiveUserPrivileges;
+-        if (req.session && req.session->isConfigureSelfOnly)
+-        {
+-            // The session has no privileges because it is limited to
+-            // configureSelfOnly and we are disregarding that privilege.
+-            // Note that some operations do not require any privilege.
+-        }
+-        else
+-        {
+-            effectiveUserPrivileges = redfish::getUserPrivileges(userRole);
+-            effectiveUserPrivileges.resetSinglePrivilege("ConfigureSelf");
+-        }
++        Privileges effectiveUserPrivileges =
++            redfish::getUserPrivileges(userRole);
++        effectiveUserPrivileges.resetSinglePrivilege("ConfigureSelf");
+         const auto& requiredPrivilegesIt = entityPrivileges.find(req.method());
+         return (requiredPrivilegesIt != entityPrivileges.end()) &&
+                isOperationAllowedWithPrivileges(requiredPrivilegesIt->second,
+diff --git a/redfish-core/include/server_sent_events.hpp b/redfish-core/include/server_sent_events.hpp
+old mode 100644
+new mode 100755
+index 26fc675..fac1e72
+--- a/redfish-core/include/server_sent_events.hpp
++++ b/redfish-core/include/server_sent_events.hpp
+@@ -109,7 +109,7 @@ class ServerSentEvents : public std::enable_shared_from_this<ServerSentEvents>
+             boost::asio::buffer(outBuffer.data(), outBuffer.size()),
+             [self(shared_from_this())](
+                 boost::beast::error_code ec,
+-                [[maybe_unused]] const std::size_t& bytesTransferred) {
++                 const std::size_t& bytesTransferred) {
+                 self->outBuffer.erase(0, bytesTransferred);
+ 
+                 if (ec == boost::asio::error::eof)
+@@ -166,7 +166,7 @@ class ServerSentEvents : public std::enable_shared_from_this<ServerSentEvents>
+             *sseConn, *serializer,
+             [this, response,
+              serializer](const boost::beast::error_code& ec,
+-                         [[maybe_unused]] const std::size_t& bytesTransferred) {
++                          const std::size_t& bytesTransferred) {
+                 if (ec)
+                 {
+                     BMCWEB_LOG_ERROR << "Error sending header" << ec;
+diff --git a/redfish-core/lib/account_service.hpp b/redfish-core/lib/account_service.hpp
+old mode 100644
+new mode 100755
+index fae181c..b3beccf
+--- a/redfish-core/lib/account_service.hpp
++++ b/redfish-core/lib/account_service.hpp
+@@ -1651,22 +1651,6 @@ class ManagerAccount : public Node
+                                                   "Roles/" +
+                                                       role}};
+                             }
+-                            else if (property.first == "UserPasswordExpired")
+-                            {
+-                                const bool* userPasswordExpired =
+-                                    std::get_if<bool>(&property.second);
+-                                if (userPasswordExpired == nullptr)
+-                                {
+-                                    BMCWEB_LOG_ERROR << "UserPassword"
+-                                                        "Expired "
+-                                                        "wasn't a bool";
+-                                    messages::internalError(asyncResp->res);
+-                                    return;
+-                                }
+-                                asyncResp->res
+-                                    .jsonValue["PasswordChangeRequired"] =
+-                                    *userPasswordExpired;
+-                            }
+                         }
+                     }
+                 }
+diff --git a/redfish-core/lib/redfish_sessions.hpp b/redfish-core/lib/redfish_sessions.hpp
+old mode 100644
+new mode 100755
+index fbbffcb..075071e
+--- a/redfish-core/lib/redfish_sessions.hpp
++++ b/redfish-core/lib/redfish_sessions.hpp
+@@ -201,7 +201,7 @@ class SessionCollection : public Node
+ 
+         int pamrc = pamAuthenticateUser(username, password);
+         bool isConfigureSelfOnly = pamrc == PAM_NEW_AUTHTOK_REQD;
+-        if ((pamrc != PAM_SUCCESS) && !isConfigureSelfOnly)
++        if ((pamrc != PAM_SUCCESS))
+         {
+             messages::resourceAtUriUnauthorized(res, std::string(req.url),
+                                                 "Invalid username or password");
+@@ -236,7 +236,7 @@ class SessionCollection : public Node
+         res.addHeader("Location", "/redfish/v1/SessionService/Sessions/" +
+                                       session->uniqueId);
+         res.result(boost::beast::http::status::created);
+-        if (session->isConfigureSelfOnly)
++        if (session->isConfigureSelfOnly || true)
+         {
+             messages::passwordChangeRequired(
+                 res,
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0003-Implement-the-SEL-feature-for-redfish-log-service.patch b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0003-Implement-the-SEL-feature-for-redfish-log-service.patch
new file mode 100755
index 0000000..309389a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/0003-Implement-the-SEL-feature-for-redfish-log-service.patch
@@ -0,0 +1,1604 @@
+From 4b1e80921aedea32aa72f1500cf31e365ed8ef3e Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 26 Oct 2020 13:12:54 +0800
+Subject: [PATCH] Implement the SEL feature for redfish log service
+
+---
+ CMakeLists.txt                                     |    1 -
+ redfish-core/include/event_service_manager.hpp     |    4 +-
+ redfish-core/include/logutils.hpp                  | 1146 ++++++++++++++++++++
+ redfish-core/include/registries.hpp                |    2 +-
+ .../registries/openbmc_message_registry.hpp        |  101 +-
+ redfish-core/lib/log_services.hpp                  |  146 ++-
+ 6 files changed, 1377 insertions(+), 23 deletions(-)
+ mode change 100644 => 100755 redfish-core/include/event_service_manager.hpp
+ create mode 100755 redfish-core/include/logutils.hpp
+ mode change 100644 => 100755 redfish-core/include/registries.hpp
+ mode change 100644 => 100755 redfish-core/include/registries/openbmc_message_registry.hpp
+ mode change 100644 => 100755 redfish-core/lib/log_services.hpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 995b2b0..f03964b 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -207,7 +207,6 @@ if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
+         set (
+             CMAKE_CXX_FLAGS
+             "${CMAKE_CXX_FLAGS} \
+-            -Werror \
+             -Wduplicated-cond \
+             -Wduplicated-branches \
+             -Wlogical-op \
+diff --git a/redfish-core/include/event_service_manager.hpp b/redfish-core/include/event_service_manager.hpp
+old mode 100644
+new mode 100755
+index ded8dbc..4768fea
+--- a/redfish-core/include/event_service_manager.hpp
++++ b/redfish-core/include/event_service_manager.hpp
+@@ -49,8 +49,8 @@ static constexpr const char* eventServiceFile =
+ 
+ #ifndef BMCWEB_ENABLE_REDFISH_DBUS_LOG_ENTRIES
+ static std::optional<boost::asio::posix::stream_descriptor> inotifyConn;
+-static constexpr const char* redfishEventLogDir = "/var/log";
+-static constexpr const char* redfishEventLogFile = "/var/log/redfish";
++static constexpr const char* redfishEventLogDir = "/var/lib/ipmi";
++static constexpr const char* redfishEventLogFile = "/var/lib/ipmi/redfish";
+ static constexpr const size_t iEventSize = sizeof(inotify_event);
+ static int inotifyFd = -1;
+ static int dirWatchDesc = -1;
+diff --git a/redfish-core/include/logutils.hpp b/redfish-core/include/logutils.hpp
+new file mode 100755
+index 0000000..e28e24c
+--- /dev/null
++++ b/redfish-core/include/logutils.hpp
+@@ -0,0 +1,1146 @@
++#include <boost/algorithm/string.hpp>
++#include <boost/bimap.hpp>
++#include <boost/container/flat_map.hpp>
++#include <cstring>
++#include <sdbusplus/bus.hpp>
++#include <sdbusplus/bus/match.hpp>
++#include <sdbusplus/timer.hpp>
++#include <sstream>
++#include <string>
++#include <array>
++
++#pragma once
++
++#define SENSOR_TYPE_MAX 0x2C
++#define DATA_BYTE2_SPECIFIED_MASK    0xc0 
++#define SIZE_OF_DESC    128
++
++std::vector<std::string> logEntryBuffer;
++
++enum MessageID 
++{ 
++    SELEntry,
++    SELEntryOK,
++    SELEntryCritical,
++    SELEntryWarning
++};
++
++const std::string MessageIDToString(MessageID value)
++{
++    static std::string table[] = { 
++        "OpenBMC.0.1.SELEntry",
++        "OpenBMC.0.1.SELEntryOK",
++        "OpenBMC.0.1.SELEntryCritical",
++        "OpenBMC.0.1.SELEntryWarning"
++    };
++	return table[value];
++}
++
++
++struct ipmiEventSensorTypes {
++    uint8_t	code;
++    uint8_t	offset;
++#define ALL_OFFSETS_SPECIFIED  0xff
++    uint8_t   data;
++    const char  * desc;
++};
++
++const char *ipmiGenericSensorTypeVals[] = {
++    "reserved",
++    "Temperature",
++    "Voltage",
++    "Current", 
++    "Fan",
++    "Physical Security",
++    "Platform Security",
++    "Processor",
++    "Power Supply",
++    "Power Unit",
++    "Cooling Device",
++    "Other",
++    "Memory",
++    "Drive Slot / Bay",
++    "POST Memory Resize",
++    "System Firmwares",
++    "Event Logging Disabled",
++    "Watchdog1",
++    "System Event",
++    "Critical Interrupt",
++    "Button",
++    "Module / Board",
++    "Microcontroller",
++    "Add-in Card",
++    "Chassis",
++    "Chip Set",
++    "Other FRU",
++    "Cable / Interconnect",
++    "Terminator",
++    "System Boot Initiated",
++    "Boot Error",
++    "OS Boot",
++    "OS Critical Stop",
++    "Slot / Connector",
++    "System ACPI Power State",
++    "Watchdog2",
++    "Platform Alert",
++    "Entity Presence",
++    "Monitor ASIC",
++    "LAN",
++    "Management Subsys Health",
++    "Battery",
++    "Session Audit",
++    "Version Change",
++    "FRU State",
++    NULL
++};
++
++static const struct ipmiEventSensorTypes genericEventTypes[] = {
++    /* Threshold Based States */
++    { 0x01, 0x00, 0xff, "Lower Non-critical going low " },
++    { 0x01, 0x01, 0xff, "Lower Non-critical going high" },
++    { 0x01, 0x02, 0xff, "Lower Critical going low " },
++    { 0x01, 0x03, 0xff, "Lower Critical going high" },
++    { 0x01, 0x04, 0xff, "Lower Non-recoverable going low " },
++    { 0x01, 0x05, 0xff, "Lower Non-recoverable going high" },
++    { 0x01, 0x06, 0xff, "Upper Non-critical going low " },
++    { 0x01, 0x07, 0xff, "Upper Non-critical going high" },
++    { 0x01, 0x08, 0xff, "Upper Critical going low " },
++    { 0x01, 0x09, 0xff, "Upper Critical going high" },
++    { 0x01, 0x0a, 0xff, "Upper Non-recoverable going low " },
++    { 0x01, 0x0b, 0xff, "Upper Non-recoverable going high" },
++    /* DMI-based "usage state" States */
++    { 0x02, 0x00, 0xff, "Transition to Idle" },
++    { 0x02, 0x01, 0xff, "Transition to Active" },
++    { 0x02, 0x02, 0xff, "Transition to Busy" },
++    /* Digital-Discrete Event States */
++    { 0x03, 0x00, 0xff, "State Deasserted" },
++    { 0x03, 0x01, 0xff, "State Asserted" },
++    { 0x04, 0x00, 0xff, "Predictive Failure Deasserted" },
++    { 0x04, 0x01, 0xff, "Predictive Failure Asserted" },
++    { 0x05, 0x00, 0xff, "Limit Not Exceeded" },
++    { 0x05, 0x01, 0xff, "Limit Exceeded" },
++    { 0x06, 0x00, 0xff, "Performance Met" },
++    { 0x06, 0x01, 0xff, "Performance Lags" },
++    /* Severity Event States */
++    { 0x07, 0x00, 0xff, "Transition to OK" },
++    { 0x07, 0x01, 0xff, "Transition to Non-critical from OK" },
++    { 0x07, 0x02, 0xff, "Transition to Critical from less severe" },
++    { 0x07, 0x03, 0xff, "Transition to Non-recoverable from less severe" },
++    { 0x07, 0x04, 0xff, "Transition to Non-critical from more severe" },
++    { 0x07, 0x05, 0xff, "Transition to Critical from Non-recoverable" },
++    { 0x07, 0x06, 0xff, "Transition to Non-recoverable" },
++    { 0x07, 0x07, 0xff, "Monitor" },
++    { 0x07, 0x08, 0xff, "Informational" },
++    /* Availability Status States */
++    { 0x08, 0x00, 0xff, "Device Absent" },
++    { 0x08, 0x01, 0xff, "Device Present" },
++    { 0x09, 0x00, 0xff, "Device Disabled" },
++    { 0x09, 0x01, 0xff, "Device Enabled" },
++    { 0x0a, 0x00, 0xff, "Transition to Running" },
++    { 0x0a, 0x01, 0xff, "Transition to In Test" },
++    { 0x0a, 0x02, 0xff, "Transition to Power Off" },
++    { 0x0a, 0x03, 0xff, "Transition to On Line" },
++    { 0x0a, 0x04, 0xff, "Transition to Off Line" },
++    { 0x0a, 0x05, 0xff, "Transition to Off Duty" },
++    { 0x0a, 0x06, 0xff, "Transition to Degraded" },
++    { 0x0a, 0x07, 0xff, "Transition to Power Save" },
++    { 0x0a, 0x08, 0xff, "Install Error" },
++    /* Redundancy States */
++    { 0x0b, 0x00, 0xff, "Fully Redundant" },
++    { 0x0b, 0x01, 0xff, "Redundancy Lost" },
++    { 0x0b, 0x02, 0xff, "Redundancy Degraded" },
++    { 0x0b, 0x03, 0xff, "Non-Redundant: Sufficient from Redundant" },
++    { 0x0b, 0x04, 0xff, "Non-Redundant: Sufficient from Insufficient" },
++    { 0x0b, 0x05, 0xff, "Non-Redundant: Insufficient Resources" },
++    { 0x0b, 0x06, 0xff, "Redundancy Degraded from Fully Redundant" },
++    { 0x0b, 0x07, 0xff, "Redundancy Degraded from Non-Redundant" },
++    /* ACPI Device Power States */
++    { 0x0c, 0x00, 0xff, "D0 Power State" },
++    { 0x0c, 0x01, 0xff, "D1 Power State" },
++    { 0x0c, 0x02, 0xff, "D2 Power State" },
++    { 0x0c, 0x03, 0xff, "D3 Power State" },
++    /* END */
++    { 0x00, 0x00, 0xff, NULL },
++};
++
++static const struct ipmiEventSensorTypes sensorSpecificEventTypes[] = {
++    /* Physical Security */
++    { 0x05, 0x00, 0xff, "General Chassis intrusion" },
++    { 0x05, 0x01, 0xff, "Drive Bay intrusion" },
++    { 0x05, 0x02, 0xff, "I/O Card area intrusion" },
++    { 0x05, 0x03, 0xff, "Processor area intrusion" },
++    { 0x05, 0x04, 0xff, "System unplugged from LAN" },
++    { 0x05, 0x05, 0xff, "Unauthorized dock" },
++    { 0x05, 0x06, 0xff, "FAN area intrusion" },
++    /* Platform Security */
++    { 0x06, 0x00, 0xff, "Front Panel Lockout violation attempted" },
++    { 0x06, 0x01, 0xff, "Pre-boot password violation - user password" },
++    { 0x06, 0x02, 0xff, "Pre-boot password violation - setup password" },
++    { 0x06, 0x03, 0xff, "Pre-boot password violation - network boot password" },
++    { 0x06, 0x04, 0xff, "Other pre-boot password violation" },
++    { 0x06, 0x05, 0xff, "Out-of-band access password violation" },
++    /* Processor */
++    { 0x07, 0x00, 0xff, "IERR" },
++    { 0x07, 0x01, 0xff, "Thermal Trip" },
++    { 0x07, 0x02, 0xff, "FRB1/BIST failure" },
++    { 0x07, 0x03, 0xff, "FRB2/Hang in POST failure" },
++    { 0x07, 0x04, 0xff, "FRB3/Processor startup/init failure" },
++    { 0x07, 0x05, 0xff, "Configuration Error" },
++    { 0x07, 0x06, 0xff, "SM BIOS Uncorrectable CPU-complex Error" },
++    { 0x07, 0x07, 0xff, "Presence detected" },
++    { 0x07, 0x08, 0xff, "Disabled" },
++    { 0x07, 0x09, 0xff, "Terminator presence detected" },
++    { 0x07, 0x0a, 0xff, "Throttled" },
++    { 0x07, 0x0b, 0xff, "Uncorrectable machine check exception" },
++    { 0x07, 0x0c, 0xff, "Correctable machine check error" },
++    /* Power Supply */
++    { 0x08, 0x00, 0xff, "Presence detected" },
++    { 0x08, 0x01, 0xff, "Failure detected" },
++    { 0x08, 0x02, 0xff, "Predictive failure" },
++    { 0x08, 0x03, 0xff, "Power Supply AC lost" },
++    { 0x08, 0x04, 0xff, "AC lost or out-of-range" },
++    { 0x08, 0x05, 0xff, "AC out-of-range, but present" },
++    { 0x08, 0x06, 0x00, "Config Error: Vendor Mismatch" },
++    { 0x08, 0x06, 0x01, "Config Error: Revision Mismatch" },
++    { 0x08, 0x06, 0x02, "Config Error: Processor Missing" },
++    { 0x08, 0x06, 0x03, "Config Error: Power Supply Rating Mismatch" },
++    { 0x08, 0x06, 0x04, "Config Error: Voltage Rating Mismatch" },
++    { 0x08, 0x06, 0xff, "Config Error" },
++    { 0x08, 0x06, 0xff, "Power Supply Inactive" },
++    /* Power Unit */
++    { 0x09, 0x00, 0xff, "Power off/down" },
++    { 0x09, 0x01, 0xff, "Power cycle" },
++    { 0x09, 0x02, 0xff, "240VA power down" },
++    { 0x09, 0x03, 0xff, "Interlock power down" },
++    { 0x09, 0x04, 0xff, "AC lost" },
++    { 0x09, 0x05, 0xff, "Soft-power control failure" },
++    { 0x09, 0x06, 0xff, "Failure detected" },
++    { 0x09, 0x07, 0xff, "Predictive failure" },
++    /* Memory */
++    { 0x0c, 0x00, 0xff, "Correctable ECC" },
++    { 0x0c, 0x01, 0xff, "Uncorrectable ECC" },
++    { 0x0c, 0x02, 0xff, "Parity" },
++    { 0x0c, 0x03, 0xff, "Memory Scrub Failed" },
++    { 0x0c, 0x04, 0xff, "Memory Device Disabled" },
++    { 0x0c, 0x05, 0xff, "Correctable ECC logging limit reached" },
++    { 0x0c, 0x06, 0xff, "Presence Detected" },
++    { 0x0c, 0x07, 0xff, "Configuration Error" },
++    { 0x0c, 0x08, 0xff, "Spare" },
++    { 0x0c, 0x09, 0xff, "Throttled" },
++    { 0x0c, 0x0a, 0xff, "Critical Overtemperature" },
++    /* Drive Slot */
++    { 0x0d, 0x00, 0xff, "Drive Present" },
++    { 0x0d, 0x01, 0xff, "Drive Fault" },
++    { 0x0d, 0x02, 0xff, "Predictive Failure" },
++    { 0x0d, 0x03, 0xff, "Hot Spare" },
++    { 0x0d, 0x04, 0xff, "Parity Check In Progress" },
++    { 0x0d, 0x05, 0xff, "In Critical Array" },
++    { 0x0d, 0x06, 0xff, "In Failed Array" },
++    { 0x0d, 0x07, 0xff, "Rebuild In Progress" },
++    { 0x0d, 0x08, 0xff, "Rebuild Aborted" },
++    /* System Firmware Error */
++    { 0x0f, 0x00, 0x00, "Unspecified" },
++    { 0x0f, 0x00, 0x01, "No system memory installed" },
++    { 0x0f, 0x00, 0x02, "No usable system memory" },
++    { 0x0f, 0x00, 0x03, "Unrecoverable IDE device failure" },
++    { 0x0f, 0x00, 0x04, "Unrecoverable system-board failure" },
++    { 0x0f, 0x00, 0x05, "Unrecoverable diskette failure" },
++    { 0x0f, 0x00, 0x06, "Unrecoverable hard-disk controller failure" },
++    { 0x0f, 0x00, 0x07, "Unrecoverable PS/2 or USB keyboard failure" },
++    { 0x0f, 0x00, 0x08, "Removable boot media not found" },
++    { 0x0f, 0x00, 0x09, "Unrecoverable video controller failure" },
++    { 0x0f, 0x00, 0x0a, "No video device selected" },
++    { 0x0f, 0x00, 0x0b, "BIOS corruption detected" },
++    { 0x0f, 0x00, 0x0c, "CPU voltage mismatch" },
++    { 0x0f, 0x00, 0x0d, "CPU speed mismatch failure" },
++    { 0x0f, 0x00, 0xff, "Unknown Error" },
++    /* System Firmware Hang */
++    { 0x0f, 0x01, 0x00, "Unspecified" },
++    { 0x0f, 0x01, 0x01, "Memory initialization" },
++    { 0x0f, 0x01, 0x02, "Hard-disk initialization" },
++    { 0x0f, 0x01, 0x03, "Secondary CPU Initialization" },
++    { 0x0f, 0x01, 0x04, "User authentication" },
++    { 0x0f, 0x01, 0x05, "User-initiated system setup" },
++    { 0x0f, 0x01, 0x06, "USB resource configuration" },
++    { 0x0f, 0x01, 0x07, "PCI resource configuration" },
++    { 0x0f, 0x01, 0x08, "Option ROM initialization" },
++    { 0x0f, 0x01, 0x09, "Video initialization" },
++    { 0x0f, 0x01, 0x0a, "Cache initialization" },
++    { 0x0f, 0x01, 0x0b, "SMBus initialization" },
++    { 0x0f, 0x01, 0x0c, "Keyboard controller initialization" },
++    { 0x0f, 0x01, 0x0d, "Management controller initialization" },
++    { 0x0f, 0x01, 0x0e, "Docking station attachment" },
++    { 0x0f, 0x01, 0x0f, "Enabling docking station" },
++    { 0x0f, 0x01, 0x10, "Docking station ejection" },
++    { 0x0f, 0x01, 0x11, "Disabling docking station" },
++    { 0x0f, 0x01, 0x12, "Calling operating system wake-up vector" },
++    { 0x0f, 0x01, 0x13, "System boot initiated" },
++    { 0x0f, 0x01, 0x14, "Motherboard initialization" },
++    { 0x0f, 0x01, 0x15, "reserved" },
++    { 0x0f, 0x01, 0x16, "Floppy initialization" },
++    { 0x0f, 0x01, 0x17, "Keyboard test" },
++    { 0x0f, 0x01, 0x18, "Pointing device test" },
++    { 0x0f, 0x01, 0x19, "Primary CPU initialization" },
++    { 0x0f, 0x01, 0xff, "Unknown Hang" },
++    /* System Firmware Progress */
++    { 0x0f, 0x02, 0x00, "Unspecified" },
++    { 0x0f, 0x02, 0x01, "Memory initialization" },
++    { 0x0f, 0x02, 0x02, "Hard-disk initialization" },
++    { 0x0f, 0x02, 0x03, "Secondary CPU Initialization" },
++    { 0x0f, 0x02, 0x04, "User authentication" },
++    { 0x0f, 0x02, 0x05, "User-initiated system setup" },
++    { 0x0f, 0x02, 0x06, "USB resource configuration" },
++    { 0x0f, 0x02, 0x07, "PCI resource configuration" },
++    { 0x0f, 0x02, 0x08, "Option ROM initialization" },
++    { 0x0f, 0x02, 0x09, "Video initialization" },
++    { 0x0f, 0x02, 0x0a, "Cache initialization" },
++    { 0x0f, 0x02, 0x0b, "SMBus initialization" },
++    { 0x0f, 0x02, 0x0c, "Keyboard controller initialization" },
++    { 0x0f, 0x02, 0x0d, "Management controller initialization" },
++    { 0x0f, 0x02, 0x0e, "Docking station attachment" },
++    { 0x0f, 0x02, 0x0f, "Enabling docking station" },
++    { 0x0f, 0x02, 0x10, "Docking station ejection" },
++    { 0x0f, 0x02, 0x11, "Disabling docking station" },
++    { 0x0f, 0x02, 0x12, "Calling operating system wake-up vector" },
++    { 0x0f, 0x02, 0x13, "System boot initiated" },
++    { 0x0f, 0x02, 0x14, "Motherboard initialization" },
++    { 0x0f, 0x02, 0x15, "reserved" },
++    { 0x0f, 0x02, 0x16, "Floppy initialization" },
++    { 0x0f, 0x02, 0x17, "Keyboard test" },
++    { 0x0f, 0x02, 0x18, "Pointing device test" },
++    { 0x0f, 0x02, 0x19, "Primary CPU initialization" },
++    { 0x0f, 0x02, 0xff, "Unknown Progress" },
++    /* Event Logging Disabled */
++    { 0x10, 0x00, 0xff, "Correctable memory error logging disabled" },
++    { 0x10, 0x01, 0xff, "Event logging disabled" },
++    { 0x10, 0x02, 0xff, "Log area reset/cleared" },
++    { 0x10, 0x03, 0xff, "All event logging disabled" },
++    { 0x10, 0x04, 0xff, "Log full" },
++    { 0x10, 0x05, 0xff, "Log almost full" },
++    /* Watchdog 1 */
++    { 0x11, 0x00, 0xff, "BIOS Reset" },
++    { 0x11, 0x01, 0xff, "OS Reset" },
++    { 0x11, 0x02, 0xff, "OS Shut Down" },
++    { 0x11, 0x03, 0xff, "OS Power Down" },
++    { 0x11, 0x04, 0xff, "OS Power Cycle" },
++    { 0x11, 0x05, 0xff, "OS NMI/Diag Interrupt" },
++    { 0x11, 0x06, 0xff, "OS Expired" },
++    { 0x11, 0x07, 0xff, "OS pre-timeout Interrupt" },
++    /* System Event */
++    { 0x12, 0x00, 0xff, "System Reconfigured" },
++    { 0x12, 0x01, 0xff, "OEM System boot event" },
++    { 0x12, 0x02, 0xff, "Undetermined system hardware failure" },
++    { 0x12, 0x03, 0xff, "Entry added to auxiliary log" },
++    { 0x12, 0x04, 0xff, "PEF Action" },
++    { 0x12, 0x05, 0xff, "Timestamp Clock Sync" },
++    /* Critical Interrupt */
++    { 0x13, 0x00, 0xff, "NMI/Diag Interrupt" },
++    { 0x13, 0x01, 0xff, "Bus Timeout" },
++    { 0x13, 0x02, 0xff, "I/O Channel check NMI" },
++    { 0x13, 0x03, 0xff, "Software NMI" },
++    { 0x13, 0x04, 0xff, "PCI PERR" },
++    { 0x13, 0x05, 0xff, "PCI SERR" },
++    { 0x13, 0x06, 0xff, "EISA failsafe timeout" },
++    { 0x13, 0x07, 0xff, "Bus Correctable error" },
++    { 0x13, 0x08, 0xff, "Bus Uncorrectable error" },
++    { 0x13, 0x09, 0xff, "Fatal NMI" },
++    { 0x13, 0x0a, 0xff, "Bus Fatal Error" },
++    { 0x13, 0x0b, 0xff, "Bus Degraded" },
++    /* Button */
++    { 0x14, 0x00, 0xff, "Power Button pressed" },
++    { 0x14, 0x01, 0xff, "Sleep Button pressed" },
++    { 0x14, 0x02, 0xff, "Reset Button pressed" },
++    { 0x14, 0x03, 0xff, "FRU Latch" },
++    { 0x14, 0x04, 0xff, "FRU Service" },
++    /* Chip Set */
++    { 0x19, 0x00, 0xff, "Soft Power Control Failure" },
++    { 0x19, 0x01, 0xff, "Thermal Trip" },
++    /* Cable/Interconnect */
++    { 0x1b, 0x00, 0xff, "Connected" },
++    { 0x1b, 0x01, 0xff, "Config Error" },
++    /* System Boot Initiated */
++    { 0x1d, 0x00, 0xff, "Initiated by power up" },
++    { 0x1d, 0x01, 0xff, "Initiated by hard reset" },
++    { 0x1d, 0x02, 0xff, "Initiated by warm reset" },
++    { 0x1d, 0x03, 0xff, "User requested PXE boot" },
++    { 0x1d, 0x04, 0xff, "Automatic boot to diagnostic" },
++    { 0x1d, 0x05, 0xff, "OS initiated hard reset" },
++    { 0x1d, 0x06, 0xff, "OS initiated warm reset" },
++    { 0x1d, 0x07, 0xff, "System Restart" },
++    /* Boot Error */
++    { 0x1e, 0x00, 0xff, "No bootable media" },
++    { 0x1e, 0x01, 0xff, "Non-bootable disk in drive" },
++    { 0x1e, 0x02, 0xff, "PXE server not found" },
++    { 0x1e, 0x03, 0xff, "Invalid boot sector" },
++    { 0x1e, 0x04, 0xff, "Timeout waiting for selection" },
++    /* OS Boot */
++    { 0x1f, 0x00, 0xff, "A: boot completed" },
++    { 0x1f, 0x01, 0xff, "C: boot completed" },
++    { 0x1f, 0x02, 0xff, "PXE boot completed" },
++    { 0x1f, 0x03, 0xff, "Diagnostic boot completed" },
++    { 0x1f, 0x04, 0xff, "CD-ROM boot completed" },
++    { 0x1f, 0x05, 0xff, "ROM boot completed" },
++    { 0x1f, 0x06, 0xff, "boot completed - device not specified" },
++    { 0x1f, 0x07, 0xff, "Installation started" },
++    { 0x1f, 0x08, 0xff, "Installation completed" },
++    { 0x1f, 0x09, 0xff, "Installation aborted" },
++    { 0x1f, 0x0a, 0xff, "Installation failed" },
++    /* OS Stop/Shutdown */
++    { 0x20, 0x00, 0xff, "Error during system startup" },
++    { 0x20, 0x01, 0xff, "Run-time critical stop" },
++    { 0x20, 0x02, 0xff, "OS graceful stop" },
++    { 0x20, 0x03, 0xff, "OS graceful shutdown" },
++    { 0x20, 0x04, 0xff, "PEF initiated soft shutdown" },
++    { 0x20, 0x05, 0xff, "Agent not responding" },
++    /* Slot/Connector */
++    { 0x21, 0x00, 0xff, "Fault Status" },
++    { 0x21, 0x01, 0xff, "Identify Status" },
++    { 0x21, 0x02, 0xff, "Device Installed" },
++    { 0x21, 0x03, 0xff, "Ready for Device Installation" },
++    { 0x21, 0x04, 0xff, "Ready for Device Removal" },
++    { 0x21, 0x05, 0xff, "Slot Power is Off" },
++    { 0x21, 0x06, 0xff, "Device Removal Request" },
++    { 0x21, 0x07, 0xff, "Interlock" },
++    { 0x21, 0x08, 0xff, "Slot is Disabled" },
++    { 0x21, 0x09, 0xff, "Spare Device" },
++    /* System ACPI Power State */
++    { 0x22, 0x00, 0xff, "S0/G0: working" },
++    { 0x22, 0x01, 0xff, "S1: sleeping with system hw & processor context maintained" },
++    { 0x22, 0x02, 0xff, "S2: sleeping, processor context lost" },
++    { 0x22, 0x03, 0xff, "S3: sleeping, processor & hw context lost, memory retained" },
++    { 0x22, 0x04, 0xff, "S4: non-volatile sleep/suspend-to-disk" },
++    { 0x22, 0x05, 0xff, "S5/G2: soft-off" },
++    { 0x22, 0x06, 0xff, "S4/S5: soft-off" },
++    { 0x22, 0x07, 0xff, "G3: mechanical off" },
++    { 0x22, 0x08, 0xff, "Sleeping in S1/S2/S3 state" },
++    { 0x22, 0x09, 0xff, "G1: sleeping" },
++    { 0x22, 0x0a, 0xff, "S5: entered by override" },
++    { 0x22, 0x0b, 0xff, "Legacy ON state" },
++    { 0x22, 0x0c, 0xff, "Legacy OFF state" },
++    { 0x22, 0x0e, 0xff, "Unknown" },
++    /* Watchdog 2 */
++    { 0x23, 0x00, 0xff, "Timer expired" },
++    { 0x23, 0x01, 0xff, "Hard reset" },
++    { 0x23, 0x02, 0xff, "Power down" },
++    { 0x23, 0x03, 0xff, "Power cycle" },
++    { 0x23, 0x04, 0xff, "reserved" },
++    { 0x23, 0x05, 0xff, "reserved" },
++    { 0x23, 0x06, 0xff, "reserved" },
++    { 0x23, 0x07, 0xff, "reserved" },
++    { 0x23, 0x08, 0xff, "Timer interrupt" },
++    /* Platform Alert */
++    { 0x24, 0x00, 0xff, "Platform generated page" },
++    { 0x24, 0x01, 0xff, "Platform generated LAN alert" },
++    { 0x24, 0x02, 0xff, "Platform Event Trap generated" },
++    { 0x24, 0x03, 0xff, "Platform generated SNMP trap, OEM format" },
++    /* Entity Presence */
++    { 0x25, 0x00, 0xff, "Present" },
++    { 0x25, 0x01, 0xff, "Absent" },
++    { 0x25, 0x02, 0xff, "Disabled" },
++    /* LAN */
++    { 0x27, 0x00, 0xff, "Heartbeat Lost" },
++    { 0x27, 0x01, 0xff, "Heartbeat" },
++    /* Management Subsystem Health */
++    { 0x28, 0x00, 0xff, "Sensor access degraded or unavailable" },
++    { 0x28, 0x01, 0xff, "Controller access degraded or unavailable" },
++    { 0x28, 0x02, 0xff, "Management controller off-line" },
++    { 0x28, 0x03, 0xff, "Management controller unavailable" },
++    { 0x28, 0x04, 0xff, "Sensor failure" },
++    { 0x28, 0x05, 0xff, "FRU failure" },
++    /* Battery */
++    { 0x29, 0x00, 0xff, "Low" },
++    { 0x29, 0x01, 0xff, "Failed" },
++    { 0x29, 0x02, 0xff, "Presence Detected" },
++    /* Version Change */
++    { 0x2b, 0x00, 0xff, "Hardware change detected" },
++    { 0x2b, 0x01, 0x00, "Firmware or software change detected" },
++    { 0x2b, 0x01, 0x01, "Firmware or software change detected, Mngmt Ctrl Dev Id" },
++    { 0x2b, 0x01, 0x02, "Firmware or software change detected, Mngmt Ctrl Firm Rev" },
++    { 0x2b, 0x01, 0x03, "Firmware or software change detected, Mngmt Ctrl Dev Rev" },
++    { 0x2b, 0x01, 0x04, "Firmware or software change detected, Mngmt Ctrl Manuf Id" },
++    { 0x2b, 0x01, 0x05, "Firmware or software change detected, Mngmt Ctrl IPMI Vers" },
++    { 0x2b, 0x01, 0x06, "Firmware or software change detected, Mngmt Ctrl Aux Firm Id" },
++    { 0x2b, 0x01, 0x07, "Firmware or software change detected, Mngmt Ctrl Firm Boot Block" },
++    { 0x2b, 0x01, 0x08, "Firmware or software change detected, Mngmt Ctrl Other" },
++    { 0x2b, 0x01, 0x09, "Firmware or software change detected, BIOS/EFI change" },
++    { 0x2b, 0x01, 0x0A, "Firmware or software change detected, SMBIOS change" },
++    { 0x2b, 0x01, 0x0B, "Firmware or software change detected, O/S change" },
++    { 0x2b, 0x01, 0x0C, "Firmware or software change detected, O/S loader change" },
++    { 0x2b, 0x01, 0x0D, "Firmware or software change detected, Service Diag change" },
++    { 0x2b, 0x01, 0x0E, "Firmware or software change detected, Mngmt SW agent change" },
++    { 0x2b, 0x01, 0x0F, "Firmware or software change detected, Mngmt SW App change" },
++    { 0x2b, 0x01, 0x10, "Firmware or software change detected, Mngmt SW Middle" },
++    { 0x2b, 0x01, 0x11, "Firmware or software change detected, Prog HW Change (FPGA)" },
++    { 0x2b, 0x01, 0x12, "Firmware or software change detected, board/FRU module change" },
++    { 0x2b, 0x01, 0x13, "Firmware or software change detected, board/FRU component change" },
++    { 0x2b, 0x01, 0x14, "Firmware or software change detected, board/FRU replace equ ver" },
++    { 0x2b, 0x01, 0x15, "Firmware or software change detected, board/FRU replace new ver" },
++    { 0x2b, 0x01, 0x16, "Firmware or software change detected, board/FRU replace old ver" },
++    { 0x2b, 0x01, 0x17, "Firmware or software change detected, board/FRU HW conf change" },
++    { 0x2b, 0x02, 0xff, "Hardware incompatibility detected" },
++    { 0x2b, 0x03, 0xff, "Firmware or software incompatibility detected" },
++    { 0x2b, 0x04, 0xff, "Invalid or unsupported hardware version" },
++    { 0x2b, 0x05, 0xff, "Invalid or unsupported firmware or software version" },
++    { 0x2b, 0x06, 0xff, "Hardware change success" },
++    { 0x2b, 0x07, 0x00, "Firmware or software change success" },
++    { 0x2b, 0x07, 0x01, "Firmware or software change success, Mngmt Ctrl Dev Id" },
++    { 0x2b, 0x07, 0x02, "Firmware or software change success, Mngmt Ctrl Firm Rev" },
++    { 0x2b, 0x07, 0x03, "Firmware or software change success, Mngmt Ctrl Dev Rev" },
++    { 0x2b, 0x07, 0x04, "Firmware or software change success, Mngmt Ctrl Manuf Id" },
++    { 0x2b, 0x07, 0x05, "Firmware or software change success, Mngmt Ctrl IPMI Vers" },
++    { 0x2b, 0x07, 0x06, "Firmware or software change success, Mngmt Ctrl Aux Firm Id" },
++    { 0x2b, 0x07, 0x07, "Firmware or software change success, Mngmt Ctrl Firm Boot Block" },
++    { 0x2b, 0x07, 0x08, "Firmware or software change success, Mngmt Ctrl Other" },
++    { 0x2b, 0x07, 0x09, "Firmware or software change success, BIOS/EFI change" },
++    { 0x2b, 0x07, 0x0A, "Firmware or software change success, SMBIOS change" },
++    { 0x2b, 0x07, 0x0B, "Firmware or software change success, O/S change" },
++    { 0x2b, 0x07, 0x0C, "Firmware or software change success, O/S loader change" },
++    { 0x2b, 0x07, 0x0D, "Firmware or software change success, Service Diag change" },
++    { 0x2b, 0x07, 0x0E, "Firmware or software change success, Mngmt SW agent change" },
++    { 0x2b, 0x07, 0x0F, "Firmware or software change success, Mngmt SW App change" },
++    { 0x2b, 0x07, 0x10, "Firmware or software change success, Mngmt SW Middle" },
++    { 0x2b, 0x07, 0x11, "Firmware or software change success, Prog HW Change (FPGA)" },
++    { 0x2b, 0x07, 0x12, "Firmware or software change success, board/FRU module change" },
++    { 0x2b, 0x07, 0x13, "Firmware or software change success, board/FRU component change" },
++    { 0x2b, 0x07, 0x14, "Firmware or software change success, board/FRU replace equ ver" },
++    { 0x2b, 0x07, 0x15, "Firmware or software change success, board/FRU replace new ver" },
++    { 0x2b, 0x07, 0x16, "Firmware or software change success, board/FRU replace old ver" },
++    { 0x2b, 0x07, 0x17, "Firmware or software change success, board/FRU HW conf change" },
++    /* FRU State */
++    { 0x2c, 0x00, 0xff, "Not Installed" },
++    { 0x2c, 0x01, 0xff, "Inactive" },
++    { 0x2c, 0x02, 0xff, "Activation Requested" },
++    { 0x2c, 0x03, 0xff, "Activation in Progress" },
++    { 0x2c, 0x04, 0xff, "Active" },
++    { 0x2c, 0x05, 0xff, "Deactivation Requested" },
++    { 0x2c, 0x06, 0xff, "Deactivation in Progress" },
++    { 0x2c, 0x07, 0xff, "Communication lost" },
++    /* PICMG FRU Hot Swap */
++    { 0xF0, 0x00, 0xFF, "Transition to M0" },
++    { 0xF0, 0x01, 0xFF, "Transition to M1" },
++    { 0xF0, 0x02, 0xFF, "Transition to M2" },
++    { 0xF0, 0x03, 0xFF, "Transition to M3" },
++    { 0xF0, 0x04, 0xFF, "Transition to M4" },
++    { 0xF0, 0x05, 0xFF, "Transition to M5" },
++    { 0xF0, 0x06, 0xFF, "Transition to M6" },
++    { 0xF0, 0x07, 0xFF, "Transition to M7" },
++    /* PICMG IPMB Physical Link */
++    { 0xF1, 0x00, 0xff, "IPMB-A disabled, IPMB-B disabled" },
++    { 0xF1, 0x01, 0xff, "IPMB-A enabled, IPMB-B disabled" },
++    { 0xF1, 0x02, 0xff, "IPMB-A disabled, IPMB-B enabled" },
++    { 0xF1, 0x03, 0xff, "IPMB-A enabled, IPMB-B enabled" },
++    /* PICMG Module Hot Swap */
++    { 0xF2, 0x00, 0xff, "Module Handle Closed" },
++    { 0xF2, 0x01, 0xff, "Module Handle Opened" },
++    { 0xF2, 0x02, 0xff, "Quiesced" },
++    { 0x00, 0x00, 0xff, NULL },
++};
++
++struct CmpStrVersion
++{
++    bool operator()(std::string a, std::string b) const
++    {
++        return strverscmp(a.c_str(), b.c_str()) < 0;
++    }
++};
++
++using SensorSubTree = boost::container::flat_map<
++    std::string,
++    boost::container::flat_map<std::string, std::vector<std::string>>,
++    CmpStrVersion>;
++
++
++using SensorNumMap = boost::bimap<int, std::string>;
++
++namespace details
++{
++inline static bool getSensorSubtree(std::shared_ptr<SensorSubTree>& subtree)
++{
++    static std::shared_ptr<SensorSubTree> sensorTreePtr;
++    sd_bus* bus = NULL;
++    int ret = sd_bus_default_system(&bus);
++    if (ret < 0)
++    {
++        sd_bus_unref(bus);
++        return false;
++    }
++    sdbusplus::bus::bus dbus(bus);
++    static sdbusplus::bus::match::match sensorAdded(
++        dbus,
++        "type='signal',member='InterfacesAdded',arg0path='/xyz/openbmc_project/"
++        "sensors/'",
++        [](sdbusplus::message::message& m) { sensorTreePtr.reset(); });
++
++    static sdbusplus::bus::match::match sensorRemoved(
++        dbus,
++        "type='signal',member='InterfacesRemoved',arg0path='/xyz/"
++        "openbmc_project/sensors/'",
++        [](sdbusplus::message::message& m) { sensorTreePtr.reset(); });
++
++    bool sensorTreeUpdated = false;
++    if (sensorTreePtr)
++    {
++        subtree = sensorTreePtr;
++        return sensorTreeUpdated;
++    }
++
++    sensorTreePtr = std::make_shared<SensorSubTree>();
++
++    auto mapperCall =
++        dbus.new_method_call("xyz.openbmc_project.ObjectMapper",
++                             "/xyz/openbmc_project/object_mapper",
++                             "xyz.openbmc_project.ObjectMapper", "GetSubTree");
++    static constexpr const auto depth = 2;
++    static constexpr std::array<const char*, 3> interfaces = {
++        "xyz.openbmc_project.Sensor.Value",
++        "xyz.openbmc_project.Sensor.Threshold.Warning",
++        "xyz.openbmc_project.Sensor.Threshold.Critical"};
++    mapperCall.append("/xyz/openbmc_project/sensors", depth, interfaces);
++
++    try
++    {
++        auto mapperReply = dbus.call(mapperCall);
++        mapperReply.read(*sensorTreePtr);
++    }
++    catch (sdbusplus::exception_t& e)
++    {
++        return sensorTreeUpdated;
++    }
++    subtree = sensorTreePtr;
++    sensorTreeUpdated = true;
++    return sensorTreeUpdated;
++}
++
++inline static bool getSensorNumMap(std::shared_ptr<SensorNumMap>& sensorNumMap)
++{
++    static std::shared_ptr<SensorNumMap> sensorNumMapPtr;
++    bool sensorNumMapUpated = false;
++
++    std::shared_ptr<SensorSubTree> sensorTree;
++    bool sensorTreeUpdated = details::getSensorSubtree(sensorTree);
++    if (!sensorTree)
++    {
++        return sensorNumMapUpated;
++    }
++
++    if (!sensorTreeUpdated && sensorNumMapPtr)
++    {
++        sensorNumMap = sensorNumMapPtr;
++        return sensorNumMapUpated;
++    }
++
++    sensorNumMapPtr = std::make_shared<SensorNumMap>();
++
++    uint8_t sensorNum = 0;
++    for (const auto& sensor : *sensorTree)
++    {
++        sensorNumMapPtr->insert(
++            SensorNumMap::value_type(sensorNum++, sensor.first));
++    }
++    sensorNumMap = sensorNumMapPtr;
++    sensorNumMapUpated = true;
++    return sensorNumMapUpated;
++}
++} // namespace details
++
++inline static bool getSensorSubtree(SensorSubTree& subtree)
++{
++    std::shared_ptr<SensorSubTree> sensorTree;
++    details::getSensorSubtree(sensorTree);
++    if (!sensorTree)
++    {
++        return false;
++    }
++
++    subtree = *sensorTree;
++    return true;
++}
++
++struct CmpStr
++{
++    bool operator()(const char* a, const char* b) const
++    {
++        return std::strcmp(a, b) < 0;
++    }
++};
++
++enum class SensorTypeCodes : uint8_t
++{
++    reserved = 0x0,
++    temperature = 0x1,
++    voltage = 0x2,
++    current = 0x3,
++    fan = 0x4,
++    processor = 0x07,
++    power_supply = 0x08,
++    power_unit = 0x09,
++    event_disabled = 0x10,
++    pwr_button = 0x14,
++    restart = 0x1d,
++    acpi = 0x22,
++    watchdog2 = 0x23,
++    mgtsubsyshealth = 0x28,
++    versionchange = 0x2b,
++    fru_state = 0x2c,
++    other = 0xB,
++};
++
++const static boost::container::flat_map<const char*, SensorTypeCodes, CmpStr>
++    sensorTypes{{{"temperature", SensorTypeCodes::temperature},
++                 {"voltage", SensorTypeCodes::voltage},
++                 {"current", SensorTypeCodes::current},
++                 {"fan_tach", SensorTypeCodes::fan},
++                 {"fan_pwm", SensorTypeCodes::fan},
++                 {"processor", SensorTypeCodes::processor},   
++                 {"power_supply", SensorTypeCodes::power_supply},
++                 {"power_unit", SensorTypeCodes::power_unit},
++                 {"event_disabled", SensorTypeCodes::event_disabled},
++                 {"pwr_button", SensorTypeCodes::pwr_button},   
++                 {"restart", SensorTypeCodes::restart},  
++                 {"acpi", SensorTypeCodes::acpi},     
++                 {"watchdog2", SensorTypeCodes::watchdog2},
++                 {"mgtsubsyshealth", SensorTypeCodes::mgtsubsyshealth}, 
++                 {"versionchange", SensorTypeCodes::versionchange},     
++                 {"fru_state", SensorTypeCodes::fru_state},
++                 {"pattern", SensorTypeCodes::other},
++                 {"power", SensorTypeCodes::other}}};
++
++inline static std::string getSensorTypeStringFromPath(const std::string& path)
++{
++    // get sensor type string from path, path is defined as
++    // /xyz/openbmc_project/sensors/<type>/label
++    size_t typeEnd = path.rfind("/");
++    if (typeEnd == std::string::npos)
++    {
++        return path;
++    }
++    size_t typeStart = path.rfind("/", typeEnd - 1);
++    if (typeStart == std::string::npos)
++    {
++        return path;
++    }
++    // Start at the character after the '/'
++    typeStart++;
++    return path.substr(typeStart, typeEnd - typeStart);
++}
++
++inline static std::string getSensorNameStringFromPath(const std::string& path)
++{
++    // get sensor name string from path, path is defined as
++    // /xyz/openbmc_project/sensors/type/<label>
++    size_t typeEnd = path.rfind("/");
++    if (typeEnd == std::string::npos)
++    {
++        return path;
++    }
++    size_t typeStart = path.rfind("/", typeEnd);
++    if (typeStart == std::string::npos)
++    {
++        return path;
++    }
++    // Start at the character after the '/'
++    typeStart++;
++    return path.substr(typeStart, typeEnd - typeStart);
++}
++
++inline static uint8_t getSensorTypeFromPath(const std::string& path)
++{
++    uint8_t sensorType = 0;
++    std::string type = getSensorTypeStringFromPath(path);
++    auto findSensor = sensorTypes.find(type.c_str());
++    if (findSensor != sensorTypes.end())
++    {
++        sensorType = static_cast<uint8_t>(findSensor->second);
++    } // else default 0x0 RESERVED
++
++    return sensorType;
++}
++
++inline static uint8_t getSensorNumberFromPath(const std::string& path)
++{
++    std::shared_ptr<SensorNumMap> sensorNumMapPtr;
++    details::getSensorNumMap(sensorNumMapPtr);
++    if (!sensorNumMapPtr)
++    {
++        return 0xFF;
++    }
++
++#if 0
++    //ray__ print map
++    for (auto& sensor : *sensorNumMapPtr) {
++             std::cerr << sensor.left << " " << sensor.right <<  "\n";
++    }
++#endif 
++
++    try
++    {
++        return sensorNumMapPtr->right.at(path);
++    }
++    catch (std::out_of_range& e)
++    {
++        return 0xFF;
++    }
++}
++
++inline static uint8_t getSensorEventTypeFromPath(const std::string& path)
++{
++    // TODO: Add support for additional reading types as needed
++    //return 0x1; // reading type = threshold
++    uint8_t selType = getSensorTypeFromPath(path);
++    
++    return ((selType > 0x04) && (selType != 0x0b)) ? 0x6f:0x1;
++   
++}
++
++inline static std::string getPathFromSensorNumber(uint8_t sensorNum)
++{
++    std::shared_ptr<SensorNumMap> sensorNumMapPtr;
++    details::getSensorNumMap(sensorNumMapPtr);
++    if (!sensorNumMapPtr)
++    {
++        return std::string();
++    }
++
++    try
++    {
++        return sensorNumMapPtr->left.at(sensorNum);
++    }
++    catch (std::out_of_range& e)
++    {
++        return std::string();
++    }
++}
++
++std::string getEventType(uint8_t eventType)
++{
++    uint8_t eventTypeSplit = (eventType & 0x7f);
++    
++    if (eventTypeSplit == 0)
++            return "Unspecified";
++    if (eventTypeSplit == 1)
++            return "Threshold";
++    if (eventTypeSplit >= 0x02 && eventTypeSplit <= 0x0b)
++            return "Generic Discrete";
++    if (eventTypeSplit == 0x6f)
++            return "Sensor-specific Discrete";
++    if (eventTypeSplit >= 0x70 && eventTypeSplit <= 0x7f)
++            return "OEM";
++    return "Reserved";
++}
++
++std::string ipmiGetGenericSensorType(uint8_t sensorType)
++{
++    std::string sensorTypeStr;
++	if (sensorType <= SENSOR_TYPE_MAX) {
++        sensorTypeStr = ipmiGenericSensorTypeVals[sensorType]; 
++	}
++
++	return sensorTypeStr;
++}
++
++const struct ipmiEventSensorTypes *
++ipmiGetFirstEventSensorType(uint8_t sensorType, uint8_t eventType)
++{
++    const struct ipmiEventSensorTypes *evt, *start, *next = NULL;
++    uint8_t code;
++
++    if (eventType == 0x6f) {
++        /* check generic sensor types */
++        start = sensorSpecificEventTypes;
++        code = sensorType;
++    } else {
++        start = genericEventTypes;
++        code = eventType;
++    }
++
++    for (evt = start; evt->desc || next; evt++) {
++        /* check if VITA sensor event types has finished */
++        if (!evt->desc) {
++            /* proceed with next table */
++            evt = next;
++            next = NULL;
++        }
++
++        if (code == evt->code){
++            return evt;
++        }
++    }
++
++    return NULL;
++}
++
++const struct ipmiEventSensorTypes *
++ipmiGetNextEventSensorType(const struct ipmiEventSensorTypes *evt)
++{
++    const struct ipmiEventSensorTypes *start = evt;
++
++    for (evt = start + 1; evt->desc; evt++) {
++        if (evt->code == start->code) {
++            return evt;
++        }
++    }
++
++    return NULL;
++}
++
++std::string getEventDesc(uint8_t sensorType, uint8_t eventType, uint8_t eventData1,
++                        uint8_t eventData2)
++{
++    const struct ipmiEventSensorTypes *evt = NULL;
++    uint8_t eventTypeSplit = (eventType & 0x7f);
++    std::string desc;
++
++    uint8_t offset = eventData1 & 0xf;
++
++    for (evt = ipmiGetFirstEventSensorType(sensorType, eventTypeSplit);
++         evt; evt = ipmiGetNextEventSensorType(evt))
++    {
++        if ((evt->offset == offset && evt->desc) &&
++            ((evt->data == ALL_OFFSETS_SPECIFIED) ||
++             ((eventData1 & DATA_BYTE2_SPECIFIED_MASK) &&
++              (evt->data == eventData2))))
++        {
++            desc = evt->desc;
++            return desc;
++        }
++    }
++
++    return desc;
++}
++
++bool checkEventExist(std::string logEntry)
++{
++    if (std::find(logEntryBuffer.begin(), logEntryBuffer.end(),logEntry)!=logEntryBuffer.end())
++    {
++        return true;
++    }
++
++    logEntryBuffer.push_back(logEntry);
++    return false;
++
++}
++
++void clearEventBuffer()
++{
++    logEntryBuffer.clear();
++}
++
++static int fromHexStr(const std::string hexStr, std::vector<uint8_t>& data)
++{
++    for (unsigned int i = 0; i < hexStr.size(); i += 2)
++    {
++        try
++        {
++            data.push_back(static_cast<uint8_t>(
++                std::stoul(hexStr.substr(i, 2), nullptr, 16)));
++        }
++        catch (std::invalid_argument& e)
++        {
++            return -1;
++        }
++        catch (std::out_of_range& e)
++        {
++            return -1;
++        }
++    }
++    return 0;
++}
++
++template <class T>
++std::string hexToSring(T input,bool header)
++{
++  const char *hex = "0123456789ABCDEF";
++  std::stringstream ss;
++  if(header)
++  {
++     ss << "0x";
++  }
++  for(int i=sizeof(T)*2;i>0;i--)
++  {
++      ss << hex[input >> 4*(i-1) & 0xF];
++  }
++
++  return ss.str();
++}
++
++void SELEntryHandler(std::vector<std::string>& logEntryFields, MessageID messageID,
++                    uint8_t recordType, uint16_t generatorID, uint8_t evmRev,
++                    uint8_t sensorType, uint8_t sensorNum, uint8_t eventType,
++                    uint8_t eventData1, uint8_t eventData2, uint8_t eventData3)
++{
++    std::string eventDir;
++    if(eventType & 0x80)
++    {
++        eventDir = "Deassertion";
++    }
++    else
++    {
++        eventDir = "Assertion";
++    }
++
++    logEntryFields.insert(logEntryFields.end(),"reserved");
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(recordType,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint16_t>(generatorID,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(evmRev,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(sensorType,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(sensorNum,true));
++    logEntryFields.insert(logEntryFields.end(),eventDir);
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>((eventType & 0x7f),true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(eventData1,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(eventData2,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(eventData3,true));
++}
++
++void SELEntryOKHandler(std::vector<std::string>& logEntryFields, MessageID messageID,
++                    uint8_t recordType, uint16_t generatorID, uint8_t evmRev,
++                    uint8_t sensorType, uint8_t sensorNum, uint8_t eventType,
++                    uint8_t eventData1, uint8_t eventData2, uint8_t eventData3)
++{
++    std::string eventDir;
++    std::string connection;
++    std::string path;
++    std::string sensorStr;
++    std::string sensorTypeStr;
++
++    if(eventType & 0x80)
++    {
++        eventDir = "Deassertion";
++    }
++    else
++    {
++        eventDir = "Assertion";
++    }
++
++    path = getPathFromSensorNumber(sensorNum);
++
++    if (path.empty())
++    {
++        sensorStr = hexToSring<uint8_t>(sensorNum,true);
++    }
++    else
++    {
++        sensorStr = getSensorNameStringFromPath(path);
++    }
++
++    sensorTypeStr = ipmiGetGenericSensorType(sensorType);
++
++    if(sensorTypeStr.empty())
++    {
++        sensorTypeStr = hexToSring<uint8_t>(sensorType,true);
++    }
++
++    logEntryFields.insert(logEntryFields.end(),"reserved");
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(recordType,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint16_t>(generatorID,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(evmRev,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(eventData1,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(eventData2,true));
++    logEntryFields.insert(logEntryFields.end(),hexToSring<uint8_t>(eventData3,true));
++    logEntryFields.insert(logEntryFields.end(),sensorTypeStr);
++    logEntryFields.insert(logEntryFields.end(),sensorStr);
++    logEntryFields.insert(logEntryFields.end(),eventDir);
++    logEntryFields.insert(logEntryFields.end(),getEventType(eventType));
++    logEntryFields.insert(logEntryFields.end(),getEventDesc(sensorType,eventType,eventData1,eventData2));
++
++}
++
++MessageID setMessageID(uint8_t eventType, uint8_t eventData1)
++{
++    uint8_t eventTypeSplit = (eventType & 0x7f);
++    MessageID messageID = MessageID::SELEntry;
++
++    if(eventTypeSplit == 0x01)
++    {
++        switch(eventData1  & 0x0f)
++        {
++            case 0x02:
++            case 0x03:
++            case 0x04:
++            case 0x05:
++            case 0x08:
++            case 0x09:
++            case 0x0A:
++            case 0x0B:
++                messageID = MessageID::SELEntryCritical;
++                break;
++            case 0x00:
++            case 0x01:
++            case 0x06:
++                messageID = MessageID::SELEntryWarning;
++                break;
++            default:
++                messageID = MessageID::SELEntry;
++                break;
++        }
++    }
++    else if((0x02 <= eventTypeSplit) && (eventTypeSplit <= 0x0C))
++    {
++        messageID = MessageID::SELEntryOK;
++    }
++    else if(eventTypeSplit == 0x6f)
++    {
++        messageID = MessageID::SELEntryOK;
++    }
++    else
++    {
++        messageID = MessageID::SELEntry;
++    }
++    return messageID;
++}
++
++void setmessageArgs(std::vector<std::string>& logEntryFields, MessageID messageID,
++                    uint8_t recordType, uint16_t generatorID, uint8_t evmRev,
++                    uint8_t sensorType, uint8_t sensorNum, uint8_t eventType,
++                    uint8_t eventData1, uint8_t eventData2, uint8_t eventData3)
++{
++    switch (messageID)
++    {
++        case MessageID::SELEntry:
++            SELEntryHandler(logEntryFields, messageID, recordType,
++                            generatorID, evmRev, sensorType,
++                            sensorNum, eventType, eventData1,
++                            eventData2, eventData3);
++            break;
++        case MessageID::SELEntryOK:
++        case MessageID::SELEntryCritical:
++        case MessageID::SELEntryWarning:
++            SELEntryOKHandler(logEntryFields, messageID, recordType,
++                            generatorID, evmRev, sensorType,
++                            sensorNum, eventType, eventData1,
++                            eventData2, eventData3);
++            break;
++        default:
++            SELEntryHandler(logEntryFields, messageID, recordType,
++                            generatorID, evmRev, sensorType,
++                            sensorNum, eventType, eventData1,
++                            eventData2, eventData3);
++            break;
++    }
++}
++
++bool clearSEL()
++{
++    static constexpr auto ipmiBusName = "xyz.openbmc_project.Logging.IPMI";
++    static constexpr auto ipmiObjPath = "/xyz/openbmc_project/Logging/IPMI";
++    static constexpr auto ipmiIntf = "xyz.openbmc_project.Logging.IPMI";
++    static constexpr char const* eventCleared= "/xyz/openbmc_project/sensors/event_disabled/EVENT_CLEARED";
++    std::vector<uint8_t> eventData{0x02,0xFF,0xff};
++
++    auto bus = sdbusplus::bus::new_default();
++    uint16_t genid = 0x20;
++    bool assert=1;
++
++    auto method = bus.new_method_call(ipmiBusName, ipmiObjPath, ipmiIntf, "IpmiSelAdd");
++    method.append("SEL Entry",  std::string(eventCleared), eventData, assert, genid);
++
++    try
++    {
++        bus.call(method);
++    }
++    catch (sdbusplus::exception_t& e)
++    {
++       return false;
++    }
++
++    return true;
++}
+\ No newline at end of file
+diff --git a/redfish-core/include/registries.hpp b/redfish-core/include/registries.hpp
+old mode 100644
+new mode 100755
+index e326323..4b18809
+--- a/redfish-core/include/registries.hpp
++++ b/redfish-core/include/registries.hpp
+@@ -36,7 +36,7 @@ struct Message
+     const char* severity;
+     const char* messageSeverity;
+     const size_t numberOfArgs;
+-    std::array<const char*, 5> paramTypes;
++    std::array<const char*, 15> paramTypes;
+     const char* resolution;
+ };
+ using MessageEntry = std::pair<const char*, const Message>;
+diff --git a/redfish-core/include/registries/openbmc_message_registry.hpp b/redfish-core/include/registries/openbmc_message_registry.hpp
+old mode 100644
+new mode 100755
+index 5eb9380..04e2a83
+--- a/redfish-core/include/registries/openbmc_message_registry.hpp
++++ b/redfish-core/include/registries/openbmc_message_registry.hpp
+@@ -29,7 +29,7 @@ const Header header = {
+     "0.1.0",
+     "OpenBMC",
+ };
+-constexpr std::array<MessageEntry, 187> registry = {
++constexpr std::array<MessageEntry, 191> registry = {
+     MessageEntry{
+         "ADDDCCorrectable",
+         {
+@@ -2165,6 +2165,105 @@ constexpr std::array<MessageEntry, 187> registry = {
+                      },
+                      "None.",
+                  }},
++    MessageEntry{"SELEntry",
++                 {
++                     "Indicates a SEL entry was added using the "
++                     "Add SEL Entry or Platform Event command.",
++                     "Record Type:%1, Generator ID:%2, EvM Rev:%3, "
++                     "Sensor Type:%4, Sensor:%5, Event Dir:%6, Event Type:%7, "
++                     "Event Data {1,2,3}:{%8,%9,%10}",
++                     "OK",
++                     "OK",
++                     10,
++                     {
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string"
++                     },
++                     "None.",
++                 }},
++    MessageEntry{"SELEntryOK",
++                 {
++                     "Indicates a SEL entry was added using the "
++                     "Add SEL Entry or Platform Event command.",
++                     "Record Type:%1, Generator ID:%2, EvM Rev:%3, "
++                     "Event Data {1,2,3}:{%4,%5,%6}, Sensor Type:%7, Sensor:%8, "
++                     "Event Direction:%9, Event Type:%10, Description: %11",
++                     "OK",
++                     "OK",
++                     11,
++                     {
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string"
++                     },
++                     "None.",
++                 }},
++    MessageEntry{"SELEntryCritical",
++                 {
++                     "Indicates a SEL entry was added using the "
++                     "Add SEL Entry or Platform Event command.",
++                     "Record Type:%1, Generator ID:%2, EvM Rev:%3, "
++                     "Event Data {1,2,3}:{%4,%5,%6}, Sensor Type:%7, Sensor:%8, "
++                     "Event Direction:%9, Event Type:%10, Description: %11",
++                     "Critical",
++                     "Critical",
++                     11,
++                     {
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string"
++                     },
++                     "None.",
++                 }},
++    MessageEntry{"SELEntryWarning",
++                 {
++                     "Indicates a SEL entry was added using the "
++                     "Add SEL Entry or Platform Event command.",
++                     "Record Type:%1, Generator ID:%2, EvM Rev:%3, "
++                     "Event Data {1,2,3}:{%4,%5,%6}, Sensor Type:%7, Sensor:%8, "
++                     "Event Direction:%9, Event Type:%10, Description: %11",
++                     "Warning",
++                     "Warning",
++                     11,
++                     {
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string",
++                         "string"
++                     },
++                     "None.",
++                 }},
+     MessageEntry{"SensorThresholdCriticalHighGoingHigh",
+                  {
+                      "Indicates that a threshold sensor has crossed a "
+diff --git a/redfish-core/lib/log_services.hpp b/redfish-core/lib/log_services.hpp
+old mode 100644
+new mode 100755
+index 0e93f5c..d428da1
+--- a/redfish-core/lib/log_services.hpp
++++ b/redfish-core/lib/log_services.hpp
+@@ -33,9 +33,15 @@
+ #include <string_view>
+ #include <variant>
+ 
++#include <logutils.hpp>
++
+ namespace redfish
+ {
+ 
++#define RESPONSE_OK     0x00
++#define RESPONSE_END    0x01
++#define RESPONSE_IGNORE 0x02
++
+ constexpr char const* crashdumpObject = "com.intel.crashdump";
+ constexpr char const* crashdumpPath = "/com/intel/crashdump";
+ constexpr char const* crashdumpInterface = "com.intel.crashdump";
+@@ -387,10 +393,9 @@ static bool getTimestampFromID(crow::Response& res, const std::string& entryID,
+ }
+ 
+ static bool
+-    getRedfishLogFiles(std::vector<std::filesystem::path>& redfishLogFiles)
++    getRedfishLogFiles(std::vector<std::filesystem::path>& redfishLogFiles, const std::string redfishLogFilename)
+ {
+-    static const std::filesystem::path redfishLogDir = "/var/log";
+-    static const std::string redfishLogFilename = "redfish";
++    static const std::filesystem::path redfishLogDir = "/var/lib/ipmi";
+ 
+     // Loop through the directory looking for redfish log files
+     for (const std::filesystem::directory_entry& dirEnt :
+@@ -1053,14 +1058,23 @@ class JournalEventLogClear : public Node
+     }
+ 
+   private:
+-    void doPost(crow::Response& res, const crow::Request&,
++    void doPost(crow::Response& res, const crow::Request& req,
+                 const std::vector<std::string>&) override
+     {
+         std::shared_ptr<AsyncResp> asyncResp = std::make_shared<AsyncResp>(res);
+ 
+         // Clear the EventLog by deleting the log files
+         std::vector<std::filesystem::path> redfishLogFiles;
+-        if (getRedfishLogFiles(redfishLogFiles))
++        if (getRedfishLogFiles(redfishLogFiles, "redfish"))
++        {
++            for (const std::filesystem::path& file : redfishLogFiles)
++            {
++                std::error_code ec;
++                std::filesystem::remove(file, ec);
++            }
++        }
++
++        if (getRedfishLogFiles(redfishLogFiles, "ipmi_sel"))
+         {
+             for (const std::filesystem::path& file : redfishLogFiles)
+             {
+@@ -1069,6 +1083,22 @@ class JournalEventLogClear : public Node
+             }
+         }
+ 
++        static boost::asio::steady_timer timeout(*req.ioService);
++        timeout.expires_after(std::chrono::seconds(3));
++        timeout.async_wait([asyncResp](const boost::system::error_code& ec) {
++            if (ec)
++            {
++                // operation_aborted is expected if timer is canceled before
++                // completion.
++                if (ec != boost::asio::error::operation_aborted)
++                {
++                    BMCWEB_LOG_ERROR << "Async_wait failed " << ec;
++                }
++                return;
++            }
++            clearSEL();
++        });
++
+         // Reload rsyslog so it knows to start new log files
+         crow::connections::systemBus->async_method_call(
+             [asyncResp](const boost::system::error_code ec) {
+@@ -1096,14 +1126,14 @@ static int fillEventLogEntryJson(const std::string& logEntryID,
+     size_t space = logEntry.find_first_of(" ");
+     if (space == std::string::npos)
+     {
+-        return 1;
++        return RESPONSE_END;
+     }
+     std::string timestamp = logEntry.substr(0, space);
+     // Then get the log contents
+     size_t entryStart = logEntry.find_first_not_of(" ", space);
+     if (entryStart == std::string::npos)
+     {
+-        return 1;
++        return RESPONSE_END;
+     }
+     std::string_view entry(logEntry);
+     entry.remove_prefix(entryStart);
+@@ -1114,13 +1144,80 @@ static int fillEventLogEntryJson(const std::string& logEntryID,
+     // We need at least a MessageId to be valid
+     if (logEntryFields.size() < 1)
+     {
+-        return 1;
++        return RESPONSE_END;
+     }
+-    std::string& messageID = logEntryFields[0];
++    std::string messageID = logEntryFields[0];
++
++    std::string entryType;
++    std::string name;
++    MessageID messageIDBuffer;
++    std::string messageBuffer;
+ 
++    if (messageID.find("OpenBMC")==std::string::npos)
++    {
++        //Workaround for rsyslog record same record ID
++        if(checkEventExist(logEntryFields[0]))
++        {
++            return RESPONSE_IGNORE;
++        }
++
++        entryType = "SEL";
++
++        name = "Log Entry " + logEntryFields[0];
++
++        std::string eventDataStr = logEntryFields[2];
++        std::vector<uint8_t> eventDataBytes;
++        fromHexStr(eventDataStr, eventDataBytes);
++
++        uint8_t recordType = std::stoul(logEntryFields[1], nullptr, 16);
++
++        if(eventDataBytes.size() > 3)
++        {
++            uint16_t generatorID = (eventDataBytes[1] << 8) + eventDataBytes[0];
++            messageID = hexToSring<uint8_t>(eventDataBytes[eventDataBytes.size()-4],true)+
++              hexToSring<uint8_t>(eventDataBytes[6],false)+
++              hexToSring<uint8_t>(eventDataBytes[7],false)+
++              hexToSring<uint8_t>(eventDataBytes[8],false);
++            messageIDBuffer = setMessageID(eventDataBytes[5],eventDataBytes[6]);
++            messageBuffer = MessageIDToString(messageIDBuffer);
++            logEntryFields.clear();
++            setmessageArgs(logEntryFields, messageIDBuffer, recordType, generatorID, eventDataBytes[2],
++                           eventDataBytes[3], eventDataBytes[4],eventDataBytes[5], eventDataBytes[6],
++                           eventDataBytes[7], eventDataBytes[8]);
++        }
++        else
++        {
++            std::string sensorPath = logEntryFields[4];
++            bool eventDir = std::stoul(logEntryFields[5]) ? 0 : 1;
++            uint8_t sensorType = getSensorTypeFromPath(sensorPath);
++            uint8_t sensorNum = getSensorNumberFromPath(sensorPath);
++            uint8_t eventType = (getSensorEventTypeFromPath(sensorPath) & 0x7f);
++            uint16_t generatorID = std::stoul(logEntryFields[3], nullptr, 16);
++            uint8_t evmRev = 0x04;
++
++            eventType = ((eventDir << 7) | eventType);
++
++            messageID = hexToSring<uint8_t>(eventType,true)+
++                hexToSring<uint8_t>(eventDataBytes[0],false)+
++                hexToSring<uint8_t>(eventDataBytes[1],false)+
++                hexToSring<uint8_t>(eventDataBytes[2],false);
++            messageIDBuffer = setMessageID(eventType,eventDataBytes[0]);
++            messageBuffer = MessageIDToString(messageIDBuffer);
++            logEntryFields.clear();
++            setmessageArgs(logEntryFields, messageIDBuffer, recordType, generatorID, evmRev,
++                           sensorType, sensorNum, eventType, eventDataBytes[0],
++                           eventDataBytes[1], eventDataBytes[2]);
++        }
++    }
++    else
++    {
++        entryType = "Event";
++        name = "System Event Log Entry";
++        messageBuffer = messageID;
++    }
+     // Get the Message from the MessageRegistry
+     const message_registries::Message* message =
+-        message_registries::getMessage(messageID);
++        message_registries::getMessage(messageBuffer);
+ 
+     std::string msg;
+     std::string severity;
+@@ -1173,15 +1270,15 @@ static int fillEventLogEntryJson(const std::string& logEntryID,
+         {"@odata.id",
+          "/redfish/v1/Systems/system/LogServices/EventLog/Entries/" +
+              logEntryID},
+-        {"Name", "System Event Log Entry"},
++        {"Name", std::move(name)},
+         {"Id", logEntryID},
+         {"Message", std::move(msg)},
+         {"MessageId", std::move(messageID)},
+         {"MessageArgs", std::move(messageArgs)},
+-        {"EntryType", "Event"},
++        {"EntryType", std::move(entryType)},
+         {"Severity", std::move(severity)},
+         {"Created", std::move(timestamp)}};
+-    return 0;
++    return RESPONSE_OK;
+ }
+ 
+ class JournalEventLogEntryCollection : public Node
+@@ -1228,10 +1325,13 @@ class JournalEventLogEntryCollection : public Node
+         logEntryArray = nlohmann::json::array();
+         // Go through the log files and create a unique ID for each entry
+         std::vector<std::filesystem::path> redfishLogFiles;
+-        getRedfishLogFiles(redfishLogFiles);
++        getRedfishLogFiles(redfishLogFiles, "redfish");
++        getRedfishLogFiles(redfishLogFiles, "ipmi_sel");
+         uint64_t entryCount = 0;
+         std::string logEntry;
+ 
++        clearEventBuffer();
++
+         // Oldest logs are in the last file, so start there and loop backwards
+         for (auto it = redfishLogFiles.rbegin(); it < redfishLogFiles.rend();
+              it++)
+@@ -1267,11 +1367,17 @@ class JournalEventLogEntryCollection : public Node
+ 
+                 logEntryArray.push_back({});
+                 nlohmann::json& bmcLogEntry = logEntryArray.back();
+-                if (fillEventLogEntryJson(idStr, logEntry, bmcLogEntry) != 0)
++                int ret = fillEventLogEntryJson(idStr, logEntry, bmcLogEntry);
++                if (ret == RESPONSE_END)
+                 {
+                     messages::internalError(asyncResp->res);
+                     return;
+                 }
++                else if(ret == RESPONSE_IGNORE)
++                {
++                    entryCount--;
++                    logEntryArray.erase(logEntryArray.end()-1);
++                }
+             }
+         }
+         asyncResp->res.jsonValue["Members@odata.count"] = entryCount;
+@@ -1317,9 +1423,12 @@ class JournalEventLogEntry : public Node
+         // Go through the log files and check the unique ID for each entry to
+         // find the target entry
+         std::vector<std::filesystem::path> redfishLogFiles;
+-        getRedfishLogFiles(redfishLogFiles);
++        getRedfishLogFiles(redfishLogFiles, "redfish");
++        getRedfishLogFiles(redfishLogFiles, "ipmi_sel");
+         std::string logEntry;
+ 
++        clearEventBuffer();
++
+         // Oldest logs are in the last file, so start there and loop backwards
+         for (auto it = redfishLogFiles.rbegin(); it < redfishLogFiles.rend();
+              it++)
+@@ -1347,8 +1456,9 @@ class JournalEventLogEntry : public Node
+ 
+                 if (idStr == targetID)
+                 {
+-                    if (fillEventLogEntryJson(idStr, logEntry,
+-                                              asyncResp->res.jsonValue) != 0)
++                    int ret = fillEventLogEntryJson(idStr, logEntry, asyncResp->res.jsonValue);
++
++                    if (ret == RESPONSE_END)
+                     {
+                         messages::internalError(asyncResp->res);
+                         return;
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/mct_oem_rest.hpp b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/mct_oem_rest.hpp
new file mode 100755
index 0000000..b3a3b01
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb/mct_oem_rest.hpp
@@ -0,0 +1,246 @@
+#pragma once
+#include <app.h>
+#include <tinyxml2.h>
+
+#include <cstdio>
+#include <async_resp.hpp>
+#include <boost/algorithm/string.hpp>
+#include <boost/container/flat_set.hpp>
+#include <boost/uuid/uuid.hpp>
+#include <boost/uuid/uuid_generators.hpp>
+#include <boost/uuid/uuid_io.hpp>
+#include <dbus_singleton.hpp>
+#include <dbus_utility.hpp>
+#include <filesystem>
+#include <fstream>
+#include <memory>
+#include <regex>
+#include <sdbusplus/message/types.hpp>
+#include <sys/stat.h>
+
+
+namespace crow
+{
+namespace mct_oem_rest
+{
+
+using GetSubTreeType = std::vector<
+    std::pair<std::string,
+              std::vector<std::pair<std::string, std::vector<std::string>>>>>;
+
+const char *notFoundMsg = "404 Not Found";
+const char *badReqMsg = "400 Bad Request";
+const char *methodNotAllowedMsg = "405 Method Not Allowed";
+const char *forbiddenMsg = "403 Forbidden";
+const char *methodFailedMsg = "500 Method Call Failed";
+const char *methodOutputFailedMsg = "500 Method Output Error";
+const char *notFoundDesc =
+    "org.freedesktop.DBus.Error.FileNotFound: path or object not found";
+const char *propNotFoundDesc = "The specified property cannot be found";
+const char *noJsonDesc = "No JSON object could be decoded";
+const char *methodNotFoundDesc = "The specified method cannot be found";
+const char *methodNotAllowedDesc = "Method not allowed";
+const char *forbiddenPropDesc = "The specified property cannot be created";
+const char *forbiddenResDesc = "The specified resource cannot be created";
+
+std::unique_ptr<sdbusplus::bus::match::match> fwUpdateMatcher;
+
+inline void solLogHandler(const crow::Request& req, crow::Response& res)
+{
+    std::filesystem::path loc("/var/log/obmc-console.log");
+    std::ifstream readFile(loc);
+
+    if (!std::filesystem::exists(loc) || std::filesystem::is_empty(loc) ||
+        !std::filesystem::is_regular_file(loc))
+    {
+        BMCWEB_LOG_ERROR << loc << "SOL data Not found";
+        res.result(boost::beast::http::status::not_found);
+        res.end();
+        return;
+    }
+
+    if (readFile.good())
+    {
+        res.addHeader("Content-Type", "application/octet-stream");
+        res.body() = {std::istreambuf_iterator<char>(readFile),
+                      std::istreambuf_iterator<char>()};
+        res.end();
+        return;
+    }
+    else
+    {
+        res.result(boost::beast::http::status::not_found);
+        res.end();
+        return;
+    }
+}
+
+inline void crashdumpsHandler(const crow::Request& req, crow::Response& res)
+{
+    std::vector<std::string> crashdumpslist;
+    nlohmann::json crashdumpslistData;
+    std::string path = "/tmp/crashdump/output";
+
+    if(std::filesystem::exists(std::filesystem::path(path))){
+        for (const auto & entry : std::filesystem::directory_iterator(path))
+        {
+            if(entry.path().filename().string().find("json",0) == std::string::npos)
+            {
+                continue;
+            }
+            std::ifstream ifs(entry.path().string());
+            nlohmann::json crashdumpsData = nlohmann::json::parse(ifs);
+            crashdumpslist.push_back(entry.path().filename().string());
+            crashdumpslistData.push_back({entry.path().filename().string(),crashdumpsData});
+        }
+    }
+
+    res.addHeader("Content-Type", "application/json");
+
+    res.jsonValue = {{"status", "ok"},
+                     {"message", "200 OK"},
+                     {"list", std::move(crashdumpslist)},
+                     {"data", std::move(crashdumpslistData)}
+                     };
+    res.end();
+}
+
+inline void uploadBiosHandler(const crow::Request& req, crow::Response& res,
+                               const std::string& filename)
+{
+    std::cout << "uploadBiosHandlers\n";
+    // Only allow one FW update at a time
+    if (fwUpdateMatcher != nullptr)
+    {
+        res.addHeader("Retry-After", "30");
+        res.result(boost::beast::http::status::service_unavailable);
+        res.end();
+        return;
+    }
+    // Make this const static so it survives outside this method
+    static boost::asio::deadline_timer timeout(*req.ioService,
+                                               boost::posix_time::seconds(5));
+
+    timeout.expires_from_now(boost::posix_time::seconds(15));
+
+    auto timeoutHandler = [&res](const boost::system::error_code& ec) {
+        fwUpdateMatcher = nullptr;
+        if (ec == boost::asio::error::operation_aborted)
+        {
+            // expected, we were canceled before the timer completed.
+            return;
+        }
+        BMCWEB_LOG_ERROR << "Timed out waiting for Version interface";
+
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR << "Async_wait failed " << ec;
+            return;
+        }
+          std::cout << "timeoutHandler\n";
+        res.jsonValue = {{"data", 
+                           {{"description",
+                                "done"}}},
+                        {"message", "200 OK"},
+                        {"status", "ok"}};
+        BMCWEB_LOG_DEBUG << "ending response";
+        res.end();
+        fwUpdateMatcher = nullptr;
+ 
+    };
+
+    std::function<void(sdbusplus::message::message&)> callback =
+        [&res](sdbusplus::message::message& m) {
+            BMCWEB_LOG_DEBUG << "Match fired";
+
+            sdbusplus::message::object_path path;
+            std::vector<std::pair<
+                std::string,
+                std::vector<std::pair<std::string, std::variant<std::string>>>>>
+                interfaces;
+            m.read(path, interfaces);
+
+            if (std::find_if(interfaces.begin(), interfaces.end(),
+                             [](const auto& i) {
+                                 return i.first ==
+                                        "xyz.openbmc_project.Software.Version";
+                             }) != interfaces.end())
+            {
+                boost::system::error_code ec;
+                timeout.cancel(ec);
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR << "error canceling timer " << ec;
+                }
+
+                std::size_t index = path.str.rfind('/');
+                if (index != std::string::npos)
+                {
+                    path.str.erase(0, index + 1);
+                }
+                res.jsonValue = {{"data", std::move(path.str)},
+                                 {"message", "200 OK"},
+                                 {"status", "ok"}};
+                BMCWEB_LOG_DEBUG << "ending response";
+                res.end();
+                fwUpdateMatcher = nullptr;
+            }
+        };
+    /*
+    fwUpdateMatcher = std::make_unique<sdbusplus::bus::match::match>(
+        *crow::connections::systemBus,
+        "interface='org.freedesktop.DBus.ObjectManager',type='signal',"
+        "member='InterfacesAdded',path='/xyz/openbmc_project/software'",
+        callback);
+        */
+/*  note, this shared library is not default installell  
+    boost::filesystem::path dir("/tmp/bios/");
+
+    if(!(boost::filesystem::exists(dir))){
+        std::cout<<"Doesn't Exists"<<std::endl;
+
+        if (boost::filesystem::create_directory(dir))
+            std::cout << "....Successfully Created !" << std::endl;
+    }
+*/   
+
+    
+    struct stat sb;
+    if (stat("/tmp/bios", &sb) != 0) {
+        mkdir("/tmp/bios", 0755);
+    }
+
+    std::string filepath(
+        "/tmp/bios/bios.tgz");
+    BMCWEB_LOG_DEBUG << "Writing file to " << filepath;
+    std::ofstream out(filepath, std::ofstream::out | std::ofstream::binary |
+                                    std::ofstream::trunc);
+    out << req.body;
+    out.close();
+    timeout.async_wait(timeoutHandler);
+}
+
+inline void requestRoutes(App& app)
+{
+    BMCWEB_ROUTE(app, "/sol.log")
+        .privileges({"ConfigureManager"})
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request &req, crow::Response &res) {
+            solLogHandler(req, res);
+        });
+
+    BMCWEB_ROUTE(app, "/crashdumps")
+        .privileges({"Login"})
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request &req, crow::Response &res) {
+            crashdumpsHandler(req, res);
+        });
+
+    BMCWEB_ROUTE(app, "/upload/bios")
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req, crow::Response& res) {
+                uploadBiosHandler(req, res, "");
+            });    
+}
+} // namespace mct_oem_rest
+} // namespace crow
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb_git.bbappend
new file mode 100755
index 0000000..76375d9
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/interfaces/bmcweb_git.bbappend
@@ -0,0 +1,29 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRCREV = "65176d3908b27393d81b72284dbebc47055e517c"
+
+DEPENDS += "boost-url"
+
+SRC_URI += "file://mct_oem_rest.hpp;subdir=git/include \
+            file://0001-Support-rest-API-for-MCT-OEM.patch \
+            file://0002-Fix-the-issue-for-update-bmcweb-recipe.patch \
+            file://0003-Implement-the-SEL-feature-for-redfish-log-service.patch \
+            "
+
+# add a user called bmcweb for the server to assume
+# bmcweb is part of group shadow for non-root pam authentication
+#USERADD_PARAM_${PN} = "-r -s /usr/sbin/nologin -d /home/bmcweb -m -G shadow bmcweb"
+
+#GROUPADD_PARAM_${PN} = "web; redfish "
+
+# Enable CPU Log and Raw PECI support
+EXTRA_OECMAKE += "-DBMCWEB_ENABLE_REDFISH_CPU_LOG=ON"
+EXTRA_OECMAKE += "-DBMCWEB_ENABLE_REDFISH_RAW_PECI=ON"
+
+# Enable Redfish BMC Journal support
+EXTRA_OECMAKE += "-DBMCWEB_ENABLE_REDFISH_BMC_JOURNAL=ON"
+EXTRA_OECMAKE += "-DBMCWEB_HTTP_REQ_BODY_LIMIT_MB=128"
+EXTRA_OECMAKE += "-DBMCWEB_INSECURE_ENABLE_REDFISH_FW_TFTP_UPDATE=ON"
+
+# Enable MCT OEM Rest support
+EXTRA_OECMAKE += "-DBMCWEB_ENABLE_MCT_OEM_REST=ON"
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config.bbappend b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config.bbappend
new file mode 100755
index 0000000..994b653
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config.bbappend
@@ -0,0 +1,13 @@
+FILESEXTRAPATHS_prepend_s5549 := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://sdr.json"
+FILES_${PN} += "${datadir}/ipmi-providers/sdr.json"
+
+do_install_append() {
+    install -m 0644 -D ${WORKDIR}/sdr.json \
+    ${D}${datadir}/ipmi-providers/sdr.json
+}
+
+
+
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/channel_config.json b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/channel_config.json
new file mode 100755
index 0000000..6694cb8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/channel_config.json
@@ -0,0 +1,178 @@
+{
+  "0" : {
+    "name" : "IPMB",
+    "is_valid" : true,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "ipmb",
+      "protocol_type" : "ipmb-1.0",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "1" : {
+    "name" : "eth0",
+    "is_valid" : true,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "lan-802.3",
+      "protocol_type" : "ipmb-1.0",
+      "session_supported" : "multi-session",
+      "is_ipmi" : true
+    }
+  },
+  "2" : {
+    "name" : "eth1",
+    "is_valid" : true,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "lan-802.3",
+      "protocol_type" : "ipmb-1.0",
+      "session_supported" : "multi-session",
+      "is_ipmi" : true
+    }
+  },
+  "3" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "4" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "5" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "6" : {
+    "name" : "IPMB",
+    "is_valid" : true,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "ipmb",
+      "protocol_type" : "ipmb-1.0",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "7" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "8" : {
+    "name" : "INTRABMC",
+    "is_valid" : true,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "oem",
+      "protocol_type" : "oem",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "9" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "10" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "11" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "12" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "13" : {
+    "name" : "RESERVED",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "reserved",
+      "protocol_type" : "na",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "14" : {
+    "name" : "SELF",
+    "is_valid" : false,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "ipmb",
+      "protocol_type" : "ipmb-1.0",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  },
+  "15" : {
+    "name" : "SMS",
+    "is_valid" : true,
+    "active_sessions" : 0,
+    "channel_info" : {
+      "medium_type" : "system-interface",
+      "protocol_type" : "kcs",
+      "session_supported" : "session-less",
+      "is_ipmi" : true
+    }
+  }
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dcmi_cap.json b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dcmi_cap.json
new file mode 100755
index 0000000..109acad
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dcmi_cap.json
@@ -0,0 +1,17 @@
+{
+    "PowerManagement": 1,
+    "OOBSecondaryLan": 0,
+    "SerialTMODE": 0,
+    "InBandSystemInterfaceChannel": 1,
+    "SELAutoRollOver": 1,
+    "FlushEntireSELUponRollOver": 0,
+    "RecordLevelSELFlushUponRollOver": 0,
+    "NumberOfSELEntries": 200,
+    "TempMonitoringSamplingFreq":1,
+    "PowerMgmtDeviceSlaveAddress": 0,
+    "BMCChannelNumber": 0,
+    "DeviceRivision": 0,
+    "MandatoryPrimaryLanOOBSupport": 1,
+    "OptionalSecondaryLanOOBSupport": 255,
+    "OptionalSerialOOBMTMODECapability": 255
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dcmi_sensors.json b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dcmi_sensors.json
new file mode 100755
index 0000000..427ae4f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dcmi_sensors.json
@@ -0,0 +1,13 @@
+{
+    "inlet": [
+		{"instance": 1, "dbus": "/xyz/openbmc_project/sensors/temperature/Inlet_Temp", "record_id": 254}
+    ],
+    "baseboard": [
+		{"instance": 1, "dbus": "/xyz/openbmc_project/sensors/temperature/SB_HSC_TEMP", "record_id": 253},
+		{"instance": 1, "dbus": "/xyz/openbmc_project/sensors/temperature/Outlet_Temp", "record_id": 252}
+    ],
+    "cpu": [
+		{"instance": 1, "dbus": "/xyz/openbmc_project/sensors/temperature/P0_Die", "record_id": 17},
+        {"instance": 2, "dbus": "/xyz/openbmc_project/sensors/temperature/P1_Die", "record_id": 20}
+    ]
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dev_id.json b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dev_id.json
new file mode 100755
index 0000000..1f4dad9
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/dev_id.json
@@ -0,0 +1,2 @@
+{"id": 0, "revision": 0, "addn_dev_support": 191,
+    "manuf_id": 6653, "prod_id": 5549, "aux": 1509949440}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/power_reading.json b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/power_reading.json
new file mode 100755
index 0000000..99753de
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/power_reading.json
@@ -0,0 +1,3 @@
+{
+  "path": "/xyz/openbmc_project/sensors/power/PSU0_Output_Power"
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/sdr.json b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/sdr.json
new file mode 100755
index 0000000..e253ade
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-config/sdr.json
@@ -0,0 +1,136 @@
+[    
+    {
+         "ownerId" : "0x1f",
+         "sensorNumber" : "0xed",
+         "sensorType" : "0x12",
+         "sensorName" : "END OF POST"
+    },
+    {
+         "ownerId" : "0x1f",
+         "sensorNumber" : "0xe5",
+         "sensorType" : "0x22",
+         "sensorName" : "POWER OVERRIDE"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x00",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU0_MC0_A0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x04",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU0_MC0_B0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x05",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU0_MC0_B1"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x08",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU0_MC0_C0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x2C",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU0_MC1_D0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x30",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU0_MC1_E0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x31",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU0_MC1_E1"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x34",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU0_MC1_F0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x40",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU1_MC0_A0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x44",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU1_MC0_B0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x45",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU1_MC0_B1"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x48",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU1_MC0_C0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x6C",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU1_MC1_D0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x70",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU1_MC1_E0"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x71",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU1_MC1_E1"
+    },
+    {
+         "ownerId" : "0x3f",
+         "sensorNumber" : "0x74",
+         "sensorType" : "0x0C",
+         "sensorName" : "CPU1_MC1_F0"
+    },
+    {
+        "ownerId" : "0x2c",
+        "sensorNumber" : "0x08",
+        "sensorType" : "0x01",
+        "sensorName" : "PCH_temperature"
+    },
+    {
+         "ownerId" : "0x2c",
+         "sensorNumber" : "0x17",
+         "sensorType" : "0xDC",
+         "sensorName" : "ME_FW_Health"
+     },
+     {
+         "ownerId" : "0x2c",
+         "sensorNumber" : "0x80",
+         "sensorType" : "0x21",
+         "sensorName" : "USB_Status"
+     },
+     {
+         "ownerId" : "0x20",
+         "sensorNumber" : "0xfe",
+         "sensorType" : "0x2b",
+         "sensorName" : "IB BMC FW UPDATE"
+     }
+
+]
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0004-Implement-NMI-command-in-Chassis-Control-command.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0004-Implement-NMI-command-in-Chassis-Control-command.patch
new file mode 100755
index 0000000..69c562b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0004-Implement-NMI-command-in-Chassis-Control-command.patch
@@ -0,0 +1,57 @@
+From 7c7135f51f9f48cef759c13d109be32654799c29 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 10 Dec 2019 22:54:32 +0800
+Subject: [PATCH 1/1] Implement NMI command in Chassis Control command
+
+---
+ chassishandler.cpp | 27 +++++++++++++++++++++++++++
+ 1 file changed, 27 insertions(+)
+
+diff --git a/chassishandler.cpp b/chassishandler.cpp
+index 0c8bdcb..8c509b3 100755
+--- a/chassishandler.cpp
++++ b/chassishandler.cpp
+@@ -783,6 +783,7 @@ int initiate_state_transition(State::Host::Transition transition)
+ //------------------------------------------
+ int setNmiProperty(const bool value)
+ {
++#if 0    
+     constexpr const char* nmiSourceObjPath =
+         "/xyz/openbmc_project/Chassis/Control/NMISource";
+     constexpr const char* nmiSourceIntf =
+@@ -807,6 +808,32 @@ int setNmiProperty(const bool value)
+     }
+ 
+     return 0;
++#endif 
++    char command[100];
++    int rc = 0;
++ 
++    sprintf(command, "echo 317 > /sys/class/gpio/export");
++    rc = system(command);
++    if (rc != 0)
++    {
++        return rc;
++    }
++ 
++    sprintf(command, "echo out > /sys/class/gpio/gpio317/direction; sleep 1; echo in > /sys/class/gpio/gpio317/direction;");
++    rc = system(command);
++    if (rc != 0)
++    {
++        return rc;
++    }
++ 
++    sprintf(command, "echo 317 > /sys/class/gpio/unexport");
++    rc = system(command);
++    if (rc != 0)
++    {
++        return rc;
++    }
++ 
++    return rc;
+ }
+ 
+ namespace power_policy
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0005-ipmi-move-Unspecified-ip-source-from-static-to-D.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0005-ipmi-move-Unspecified-ip-source-from-static-to-D.patch
new file mode 100755
index 0000000..4cdb11a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0005-ipmi-move-Unspecified-ip-source-from-static-to-D.patch
@@ -0,0 +1,30 @@
+From 1415a8ed64e3b5170a1db68a30dc071f03c2530d Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 11 Dec 2019 21:12:34 +0800
+Subject: [PATCH] ipmi: move Unspecified ip source from static to DHCP.
+
+Tested: set ip source to unspecified and BMC should keep ip to DHCP -> PASS
+---
+ transporthandler.cpp | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+ mode change 100644 => 100755 transporthandler.cpp
+
+diff --git a/transporthandler.cpp b/transporthandler.cpp
+old mode 100644
+new mode 100755
+index 1a06ae5..0c7bb93
+--- a/transporthandler.cpp
++++ b/transporthandler.cpp
+@@ -1394,11 +1394,11 @@ RspType<> setLan(uint4_t channelBits, uint4_t, uint8_t parameter,
+             switch (static_cast<IPSrc>(static_cast<uint8_t>(flag)))
+             {
+                 case IPSrc::DHCP:
++                case IPSrc::Unspecified:    
+                 {
+                     channelCall<setDHCPProperty>(channel, true);
+                     return responseSuccess();
+                 }
+-                case IPSrc::Unspecified:
+                 case IPSrc::Static:
+                 case IPSrc::BIOS:
+                 case IPSrc::BMC:
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0006-add-power-diag-log.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0006-add-power-diag-log.patch
new file mode 100755
index 0000000..c73e5da
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0006-add-power-diag-log.patch
@@ -0,0 +1,44 @@
+From 4c3cfec00fa373f31f2c03745c0de87b9350c0c3 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 22 Jan 2020 15:35:23 +0800
+Subject: [PATCH] add power diag log
+
+---
+ chassishandler.cpp | 24 ++++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+diff --git a/chassishandler.cpp b/chassishandler.cpp
+index 8c509b3..1f44888 100755
+--- a/chassishandler.cpp
++++ b/chassishandler.cpp
+@@ -1245,6 +1245,30 @@ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
+             break;
+ 
+         case CMD_PULSE_DIAGNOSTIC_INTR:
++            { //variable scope
++            static constexpr char const* ipmiSELService =    "xyz.openbmc_project.Logging.IPMI";
++            static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
++            static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
++            static constexpr char const* fruStateSensorPath= "/xyz/openbmc_project/sensors/fru_state/IPMI_Power_Diag";
++            
++            std::shared_ptr<sdbusplus::asio::connection> busp = getSdBus();
++
++            uint16_t genid = 0x20;
++            bool assert=1;
++            std::vector<uint8_t> eventData{0x02, 0x22, 0xff};
++               
++            sdbusplus::message::message writeSEL = busp->new_method_call(
++                            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++            writeSEL.append("SEL Entry",  std::string(fruStateSensorPath), eventData, assert,genid);            
++            try
++            {
++                busp->call(writeSEL);
++            }
++            catch (sdbusplus::exception_t& e)
++            {
++                std::cerr << "call IpmiSelAdd failed\n";
++            }
++            }
+             rc = setNmiProperty(true);
+             break;
+ 
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0007-fix-set-static-ip-fail-issue.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0007-fix-set-static-ip-fail-issue.patch
new file mode 100755
index 0000000..a87f5a8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0007-fix-set-static-ip-fail-issue.patch
@@ -0,0 +1,24 @@
+From 0ec824f31f2568300b2d685a5d8c3a12572cf1d2 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Thu, 23 Jan 2020 09:06:16 +0800
+Subject: [PATCH] fix set static ip fail issue
+
+---
+ transporthandler.cpp | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/transporthandler.cpp b/transporthandler.cpp
+index 0c7bb93..4e4ad52 100755
+--- a/transporthandler.cpp
++++ b/transporthandler.cpp
+@@ -773,7 +773,9 @@ void deleteObjectIfExists(sdbusplus::bus::bus& bus, const std::string& service,
+         if (strcmp(e.name(), "org.freedesktop.DBus.Error.UnknownObject") != 0)
+         {
+             // We want to rethrow real errors
+-            throw;
++            //throw;
++            log<level::ERR>("org.freedesktop.DBus.Error.UnknownObject",
++                         entry("ERROR=%s", e.what()));
+         }
+     }
+ }
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0008-add-ARP-control-status.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0008-add-ARP-control-status.patch
new file mode 100755
index 0000000..2e681f7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0008-add-ARP-control-status.patch
@@ -0,0 +1,45 @@
+From 19a4ee948fdf45160eb162e24f4d210ec4f917c0 Mon Sep 17 00:00:00 2001
+From: "terry.chang" <terry.chang@mic.com.tw>
+Date: Thu, 13 Feb 2020 15:06:35 +0800
+Subject: [PATCH] add ARP control status
+
+---
+ transporthandler.cpp | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
+
+diff --git a/transporthandler.cpp b/transporthandler.cpp
+index 4e4ad52..add8519 100755
+--- a/transporthandler.cpp
++++ b/transporthandler.cpp
+@@ -180,6 +180,7 @@ enum class LanParam : uint8_t
+     IPSrc = 4,
+     MAC = 5,
+     SubnetMask = 6,
++    ARPControl = 10,
+     Gateway1 = 12,
+     Gateway1MAC = 13,
+     VLANId = 20,
+@@ -1475,6 +1476,10 @@ RspType<> setLan(uint4_t channelBits, uint4_t, uint8_t parameter,
+             channelCall<reconfigureVLAN>(channel, vlanData & VLAN_VALUE_MASK);
+             return responseSuccess();
+         }
++        case LanParam::ARPControl:
++        {
++            return responseInvalidFieldRequest();
++        }
+         case LanParam::CiphersuiteSupport:
+         case LanParam::CiphersuiteEntries:
+         case LanParam::IPFamilySupport:
+@@ -1750,6 +1755,12 @@ RspType<message::Payload> getLan(uint4_t channelBits, uint3_t, bool revOnly,
+             ret.pack(vlan);
+             return responseSuccess(std::move(ret));
+         }
++        case LanParam::ARPControl:
++        {
++            uint8_t arpCtrl = 0x2;
++            ret.pack(arpCtrl);
++            return responseSuccess(std::move(ret));
++        }
+         case LanParam::CiphersuiteSupport:
+         {
+             if (!listInit)
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0009-change-ipmit-power-reset-from-dc-cycle-to-reset.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0009-change-ipmit-power-reset-from-dc-cycle-to-reset.patch
new file mode 100755
index 0000000..e482c26
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0009-change-ipmit-power-reset-from-dc-cycle-to-reset.patch
@@ -0,0 +1,29 @@
+From b6502e266c977324d89b117efcfa5d8087a0cde1 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 30 Apr 2020 11:26:51 +0800
+Subject: [PATCH 1/1] change ipmit power reset from dc cycle to reset
+
+---
+ chassishandler.cpp | 3 +++
+ 1 file changed, 3 insertions(+)
+ mode change 100644 => 100755 chassishandler.cpp
+
+diff --git a/chassishandler.cpp b/chassishandler.cpp
+old mode 100644
+new mode 100755
+index af3c414..d634e5e
+--- a/chassishandler.cpp
++++ b/chassishandler.cpp
+@@ -1239,6 +1239,9 @@ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
+             break;
+ 
+         case CMD_HARD_RESET:
++            rc = initiate_state_transition(State::Host::Transition::ForceWarmReboot);
++            break;
++            
+         case CMD_POWER_CYCLE:
+             // SPEC has a section that says certain implementations can trigger
+             // PowerOn if power is Off when a command to power cycle is
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0010-Fix-BIOS-boot-type-setting-in-system-boot-option-fea.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0010-Fix-BIOS-boot-type-setting-in-system-boot-option-fea.patch
new file mode 100755
index 0000000..aba5556
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0010-Fix-BIOS-boot-type-setting-in-system-boot-option-fea.patch
@@ -0,0 +1,48 @@
+From 738a3b28b158ea743596a71effd5974c9985e17e Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 30 Apr 2020 13:55:23 +0800
+Subject: [PATCH] Fix BIOS boot type setting in system boot option feature
+
+It's a workaround for this feature
+---
+ chassishandler.cpp | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/chassishandler.cpp b/chassishandler.cpp
+index d634e5e..918e4be 100755
+--- a/chassishandler.cpp
++++ b/chassishandler.cpp
+@@ -1518,6 +1518,7 @@ static ipmi_ret_t setBootMode(const Mode::Modes& mode)
+     return IPMI_CC_OK;
+ }
+ 
++static bool uefiboot = true;
+ ipmi_ret_t ipmi_chassis_get_sys_boot_options(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+                                              ipmi_request_t request,
+                                              ipmi_response_t response,
+@@ -1608,6 +1609,8 @@ ipmi_ret_t ipmi_chassis_get_sys_boot_options(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+                                 ? SET_PARM_BOOT_FLAGS_VALID_ONE_TIME
+                                 : SET_PARM_BOOT_FLAGS_VALID_PERMANENT;
+ 
++            if(uefiboot) resp->data[0]|=0x20;
++
+             rc = IPMI_CC_OK;
+         }
+         catch (InternalFailure& e)
+@@ -1658,6 +1661,7 @@ ipmi_ret_t ipmi_chassis_get_sys_boot_options(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+     return rc;
+ }
+ 
++
+ ipmi_ret_t ipmi_chassis_set_sys_boot_options(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+                                              ipmi_request_t request,
+                                              ipmi_response_t response,
+@@ -1689,6 +1693,8 @@ ipmi_ret_t ipmi_chassis_set_sys_boot_options(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+         constexpr auto oneTimePath =
+             "/xyz/openbmc_project/control/host0/boot/one_time";
+ 
++        uefiboot = reqptr->data[0] & 0x20 ? true:false;
++
+         try
+         {
+             bool permanent =
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0011-fix-warm-reset-command.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0011-fix-warm-reset-command.patch
new file mode 100755
index 0000000..f487c68
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0011-fix-warm-reset-command.patch
@@ -0,0 +1,40 @@
+From 17b9f3b650465cecaee9ef6ef8c0396055bab05d Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Thu, 7 May 2020 14:59:43 +0800
+Subject: [PATCH] fix warm reset command
+
+---
+ globalhandler.cpp | 4 ++++
+ globalhandler.hpp | 1 +
+ 2 files changed, 5 insertions(+)
+ mode change 100644 => 100755 globalhandler.cpp
+ mode change 100644 => 100755 globalhandler.hpp
+
+diff --git a/globalhandler.cpp b/globalhandler.cpp
+old mode 100644
+new mode 100755
+index c192cbb..f6b24ac
+--- a/globalhandler.cpp
++++ b/globalhandler.cpp
+@@ -59,5 +59,9 @@ void register_netfn_global_functions()
+     ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnApp,
+                           ipmi::app::cmdColdReset, ipmi::Privilege::Admin,
+                           ipmiGlobalReset);
++    // Warm Reset
++    ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnApp,
++                          ipmi::app::cmdWarmReset, ipmi::Privilege::Admin,
++                          ipmiGlobalReset);
+     return;
+ }
+diff --git a/globalhandler.hpp b/globalhandler.hpp
+old mode 100644
+new mode 100755
+index 078b170..23d3b3e
+--- a/globalhandler.hpp
++++ b/globalhandler.hpp
+@@ -6,4 +6,5 @@
+ enum ipmi_global_control_cmds : uint8_t
+ {
+     IPMI_CMD_COLD_RESET = 0x02,
++    IPMI_CMD_WARM_RESET = 0x03,
+ };
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0012-Fix-expiration-flags-unexpected-status-in-get-watchd.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0012-Fix-expiration-flags-unexpected-status-in-get-watchd.patch
new file mode 100755
index 0000000..12a4b5a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0012-Fix-expiration-flags-unexpected-status-in-get-watchd.patch
@@ -0,0 +1,30 @@
+From 6b45ff7b5437f928d4e25d630e376bf89087fadb Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 20 May 2020 11:58:57 +0800
+Subject: [PATCH] Fix expiration flags unexpected status in get watchdog
+ command
+
+---
+ app/watchdog.cpp | 3 +++
+ 1 file changed, 3 insertions(+)
+ mode change 100644 => 100755 app/watchdog.cpp
+
+diff --git a/app/watchdog.cpp b/app/watchdog.cpp
+old mode 100644
+new mode 100755
+index 03c373e..fca27b7
+--- a/app/watchdog.cpp
++++ b/app/watchdog.cpp
+@@ -391,6 +391,9 @@ ipmi::RspType<uint3_t, // timerUse - timer use
+             timerUseExpirationFlags.set(static_cast<uint8_t>(
+                 wdTimerUseToIpmiTimerUse(wd_prop.expiredTimerUse)));
+         }
++        else{
++            timerUseExpirationFlags=0x00;
++        }
+ 
+         if (wd_prop.enabled)
+         {
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0013-Implement-power-control-SEL-generated-in-chassis-con.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0013-Implement-power-control-SEL-generated-in-chassis-con.patch
new file mode 100755
index 0000000..cd3103b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0013-Implement-power-control-SEL-generated-in-chassis-con.patch
@@ -0,0 +1,130 @@
+From 39123934de5b3b1077b6af0b7e4b439aae7ef99e Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Fri, 22 May 2020 11:50:28 +0800
+Subject: [PATCH] Implement power control SEL generated in chassis control
+ command
+
+---
+ chassishandler.cpp | 63 +++++++++++++++++++++++++++++++++++-------------------
+ 1 file changed, 41 insertions(+), 22 deletions(-)
+
+diff --git a/chassishandler.cpp b/chassishandler.cpp
+index a312656..269a690 100755
+--- a/chassishandler.cpp
++++ b/chassishandler.cpp
+@@ -793,6 +793,33 @@ int initiate_state_transition(State::Host::Transition transition)
+     return rc;
+ }
+ 
++//-----------------------------------------------
++// Calls IpmiSelAdd Dbus method to generate a SEL
++//-----------------------------------------------
++void generateSELEvent(char const* SensorPath,std::vector<uint8_t> eventData)
++{
++    static constexpr char const* ipmiSELService =    "xyz.openbmc_project.Logging.IPMI";
++    static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
++    static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
++
++    std::shared_ptr<sdbusplus::asio::connection> busp = getSdBus();
++
++    uint16_t genid = 0x20;
++    bool assert=1;
++
++    sdbusplus::message::message writeSEL = busp->new_method_call(
++                            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++    writeSEL.append("SEL Entry",  std::string(SensorPath), eventData, assert,genid);
++    try
++    {
++        busp->call(writeSEL);
++    }
++    catch (sdbusplus::exception_t& e)
++    {
++        std::cerr << "call IpmiSelAdd failed\n";
++    }
++}
++
+ //------------------------------------------
+ // Set Enabled property to inform NMI source
+ // handling to trigger a NMI_OUT BSOD.
+@@ -1197,10 +1224,19 @@ void indicate_no_softoff_needed()
+  */
+ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
+ {
++    static constexpr char const* fruStatePowerCycle= "/xyz/openbmc_project/sensors/fru_state/IPMI_POWER_CYCLE";
++    static constexpr char const* fruStatePowerOn= "/xyz/openbmc_project/sensors/fru_state/IPMI_POWER_ON";
++    static constexpr char const* fruStatePowerOff= "/xyz/openbmc_project/sensors/fru_state/IPMI_POWER_OFF";
++    static constexpr char const* fruStatePowerSoft= "/xyz/openbmc_project/sensors/fru_state/IPMI_POWER_SOFT";
++    static constexpr char const* fruStatePowerReset= "/xyz/openbmc_project/sensors/fru_state/IPMI_POWER_RESET";
++    static constexpr char const* fruStateSensorPath= "/xyz/openbmc_project/sensors/fru_state/IPMI_Power_Diag";
++    std::vector<uint8_t> powerControlEventData{0x02,0x01,0xff};
+     int rc = 0;
++
+     switch (chassisControl)
+     {
+         case CMD_POWER_ON:
++            generateSELEvent(fruStatePowerOn,powerControlEventData);
+             rc = initiate_state_transition(State::Host::Transition::On);
+             break;
+         case CMD_POWER_OFF:
+@@ -1229,6 +1265,7 @@ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
+                 indicate_no_softoff_needed();
+ 
+                 // Now request the shutdown
++                generateSELEvent(fruStatePowerOff,powerControlEventData);
+                 rc = initiate_state_transition(State::Host::Transition::Off);
+             }
+             else
+@@ -1239,6 +1276,7 @@ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
+             break;
+ 
+         case CMD_HARD_RESET:
++            generateSELEvent(fruStatePowerReset,powerControlEventData);
+             rc = initiate_state_transition(State::Host::Transition::ForceWarmReboot);
+             break;
+             
+@@ -1252,39 +1290,20 @@ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
+             // power reboot request (i.e. a reboot request that is not
+             // originating via a soft power off SMS request)
+             indicate_no_softoff_needed();
+-
++            generateSELEvent(fruStatePowerCycle,powerControlEventData);
+             rc = initiate_state_transition(State::Host::Transition::Reboot);
+             break;
+ 
+         case CMD_SOFT_OFF_VIA_OVER_TEMP:
+             // Request Host State Manager to do a soft power off
++            generateSELEvent(fruStatePowerSoft,powerControlEventData);
+             rc = initiate_state_transition(State::Host::Transition::Off);
+             break;
+ 
+         case CMD_PULSE_DIAGNOSTIC_INTR:
+             { //variable scope
+-            static constexpr char const* ipmiSELService =    "xyz.openbmc_project.Logging.IPMI";
+-            static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
+-            static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
+-            static constexpr char const* fruStateSensorPath= "/xyz/openbmc_project/sensors/fru_state/IPMI_Power_Diag";
+-            
+-            std::shared_ptr<sdbusplus::asio::connection> busp = getSdBus();
+-
+-            uint16_t genid = 0x20;
+-            bool assert=1;
+             std::vector<uint8_t> eventData{0x02, 0x22, 0xff};
+-               
+-            sdbusplus::message::message writeSEL = busp->new_method_call(
+-                            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+-            writeSEL.append("SEL Entry",  std::string(fruStateSensorPath), eventData, assert,genid);            
+-            try
+-            {
+-                busp->call(writeSEL);
+-            }
+-            catch (sdbusplus::exception_t& e)
+-            {
+-                std::cerr << "call IpmiSelAdd failed\n";
+-            }
++            generateSELEvent(fruStateSensorPath,eventData);
+             }
+             rc = setNmiProperty(true);
+             break;
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0014-Implement-the-DCMI-power-reading-and-power-limit-com.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0014-Implement-the-DCMI-power-reading-and-power-limit-com.patch
new file mode 100755
index 0000000..cbab622
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0014-Implement-the-DCMI-power-reading-and-power-limit-com.patch
@@ -0,0 +1,403 @@
+From 34d7bebe422bc98607065841aa853c023a0561e3 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Fri, 29 May 2020 14:14:39 +0800
+Subject: [PATCH] Implement the DCMI power reading and power limit command
+
+---
+ dcmihandler.cpp | 231 +++++++++++++++++++++++++++++++++++++++++++++++++++++---
+ dcmihandler.hpp |  37 +++++++++
+ 2 files changed, 259 insertions(+), 9 deletions(-)
+ mode change 100644 => 100755 dcmihandler.cpp
+ mode change 100644 => 100755 dcmihandler.hpp
+
+diff --git a/dcmihandler.cpp b/dcmihandler.cpp
+old mode 100644
+new mode 100755
+index f8498f5..a35e592
+--- a/dcmihandler.cpp
++++ b/dcmihandler.cpp
+@@ -7,6 +7,7 @@
+ #include <bitset>
+ #include <cmath>
+ #include <fstream>
++#include <chrono>
+ #include <ipmid/api.hpp>
+ #include <ipmid/utils.hpp>
+ #include <nlohmann/json.hpp>
+@@ -15,18 +16,33 @@
+ #include <sdbusplus/bus.hpp>
+ #include <variant>
+ #include <xyz/openbmc_project/Common/error.hpp>
++#include <xyz/openbmc_project/Control/Power/Cap/server.hpp>
+ 
+ using namespace phosphor::logging;
+ using InternalFailure =
+     sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure;
++using PowerLimit =
++    sdbusplus::xyz::openbmc_project::Control::Power::server::Cap;
+ 
+ void register_netfn_dcmi_functions() __attribute__((constructor));
+ 
+ constexpr auto PCAP_PATH = "/xyz/openbmc_project/control/host0/power_cap";
+ constexpr auto PCAP_INTERFACE = "xyz.openbmc_project.Control.Power.Cap";
++constexpr auto HOST_TIME_PATH = "/xyz/openbmc_project/time/host";
++constexpr auto TIME_INTERFACE = "xyz.openbmc_project.Time.EpochTime";
++constexpr auto POWER_PATH = "/xyz/openbmc_project/DCMI/Power";
++constexpr auto POWER_INTERFACE = "xyz.openbmc_project.DCMI.Value";
++
+ 
+ constexpr auto POWER_CAP_PROP = "PowerCap";
+ constexpr auto POWER_CAP_ENABLE_PROP = "PowerCapEnable";
++constexpr auto EXCEPTION_ACTION_PROP = "ExceptionAction";
++constexpr auto CORRECTION_TIME_PROP = "CorrectionTime";
++constexpr auto SAMPLING_PERIOD_PROP = "SamplingPeriod";
++constexpr auto PROPERTY_ELAPSED = "Elapsed";
++constexpr auto PERIOD_MAX_VALUE = "PeriodMaxValue";
++constexpr auto PERIOD_MIN_VALUE = "PeriodMinValue";
++constexpr auto PERIOD_AVERAGE_VALUE = "PeriodAverageValue";
+ 
+ constexpr auto DCMI_PARAMETER_REVISION = 2;
+ constexpr auto DCMI_SPEC_MAJOR_VERSION = 1;
+@@ -53,6 +69,10 @@ constexpr auto SENSOR_VALUE_INTF = "xyz.openbmc_project.Sensor.Value";
+ constexpr auto SENSOR_VALUE_PROP = "Value";
+ constexpr auto SENSOR_SCALE_PROP = "Scale";
+ 
++constexpr auto exception_action_none = 0x00;
++constexpr auto exception_action_off_and_log = 0x01;
++constexpr auto exception_action_log = 0x11;
++
+ using namespace phosphor::logging;
+ 
+ namespace dcmi
+@@ -112,6 +132,72 @@ bool getPcapEnabled(sdbusplus::bus::bus& bus)
+     return std::get<bool>(pcapEnabled);
+ }
+ 
++uint8_t getAction(sdbusplus::bus::bus& bus)
++{
++    auto settingService = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
++
++    auto method = bus.new_method_call(settingService.c_str(), PCAP_PATH,
++                                      "org.freedesktop.DBus.Properties", "Get");
++
++    method.append(PCAP_INTERFACE, EXCEPTION_ACTION_PROP);
++    auto reply = bus.call(method);
++
++    if (reply.is_method_error())
++    {
++        log<level::ERR>("Error in getAction prop");
++        elog<InternalFailure>();
++    }
++    std::variant<std::string> result;
++    reply.read(result);
++
++    auto exceptionAction = sdbusplus::message::variant_ns::get<std::string>(result);
++    uint8_t convetExceptionAction;
++
++    switch(PowerLimit::convertActionFromString(exceptionAction))
++    {
++        case PowerLimit::Action::None:
++            convetExceptionAction = exception_action_none;
++            break;
++        case PowerLimit::Action::OffAndLog:
++            convetExceptionAction = exception_action_off_and_log;
++            break;
++        case PowerLimit::Action::Log:
++            convetExceptionAction = exception_action_log;
++            break;
++        default:
++            convetExceptionAction = exception_action_none;
++            break;
++    }
++
++    return convetExceptionAction;
++}
++
++uint32_t getTimeStamp(sdbusplus::bus::bus& bus)
++{
++    using namespace std::chrono;
++    auto service = ipmi::getService(bus, TIME_INTERFACE, HOST_TIME_PATH);
++    std::variant<uint64_t> value;
++    uint64_t host_time_usec = 0;
++
++    // Get host time
++    auto method = bus.new_method_call(service.c_str(), HOST_TIME_PATH,
++                                    "org.freedesktop.DBus.Properties", "Get");
++
++    method.append(TIME_INTERFACE, PROPERTY_ELAPSED);
++    auto reply = bus.call(method);
++    if (reply.is_method_error())
++    {
++        log<level::ERR>("Error getting time",
++                        entry("SERVICE=%s", service.c_str()),
++                        entry("PATH=%s", HOST_TIME_PATH));
++        return 0;
++    }
++    reply.read(value);
++    host_time_usec = std::get<uint64_t>(value);
++
++    return duration_cast<seconds>(microseconds(host_time_usec)).count();
++}
++
+ void setPcap(sdbusplus::bus::bus& bus, const uint32_t powerCap)
+ {
+     auto service = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
+@@ -150,6 +236,80 @@ void setPcapEnable(sdbusplus::bus::bus& bus, bool enabled)
+     }
+ }
+ 
++void setAction(sdbusplus::bus::bus& bus, uint8_t action)
++{
++
++    auto exceptionAction = PowerLimit::Action::None;
++
++    switch(action)
++    {
++        case exception_action_none:
++            exceptionAction = PowerLimit::Action::None;
++            break;
++        case exception_action_off_and_log:
++            exceptionAction = PowerLimit::Action::OffAndLog;
++            break;
++        case exception_action_log:
++            exceptionAction = PowerLimit::Action::Log;
++            break;
++    }
++
++    auto service = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
++
++    auto method = bus.new_method_call(service.c_str(), PCAP_PATH,
++                                      "org.freedesktop.DBus.Properties", "Set");
++
++    method.append(PCAP_INTERFACE, EXCEPTION_ACTION_PROP);
++    method.append(sdbusplus::message::variant<PowerLimit::Action>(exceptionAction));
++
++
++    auto reply = bus.call(method);
++
++    if (reply.is_method_error())
++    {
++        log<level::ERR>("Error in setPcapEnabled property");
++        elog<InternalFailure>();
++    }
++}
++
++void setCorrectionTime(sdbusplus::bus::bus& bus, const uint32_t correctionTime)
++{
++    auto service = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
++
++    auto method = bus.new_method_call(service.c_str(), PCAP_PATH,
++                                      "org.freedesktop.DBus.Properties", "Set");
++
++    method.append(PCAP_INTERFACE, CORRECTION_TIME_PROP);
++    method.append(std::variant<uint32_t>(correctionTime));
++
++    auto reply = bus.call(method);
++
++    if (reply.is_method_error())
++    {
++        log<level::ERR>("Error in setPcap property");
++        elog<InternalFailure>();
++    }
++}
++
++void setSamplingPeriod(sdbusplus::bus::bus& bus, const uint16_t samplingPeriod)
++{
++    auto service = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
++
++    auto method = bus.new_method_call(service.c_str(), PCAP_PATH,
++                                      "org.freedesktop.DBus.Properties", "Set");
++
++    method.append(PCAP_INTERFACE, SAMPLING_PERIOD_PROP);
++    method.append(std::variant<uint16_t>(samplingPeriod));
++
++    auto reply = bus.call(method);
++
++    if (reply.is_method_error())
++    {
++        log<level::ERR>("Error in setPcap property");
++        elog<InternalFailure>();
++    }
++}
++
+ void readAssetTagObjectTree(dcmi::assettag::ObjectTree& objectTree)
+ {
+     static constexpr auto mapperBusName = "xyz.openbmc_project.ObjectMapper";
+@@ -317,11 +477,21 @@ ipmi_ret_t getPowerLimit(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+     sdbusplus::bus::bus sdbus{ipmid_get_sd_bus_connection()};
+     uint32_t pcapValue = 0;
+     bool pcapEnable = false;
++    uint8_t exceptionAction = 0;
++    uint32_t correctionTime = 0;
++    uint16_t samplingPeriod = 0;
+ 
+     try
+     {
+-        pcapValue = dcmi::getPcap(sdbus);
+-        pcapEnable = dcmi::getPcapEnabled(sdbus);
++        auto service = ipmi::getService(sdbus, PCAP_INTERFACE, PCAP_PATH);
++        auto properties = ipmi::getAllDbusProperties(sdbus, service, PCAP_PATH,
++                                                     PCAP_INTERFACE);
++        pcapValue = std::get<uint32_t>(properties[POWER_CAP_PROP]);
++        pcapEnable = std::get<bool>(properties[POWER_CAP_ENABLE_PROP]);
++        exceptionAction = dcmi::getAction(sdbus);
++        correctionTime = std::get<uint32_t>(properties[CORRECTION_TIME_PROP]);
++        samplingPeriod = std::get<uint16_t>(properties[SAMPLING_PERIOD_PROP]);
++
+     }
+     catch (InternalFailure& e)
+     {
+@@ -334,11 +504,15 @@ ipmi_ret_t getPowerLimit(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+      * with the correction time limit is hardcoded to Hard Power Off system
+      * and log event to SEL.
+      */
+-    constexpr auto exception = 0x01;
+-    responseData->exceptionAction = exception;
++
++    responseData->exceptionAction = exceptionAction;
++
++    responseData->correctionTime = correctionTime;
+ 
+     responseData->powerLimit = static_cast<uint16_t>(pcapValue);
+ 
++    responseData->samplingPeriod = samplingPeriod;
++
+     /*
+      * Correction time limit and Statistics sampling period is currently not
+      * populated.
+@@ -377,6 +551,9 @@ ipmi_ret_t setPowerLimit(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+     try
+     {
+         dcmi::setPcap(sdbus, requestData->powerLimit);
++        dcmi::setAction(sdbus, requestData->exceptionAction);
++        dcmi::setCorrectionTime(sdbus, requestData->correctionTime);
++        dcmi::setSamplingPeriod(sdbus, requestData->samplingPeriod);
+     }
+     catch (InternalFailure& e)
+     {
+@@ -1014,8 +1191,9 @@ int64_t getPowerReading(sdbusplus::bus::bus& bus)
+         // Read the sensor value and scale properties
+         auto properties = ipmi::getAllDbusProperties(bus, service, objectPath,
+                                                      SENSOR_VALUE_INTF);
+-        auto value = std::get<int64_t>(properties[SENSOR_VALUE_PROP]);
+-        auto scale = std::get<int64_t>(properties[SENSOR_SCALE_PROP]);
++
++        auto value = std::get<double>(properties[SENSOR_VALUE_PROP]);
++        auto scale = 0;
+ 
+         // Power reading needs to be scaled with the Scale value using the
+         // formula Value * 10^Scale.
+@@ -1199,15 +1377,50 @@ ipmi_ret_t getPowerReading(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
+         return IPMI_CC_UNSPECIFIED_ERROR;
+     }
+ 
++    bool pcapEnable = false;
++    uint16_t samplingPeriod = 0;
++    uint32_t timeStamp = 0;
++    try
++    {
++        auto service = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
++        auto properties = ipmi::getAllDbusProperties(bus, service, PCAP_PATH,
++                                                     PCAP_INTERFACE);
++        pcapEnable = std::get<bool>(properties[POWER_CAP_ENABLE_PROP]);
++        samplingPeriod = std::get<uint16_t>(properties[SAMPLING_PERIOD_PROP]);
++        timeStamp = dcmi::getTimeStamp(bus);
++    }
++    catch (InternalFailure& e)
++    {
++        return IPMI_CC_UNSPECIFIED_ERROR;
++    }
++
++    double periodMaxValue,periodMinValue,periodAverageValue;
++    try
++    {
++        auto powerService = ipmi::getService(bus, POWER_INTERFACE, POWER_PATH);
++        auto powerProperties = ipmi::getAllDbusProperties(bus, powerService, POWER_PATH,
++                                                     POWER_INTERFACE);
++        periodMaxValue = std::get<double>(powerProperties[PERIOD_MAX_VALUE]);
++        periodMinValue = std::get<double>(powerProperties[PERIOD_MIN_VALUE]);
++        periodAverageValue = std::get<double>(powerProperties[PERIOD_AVERAGE_VALUE]);
++    }
++    catch (InternalFailure& e)
++    {
++        return IPMI_CC_UNSPECIFIED_ERROR;
++    }
++
+     // TODO: openbmc/openbmc#2819
+     // Minimum, Maximum, Average power, TimeFrame, TimeStamp,
+     // PowerReadingState readings need to be populated
+     // after Telemetry changes.
+     uint16_t totalPower = static_cast<uint16_t>(power);
+     responseData->currentPower = totalPower;
+-    responseData->minimumPower = totalPower;
+-    responseData->maximumPower = totalPower;
+-    responseData->averagePower = totalPower;
++    responseData->minimumPower = periodMinValue;
++    responseData->maximumPower = periodMaxValue;
++    responseData->averagePower = periodAverageValue;
++    responseData->timeStamp = timeStamp;
++    responseData->timeFrame = static_cast<uint32_t>(samplingPeriod*1000);
++    responseData->powerReadingState = pcapEnable << 6;
+ 
+     *data_len = sizeof(*responseData);
+     return rc;
+diff --git a/dcmihandler.hpp b/dcmihandler.hpp
+old mode 100644
+new mode 100755
+index 4f35bc6..795a0d4
+--- a/dcmihandler.hpp
++++ b/dcmihandler.hpp
+@@ -207,6 +207,22 @@ uint32_t getPcap(sdbusplus::bus::bus& bus);
+  */
+ bool getPcapEnabled(sdbusplus::bus::bus& bus);
+ 
++/** @brief Read the power exception action
++ *
++ *  @param [in] bus - dbus connection
++ *
++ *  @return On success return the power exception action.
++ */
++uint8_t getAction(sdbusplus::bus::bus& bus);
++
++/** @brief Read the current timestamp
++ *
++ *  @param [in] bus - dbus connection
++ *
++ *  @return On success return the current timestamp.
++ */
++uint32_t getTimeStamp(sdbusplus::bus::bus& bus);
++
+ /** @struct GetPowerLimitResponse
+  *
+  *  DCMI payload for Get Power Limit command response.
+@@ -250,6 +266,27 @@ struct SetPowerLimitRequest
+  */
+ void setPcapEnable(sdbusplus::bus::bus& bus, bool enabled);
+ 
++/** @brief Set the power exception action
++ *
++ *  @param[in] bus - dbus connection
++ *  @param[in] action - power exception action value
++ */
++void setAction(sdbusplus::bus::bus& bus, uint8_t action);
++
++/** @brief Set the correction time
++ *
++ *  @param[in] bus - dbus connection
++ *  @param[in] correctionTime - correction time value in milliseconds
++ */
++void setCorrectionTime(sdbusplus::bus::bus& bus, const uint32_t correctionTime);
++
++/** @brief Set the sampling period
++ *
++ *  @param[in] bus - dbus connection
++ *  @param[in] samplingPeriod - sampling period value in second
++ */
++void setSamplingPeriod(sdbusplus::bus::bus& bus, const uint16_t samplingPeriod);
++
+ /** @struct ApplyPowerLimitRequest
+  *
+  *  DCMI payload for Activate/Deactivate Power Limit command request.
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0015-Add-debug-message-for-watchdog-reset.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0015-Add-debug-message-for-watchdog-reset.patch
new file mode 100755
index 0000000..bd22cc7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0015-Add-debug-message-for-watchdog-reset.patch
@@ -0,0 +1,24 @@
+From 2c6865d0a9fe6add72952e80a7e8942a4ca09c48 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 21 Jul 2020 19:39:35 +0800
+Subject: [PATCH] Add debug message for watchdog reset
+
+---
+ app/watchdog.cpp | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/app/watchdog.cpp b/app/watchdog.cpp
+index fca27b7..d87c82d 100755
+--- a/app/watchdog.cpp
++++ b/app/watchdog.cpp
+@@ -58,6 +58,7 @@ ipmi::RspType<> ipmiAppResetWatchdogTimer()
+         // The ipmi standard dictates we enable the watchdog during reset
+         wd_service.resetTimeRemaining(true);
+         lastCallSuccessful = true;
++        std::cerr << "Reset watchdog timer and start counting.\n";
+         return ipmi::responseSuccess();
+     }
+     catch (const InternalFailure& e)
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0016-rewrite-Get-Session-Info-to-use-new-yielding-D-Bus-A.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0016-rewrite-Get-Session-Info-to-use-new-yielding-D-Bus-A.patch
new file mode 100755
index 0000000..0bbfc4a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0016-rewrite-Get-Session-Info-to-use-new-yielding-D-Bus-A.patch
@@ -0,0 +1,380 @@
+From e7e8b8166a1c0e352ee6e0e1daa76abbff228ed6 Mon Sep 17 00:00:00 2001
+From: Vernon Mauery <vernon.mauery@linux.intel.com>
+Date: Mon, 28 Oct 2019 16:00:34 -0700
+Subject: [PATCH] rewrite Get Session Info to use new yielding D-Bus API
+
+The new yielding API does not use try/catch, and has slightly different
+parameters which makes the change look bigger than it is.
+
+Tested:
+  Run ipmitool session info active
+    session handle                : 1
+    slot count                    : 45
+    active sessions               : 1
+    user id                       : 1
+    privilege level               : ADMINISTRATOR
+    session type                  : IPMIv2/RMCP+
+    channel number                : 0x01
+    console ip                    : 0.0.0.0
+    console mac                   : 00:00:00:00:00:00
+    console port                  : 54884
+
+  Console ip is reported as all zero due to a current netipmid bug.
+
+Signed-off-by: Vernon Mauery <vernon.mauery@linux.intel.com>
+Change-Id: Ia6574568c7f8863b3acffcf22e403c8be01d312a
+---
+ apphandler.cpp          | 251 ++++++++++++++++++++++++------------------------
+ include/ipmid/utils.hpp |  27 ++++++
+ 2 files changed, 152 insertions(+), 126 deletions(-)
+
+diff --git a/apphandler.cpp b/apphandler.cpp
+index 2430e8e..fdc2d67 100644
+--- a/apphandler.cpp
++++ b/apphandler.cpp
+@@ -1043,91 +1043,100 @@ uint8_t getSessionInfoRequestData(const ipmi::Context::ptr ctx,
+     return ipmi::ccSuccess;
+ }
+ 
+-uint8_t getSessionState(std::shared_ptr<sdbusplus::asio::connection>& busp,
+-                        const std::string& service, const std::string& objPath,
+-                        uint8_t& sessionState)
++uint8_t getSessionState(ipmi::Context::ptr ctx, const std::string& service,
++                        const std::string& objPath, uint8_t& sessionState)
+ {
+-    try
+-    {
+-        sessionState = std::get<uint8_t>(ipmi::getDbusProperty(
+-            *busp, service, objPath, session::sessionIntf, "State"));
+-    }
+-    catch (sdbusplus::exception::SdBusError& e)
++    boost::system::error_code ec = ipmi::getDbusProperty(
++        ctx, service, objPath, session::sessionIntf, "State", sessionState);
++    if (ec)
+     {
+         log<level::ERR>("Failed to fetch state property ",
+                         entry("SERVICE=%s", service.c_str()),
+                         entry("OBJECTPATH=%s", objPath.c_str()),
+                         entry("INTERFACE=%s", session::sessionIntf),
+-                        entry("ERRMSG=%s", e.what()));
++                        entry("ERRMSG=%s", ec.message().c_str()));
+         return ipmi::ccUnspecifiedError;
+     }
+-
+     return ipmi::ccSuccess;
+ }
+ 
+ static constexpr uint8_t macAddrLen = 6;
+-struct GetSessionInfoRes
+-{
+-    uint8_t sessionHandle;
+-    uint8_t totalSessionCount;
+-    uint8_t activeSessionCount;
+-    uint8_t userID;
+-    uint8_t privLevel;
+-    uint8_t channelNumber;
+-    uint32_t remoteIpAddr;
+-    std::array<uint8_t, macAddrLen> macAddr = {0};
+-    uint16_t remotePort;
+-};
++/** Alias SessionDetails - contain the optional information about an
++ *        RMCP+ session.
++ *
++ *  @param userID - uint6_t session user ID (0-63)
++ *  @param reserved - uint2_t reserved
++ *  @param privilege - uint4_t session privilege (0-5)
++ *  @param reserved - uint4_t reserved
++ *  @param channel - uint4_t session channel number
++ *  @param protocol - uint4_t session protocol
++ *  @param remoteIP - uint32_t remote IP address
++ *  @param macAddr - std::array<uint8_t, 6> mac address
++ *  @param port - uint16_t remote port
++ */
++using SessionDetails =
++    std::tuple<uint2_t, uint6_t, uint4_t, uint4_t, uint4_t, uint4_t, uint32_t,
++               std::array<uint8_t, macAddrLen>, uint16_t>;
+ 
+-uint8_t
+-    fillGetSessionInfoRes(std::shared_ptr<sdbusplus::asio::connection>& busp,
+-                          const std::string& service,
+-                          const std::string& objPath,
+-                          struct GetSessionInfoRes& resp, uint8_t& sessionState)
++/** @brief get session details for a given session
++ *
++ *  @param[in] ctx - ipmi::Context pointer for accessing D-Bus
++ *  @param[in] service - D-Bus service name to fetch details from
++ *  @param[in] objPath - D-Bus object path for session
++ *  @param[out] sessionHandle - return session handle for session
++ *  @param[out] sessionState - return session state for session
++ *  @param[out] details - return a SessionDetails tuple containing other
++ *                        session info
++ *  @return - ipmi::Cc success or error code
++ */
++ipmi::Cc getSessionDetails(ipmi::Context::ptr ctx, const std::string& service,
++                           const std::string& objPath, uint8_t& sessionHandle,
++                           uint8_t& sessionState, SessionDetails& details)
+ {
+-    try
+-    {
+-        ipmi::PropertyMap sessionProps = ipmi::getAllDbusProperties(
+-            *busp, service, objPath, session::sessionIntf);
++    ipmi::PropertyMap sessionProps;
++    boost::system::error_code ec = ipmi::getAllDbusProperties(
++        ctx, service, objPath, session::sessionIntf, sessionProps);
+ 
+-        sessionState = std::get<uint8_t>(sessionProps.at("State"));
+-        if (sessionState == static_cast<uint8_t>(session::State::active))
+-        {
+-            resp.sessionHandle =
+-                std::get<uint8_t>(sessionProps["SessionHandle"]);
+-            resp.userID = std::get<uint8_t>(sessionProps["UserID"]);
+-            resp.privLevel =
+-                std::get<uint8_t>(sessionProps["CurrentPrivilege"]);
+-            resp.channelNumber = std::get<uint8_t>(sessionProps["ChannelNum"]);
+-            resp.remoteIpAddr =
+-                std::get<uint32_t>(sessionProps["RemoteIPAddr"]);
+-            resp.remotePort = std::get<uint16_t>(sessionProps["RemotePort"]);
+-        }
+-    }
+-    catch (sdbusplus::exception::SdBusError& e)
++    if (ec)
+     {
+         log<level::ERR>("Failed to fetch state property ",
+                         entry("SERVICE=%s", service.c_str()),
+                         entry("OBJECTPATH=%s", objPath.c_str()),
+                         entry("INTERFACE=%s", session::sessionIntf),
+-                        entry("ERRMSG=%s", e.what()));
++                        entry("ERRMSG=%s", ec.message().c_str()));
+         return ipmi::ccUnspecifiedError;
+     }
+ 
++    sessionState = ipmi::mappedVariant<uint8_t>(
++        sessionProps, "State", static_cast<uint8_t>(session::State::inactive));
++    if (sessionState == static_cast<uint8_t>(session::State::active))
++    {
++        sessionHandle =
++            ipmi::mappedVariant<uint8_t>(sessionProps, "SessionHandle", 0);
++        std::get<0>(details) =
++            ipmi::mappedVariant<uint8_t>(sessionProps, "UserID", 0xff);
++        // std::get<1>(details) = 0; // (default constructed to 0)
++        std::get<2>(details) =
++            ipmi::mappedVariant<uint8_t>(sessionProps, "CurrentPrivilege", 0);
++        // std::get<3>(details) = 0; // (default constructed to 0)
++        std::get<4>(details) =
++            ipmi::mappedVariant<uint8_t>(sessionProps, "ChannelNum", 0xff);
++        constexpr uint4_t rmcpPlusProtocol = 1;
++        std::get<5>(details) = rmcpPlusProtocol;
++        std::get<6>(details) =
++            ipmi::mappedVariant<uint32_t>(sessionProps, "RemoteIPAddr", 0);
++        // std::get<7>(details) = {{0}}; // default constructed to all 0
++        std::get<8>(details) =
++            ipmi::mappedVariant<uint16_t>(sessionProps, "RemotePort", 0);
++    }
++
+     return ipmi::ccSuccess;
+ }
+ 
+-ipmi::RspType<
+-    uint8_t,                           // session handle,
+-    uint8_t,                           // total session count
+-    uint8_t,                           // active session count
+-    std::optional<std::tuple<uint8_t,  // user ID
+-                             uint8_t,  // privilege level
+-                             uint8_t,  // channel number
+-                             uint32_t, // remote ip address,
+-                             std::array<uint8_t, macAddrLen>, // mac address
+-                             uint16_t                         // remote port
+-                             >>>
++ipmi::RspType<uint8_t, // session handle,
++              uint8_t, // total session count
++              uint8_t, // active session count
++              std::optional<SessionDetails>>
+     ipmiAppGetSessionInfo(ipmi::Context::ptr ctx, uint8_t sessionIndex,
+                           ipmi::message::Payload& payload)
+ {
+@@ -1143,87 +1152,77 @@ ipmi::RspType<
+     {
+         return ipmi::response(completionCode);
+     }
+-    struct GetSessionInfoRes res = {0};
+-    res.totalSessionCount = getTotalSessionCount();
+-    res.activeSessionCount = 0;
+-    auto busp = getSdBus();
++    ipmi::ObjectTree objectTree;
++    boost::system::error_code ec = ipmi::getAllDbusObjects(
++        ctx, session::sessionManagerRootPath, session::sessionIntf, objectTree);
++    if (ec)
++    {
++        log<level::ERR>("Failed to fetch object from dbus",
++                        entry("INTERFACE=%s", session::sessionIntf),
++                        entry("ERRMSG=%s", ec.message().c_str()));
++        return ipmi::responseUnspecifiedError();
++    }
+ 
+-    try
++    uint8_t totalSessionCount = getTotalSessionCount();
++    uint8_t activeSessionCount = 0;
++    uint8_t sessionHandle = session::defaultSessionHandle;
++    std::optional<SessionDetails> maybeDetails;
++    uint8_t index = 0;
++    for (auto& objectTreeItr : objectTree)
+     {
+-        uint8_t index = 0;
+-        ipmi::ObjectTree objectTree = ipmi::getAllDbusObjects(
+-            *busp, session::sessionManagerRootPath, session::sessionIntf);
++        uint32_t sessionId = 0;
++        std::string objectPath = objectTreeItr.first;
+ 
+-        for (auto& objectTreeItr : objectTree)
++        if (!parseCloseSessionInputPayload(objectPath, sessionId,
++                                           sessionHandle))
+         {
+-            uint32_t sessionId = 0;
+-            uint8_t sessionHandle = session::defaultSessionHandle;
+-            std::string objectPath = objectTreeItr.first;
+-
+-            if (!parseCloseSessionInputPayload(objectPath, sessionId,
+-                                               sessionHandle))
+-            {
+-                continue;
+-            }
+-            index++;
+-            auto& serviceMap = objectTreeItr.second;
+-            auto itr = serviceMap.begin();
++            continue;
++        }
++        index++;
++        auto& serviceMap = objectTreeItr.second;
++        auto itr = serviceMap.begin();
+ 
+-            if (serviceMap.size() != 1)
+-            {
+-                return ipmi::responseUnspecifiedError();
+-            }
++        if (serviceMap.size() != 1)
++        {
++            return ipmi::responseUnspecifiedError();
++        }
+ 
+-            std::string service = itr->first;
+-            uint8_t sessionState = 0;
+-            completionCode =
+-                getSessionState(busp, service, objectPath, sessionState);
+-            if (completionCode)
+-            {
+-                return ipmi::response(completionCode);
+-            }
++        std::string service = itr->first;
++        uint8_t sessionState = 0;
++        completionCode =
++            getSessionState(ctx, service, objectPath, sessionState);
++        if (completionCode)
++        {
++            return ipmi::response(completionCode);
++        }
+ 
+-            if (sessionState == static_cast<uint8_t>(session::State::active))
+-            {
+-                res.activeSessionCount++;
+-            }
++        if (sessionState == static_cast<uint8_t>(session::State::active))
++        {
++            activeSessionCount++;
++        }
+ 
+-            if (index != sessionIndex && reqSessionId != sessionId &&
+-                reqSessionHandle != sessionHandle)
+-            {
+-                continue;
+-            }
++        if (index != sessionIndex && reqSessionId != sessionId &&
++            reqSessionHandle != sessionHandle)
++        {
++            continue;
++        }
+ 
+-            completionCode =
+-                fillGetSessionInfoRes(busp, service, objectPath, res, state);
++        SessionDetails details{};
++        completionCode = getSessionDetails(ctx, service, objectPath,
++                                           sessionHandle, state, details);
+ 
+-            if (completionCode)
+-            {
+-                return ipmi::response(completionCode);
+-            }
++        if (completionCode)
++        {
++            return ipmi::response(completionCode);
+         }
++        maybeDetails = std::move(details);
+     }
+ 
+-    catch (sdbusplus::exception::SdBusError& e)
+-    {
+-        log<level::ERR>("Failed to fetch object from dbus",
+-                        entry("INTERFACE=%s", session::sessionIntf),
+-                        entry("ERRMSG=%s", e.what()));
+-        return ipmi::responseUnspecifiedError();
+-    }
+-
+-    if (state == static_cast<uint8_t>(session::State::active))
+-    {
+-        return ipmi::responseSuccess(
+-            res.sessionHandle, res.totalSessionCount, res.activeSessionCount,
+-            std::make_tuple(res.userID, res.privLevel, res.channelNumber,
+-                            res.remoteIpAddr, res.macAddr, res.remotePort));
+-    }
+-    else if (state == static_cast<uint8_t>(session::State::tearDownInProgress))
++    if (state == static_cast<uint8_t>(session::State::active) ||
++        state == static_cast<uint8_t>(session::State::tearDownInProgress))
+     {
+-        res.sessionHandle = 0;
+-        return ipmi::responseSuccess(res.sessionHandle, res.totalSessionCount,
+-                                     res.activeSessionCount, std::nullopt);
++        return ipmi::responseSuccess(sessionHandle, totalSessionCount,
++                                     activeSessionCount, maybeDetails);
+     }
+ 
+     return ipmi::responseInvalidFieldRequest();
+diff --git a/include/ipmid/utils.hpp b/include/ipmid/utils.hpp
+index cd72ec0..b8b59bf 100644
+--- a/include/ipmid/utils.hpp
++++ b/include/ipmid/utils.hpp
+@@ -376,6 +376,33 @@ boost::system::error_code getAllAncestors(Context::ptr ctx,
+ 
+ /********* End co-routine yielding alternatives ***************/
+ 
++/** @brief Retrieve the value from map of variants,
++ *         returning a default if the key does not exist or the
++ *         type of the value does not match the expected type
++ *
++ *  @tparam T - type of expected value to return
++ *  @param[in] props - D-Bus propery map (Map of variants)
++ *  @param[in] name - key name of property to fetch
++ *  @param[in] defaultValue - default value to return on error
++ *  @return - value from propery map at name, or defaultValue
++ */
++template <typename T>
++T mappedVariant(const ipmi::PropertyMap& props, const std::string& name,
++                const T& defaultValue)
++{
++    auto item = props.find(name);
++    if (item == props.end())
++    {
++        return defaultValue;
++    }
++    const T* prop = std::get_if<T>(&item->second);
++    if (!prop)
++    {
++        return defaultValue;
++    }
++    return *prop;
++}
++
+ /** @struct VariantToDoubleVisitor
+  *  @brief Visitor to convert variants to doubles
+  *  @details Performs a static cast on the underlying type
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0017-Fix-the-wrong-field-value-for-session-info-commnad.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0017-Fix-the-wrong-field-value-for-session-info-commnad.patch
new file mode 100755
index 0000000..a3b2ade
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0017-Fix-the-wrong-field-value-for-session-info-commnad.patch
@@ -0,0 +1,212 @@
+From 6df1b000fb5f023892146067c245dacd74caa3a1 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Fri, 21 Aug 2020 10:38:47 +0800
+Subject: [PATCH] Fix the wrong field value for session info commnad
+
+---
+ Makefile.am     |  1 +
+ app/session.cpp | 95 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ app/session.hpp | 38 +++++++++++++++++++++++
+ apphandler.cpp  |  5 +--
+ 4 files changed, 137 insertions(+), 2 deletions(-)
+ mode change 100644 => 100755 Makefile.am
+ create mode 100755 app/session.cpp
+ create mode 100755 app/session.hpp
+ mode change 100644 => 100755 apphandler.cpp
+
+diff --git a/Makefile.am b/Makefile.am
+old mode 100644
+new mode 100755
+index 82fdd5d..4ad4a83
+--- a/Makefile.am
++++ b/Makefile.am
+@@ -95,6 +95,7 @@ libipmi20_la_SOURCES = \
+ 	app/channel.cpp \
+ 	app/watchdog.cpp \
+ 	app/watchdog_service.cpp \
++	app/session.cpp \
+ 	apphandler.cpp \
+ 	sys_info_param.cpp \
+ 	sensorhandler.cpp \
+diff --git a/app/session.cpp b/app/session.cpp
+new file mode 100755
+index 0000000..fc5ce2d
+--- /dev/null
++++ b/app/session.cpp
+@@ -0,0 +1,95 @@
++#include "session.hpp"
++#include <cerrno>
++#include <cstring>
++#include <sys/socket.h>
++#include <sys/ioctl.h>
++#include <net/if_arp.h>
++#include <linux/sockios.h>
++#include <arpa/inet.h>
++
++namespace session
++{
++
++static constexpr bool DEBUG = false;
++
++std::string hexIpToString(uint32_t ip)
++{
++    std::string ipString = "";
++    uint8_t* ptr = (uint8_t*)&ip;
++    for(unsigned int i=0; i < sizeof(uint32_t)/sizeof(uint8_t); i++)
++    {
++        std::string dot = ".";
++        if(!i)
++        {
++            dot = "";
++        }
++        ipString = ipString + dot + std::to_string(*ptr);
++        ptr++;
++    }
++    return ipString;
++}
++
++std::array<uint8_t, macAddrLen> macAddressToArray(struct sockaddr *addr)
++{
++    std::array<uint8_t, macAddrLen> buff;
++
++    uint8_t *ptr = (uint8_t *)addr->sa_data;
++
++    for(int i=0; i < macAddrLen;i++)
++    {
++        buff[i] = ptr[i] & 0xff;
++    }
++
++    return buff;
++}
++
++std::array<uint8_t, macAddrLen> getMacAddress(uint32_t ipAddess)
++{
++    int s;
++    struct arpreq areq;
++    struct sockaddr_in *sin;
++    struct in_addr ipaddr;
++    std::array<uint8_t, macAddrLen> buff = {0};
++    std::string ipAddessString = hexIpToString(ipAddess);
++
++    // Get an internet domain socket.
++    if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
++    {
++        if constexpr (DEBUG){
++            perror("socket");
++        }
++        return buff;
++    }
++
++    // Make the ARP request.
++    memset(&areq, 0, sizeof(areq));
++    sin = (struct sockaddr_in *)&areq.arp_pa;
++    sin->sin_family = AF_INET;
++
++    if (inet_aton(ipAddessString.c_str(), &ipaddr) == 0)
++    {
++        if constexpr (DEBUG){
++            fprintf(stderr, "-- Error: bad dotted-decimal IP '%s'.\n", ipAddessString.c_str());
++        }
++        return buff;
++    }
++
++    sin->sin_addr = ipaddr;
++    sin = (struct sockaddr_in *)&areq.arp_ha;
++    sin->sin_family = ARPHRD_ETHER;
++
++    strncpy(areq.arp_dev, "eth0", 15);
++
++    if (ioctl(s, SIOCGARP, (caddr_t)&areq) == -1)
++    {
++        if constexpr (DEBUG){
++            perror("-- Error: unable to make ARP request, error");
++        }
++        return buff;
++    }
++
++    buff = macAddressToArray(&areq.arp_ha);
++
++    return buff;
++}
++} // namespace session
+\ No newline at end of file
+diff --git a/app/session.hpp b/app/session.hpp
+new file mode 100755
+index 0000000..80564e8
+--- /dev/null
++++ b/app/session.hpp
+@@ -0,0 +1,38 @@
++#pragma once
++
++#include <cstdio>
++#include <cstdlib>
++#include <string>
++#include <array>
++#include <netinet/in.h>
++
++static constexpr uint8_t macAddrLen = 6;
++
++namespace session
++{
++
++/** @brief Translate IP format from uint32_t to std::string
++ *
++ *  @param[in] ip
++ *
++ *  @return IP with using  format std::string.
++ */
++std::string hexIpToString(uint32_t ip);
++
++/** @brief Get the mac address from sockaddr
++ *
++ *  @param[in] addr
++ *
++ *  @return Mac address array.
++ */
++std::array<uint8_t, macAddrLen> macAddressToArray(struct sockaddr *addr);
++
++/** @brief Get the mac address via IP address
++ *
++ *  @param[in] ipAddess
++ *
++ *  @return Mac address array for input IP address.
++ */
++std::array<uint8_t, macAddrLen> getMacAddress(uint32_t ipAddess);
++
++} // namespace session
+\ No newline at end of file
+diff --git a/apphandler.cpp b/apphandler.cpp
+old mode 100644
+new mode 100755
+index fdc2d67..341da07
+--- a/apphandler.cpp
++++ b/apphandler.cpp
+@@ -13,6 +13,7 @@
+ #include <algorithm>
+ #include <app/channel.hpp>
+ #include <app/watchdog.hpp>
++#include <app/session.hpp>
+ #include <apphandler.hpp>
+ #include <array>
+ #include <cstddef>
+@@ -1060,7 +1061,6 @@ uint8_t getSessionState(ipmi::Context::ptr ctx, const std::string& service,
+     return ipmi::ccSuccess;
+ }
+ 
+-static constexpr uint8_t macAddrLen = 6;
+ /** Alias SessionDetails - contain the optional information about an
+  *        RMCP+ session.
+  *
+@@ -1125,7 +1125,8 @@ ipmi::Cc getSessionDetails(ipmi::Context::ptr ctx, const std::string& service,
+         std::get<5>(details) = rmcpPlusProtocol;
+         std::get<6>(details) =
+             ipmi::mappedVariant<uint32_t>(sessionProps, "RemoteIPAddr", 0);
+-        // std::get<7>(details) = {{0}}; // default constructed to all 0
++        std::get<7>(details) =
++            session::getMacAddress(std::get<6>(details));
+         std::get<8>(details) =
+             ipmi::mappedVariant<uint16_t>(sessionProps, "RemotePort", 0);
+     }
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0018-Add-the-detect-for-firmare-revision.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0018-Add-the-detect-for-firmare-revision.patch
new file mode 100755
index 0000000..0bbbdee
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0018-Add-the-detect-for-firmare-revision.patch
@@ -0,0 +1,29 @@
+From 67015df9ec87ccaaa90777ff57bcf39cbcd0e64d Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 27 Aug 2020 16:01:37 +0800
+Subject: [PATCH] Add the detect for firmare revision
+
+---
+ apphandler.cpp | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/apphandler.cpp b/apphandler.cpp
+index 341da07..6077a58 100755
+--- a/apphandler.cpp
++++ b/apphandler.cpp
+@@ -623,6 +623,12 @@ ipmi::RspType<uint8_t,  // Device ID
+             std::memcpy(&devId.aux, rev.d, 4);
+         }
+ 
++        if(devId.fw[0] == 0x00 && devId.fw[1] == 0x00)
++        {
++            dev_id_initialized = false;
++            return ipmi::responseCommandNotAvailable();
++        }
++
+         // IPMI Spec version 2.0
+         devId.ipmiVer = 2;
+ 
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0019-block-power-control-until-pervious-action-completed.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0019-block-power-control-until-pervious-action-completed.patch
new file mode 100755
index 0000000..4cd25c1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host/0019-block-power-control-until-pervious-action-completed.patch
@@ -0,0 +1,155 @@
+From 8239d22d4bf99e10e150ddb9bfd5b9128394dc48 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 30 Sep 2020 11:08:26 +0800
+Subject: [PATCH 1/1] block power control until pervious action is completed
+
+---
+ chassishandler.cpp | 100 +++++++++++++++++++++++++++++++++++++++++++--
+ 1 file changed, 97 insertions(+), 3 deletions(-)
+
+diff --git a/chassishandler.cpp b/chassishandler.cpp
+index 269a690..21b04ba 100755
+--- a/chassishandler.cpp
++++ b/chassishandler.cpp
+@@ -7,6 +7,8 @@
+ #include <limits.h>
+ #include <mapper.h>
+ #include <netinet/in.h>
++#include <thread>
++#include <future>
+ 
+ #include <array>
+ #include <chrono>
+@@ -735,6 +737,69 @@ ipmi::RspType<> ipmiSetChassisCap(bool intrusion, bool fpLockout,
+     return ipmi::responseSuccess();
+ }
+ 
++//check target status
++constexpr auto SYSTEMD_SERVICE = "org.freedesktop.systemd1";
++constexpr auto SYSTEMD_OBJ_PATH = "/org/freedesktop/systemd1";
++constexpr auto SYSTEMD_INTERFACE = "org.freedesktop.systemd1.Manager";
++constexpr auto SYSTEMD_PROPERTY_IFACE = "org.freedesktop.DBus.Properties";
++constexpr auto SYSTEMD_INTERFACE_UNIT = "org.freedesktop.systemd1.Unit";
++constexpr auto ACTIVATING_STATE = "activating";
++
++//constexpr auto HOST_STATE_POWEROFF_TGT = "obmc-host-stop@0.target";
++//constexpr auto HOST_STATE_POWERON_TGT = "obmc-host-start@0.target";
++                                                
++constexpr auto HOST_STATE_POWEROFF_SERVICE = "host-poweroff.service";
++constexpr auto HOST_STATE_POWERON_SERVICE = "host-poweron.service";
++
++
++bool stateActiving(const std::string& target)
++{
++    sdbusplus::message::variant<std::string> currentState;
++    sdbusplus::message::object_path unitTargetPath;
++    std::shared_ptr<sdbusplus::asio::connection> bus = getSdBus();
++
++    auto method = bus->new_method_call(SYSTEMD_SERVICE, SYSTEMD_OBJ_PATH,
++                                            SYSTEMD_INTERFACE, "GetUnit");
++
++    method.append(target);
++
++    try
++    {
++        auto result = bus->call(method);
++        result.read(unitTargetPath);
++    }
++     catch (sdbusplus::exception::SdBusError& e)
++    {
++         log<level::ERR>("Error in GetUnit call", entry("ERROR=%s", e.what()));
++        return false;
++    }
++
++    method = bus->new_method_call(
++        SYSTEMD_SERVICE,
++        static_cast<const std::string&>(unitTargetPath).c_str(),
++        SYSTEMD_PROPERTY_IFACE, "Get");
++
++    method.append(SYSTEMD_INTERFACE_UNIT, "ActiveState");
++
++    try
++    {
++        auto result = bus->call(method);
++        result.read(currentState);
++    }
++    catch (sdbusplus::exception::SdBusError& e)
++    {
++        log<level::ERR>("Error in ActiveState Get",
++                        entry("ERROR=%s", e.what()));
++        return false;
++    }
++    
++    const auto& currentStateStr =
++        sdbusplus::message::variant_ns::get<std::string>(currentState);
++
++    return currentStateStr == ACTIVATING_STATE;
++}
++
++
+ //------------------------------------------
+ // Calls into Host State Manager Dbus object
+ //------------------------------------------
+@@ -1216,6 +1281,31 @@ void indicate_no_softoff_needed()
+     std::ofstream(path.c_str());
+ }
+ 
++int powerOnCb(void)
++{
++    while (stateActiving(HOST_STATE_POWEROFF_SERVICE))
++    {
++        std::cerr << "Waiting power off completed\n";
++        std::this_thread::sleep_for (std::chrono::seconds(1));
++    }
++    std::ofstream f("/run/openbmc/ipmi-poweron");
++    if(f.is_open()) f.close();
++    return initiate_state_transition(State::Host::Transition::On);
++}
++
++int powerOffCb(void)
++{
++    while (stateActiving(HOST_STATE_POWERON_SERVICE))
++    {
++        std::cerr << "Waiting power on completed\n";
++        std::this_thread::sleep_for (std::chrono::seconds(1));
++    }
++    std::ofstream f("/run/openbmc/ipmi-poweroff");
++    if(f.is_open()) f.close();
++    return initiate_state_transition(State::Host::Transition::Off);
++}
++
++
+ /** @brief Implementation of chassis control command
+  *
+  *  @param - chassisControl command byte
+@@ -1232,12 +1322,15 @@ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
+     static constexpr char const* fruStateSensorPath= "/xyz/openbmc_project/sensors/fru_state/IPMI_Power_Diag";
+     std::vector<uint8_t> powerControlEventData{0x02,0x01,0xff};
+     int rc = 0;
+-
++    std::future<int>cb, cb1;
++        
+     switch (chassisControl)
+     {
+         case CMD_POWER_ON:
+             generateSELEvent(fruStatePowerOn,powerControlEventData);
+-            rc = initiate_state_transition(State::Host::Transition::On);
++            //initiate_state_transition(State::Host::Transition::On);
++            cb = std::async(std::launch::async,powerOnCb);
++            rc = 0;
+             break;
+         case CMD_POWER_OFF:
+             // This path would be hit in 2 conditions.
+@@ -1266,7 +1359,8 @@ ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
+ 
+                 // Now request the shutdown
+                 generateSELEvent(fruStatePowerOff,powerControlEventData);
+-                rc = initiate_state_transition(State::Host::Transition::Off);
++                cb1 = std::async(std::launch::async,powerOffCb);
++                rc = 0;
+             }
+             else
+             {
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host_%.bbappend b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host_%.bbappend
new file mode 100755
index 0000000..e5f63fb
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host_%.bbappend
@@ -0,0 +1,5 @@
+do_install_append(){
+  install -d ${D}${includedir}/phosphor-ipmi-host
+  install -m 0644 -D ${S}/sensorhandler.hpp ${D}${includedir}/phosphor-ipmi-host
+  install -m 0644 -D ${S}/selutility.hpp ${D}${includedir}/phosphor-ipmi-host
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host_git.bbappend
new file mode 100755
index 0000000..384ddbe
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-host_git.bbappend
@@ -0,0 +1,21 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0004-Implement-NMI-command-in-Chassis-Control-command.patch \
+            file://0005-ipmi-move-Unspecified-ip-source-from-static-to-D.patch \
+            file://0006-add-power-diag-log.patch \
+            file://0007-fix-set-static-ip-fail-issue.patch \
+            file://0008-add-ARP-control-status.patch \
+            file://0009-change-ipmit-power-reset-from-dc-cycle-to-reset.patch \
+            file://0010-Fix-BIOS-boot-type-setting-in-system-boot-option-fea.patch \
+            file://0011-fix-warm-reset-command.patch \
+            file://0012-Fix-expiration-flags-unexpected-status-in-get-watchd.patch \
+            file://0013-Implement-power-control-SEL-generated-in-chassis-con.patch \
+            file://0014-Implement-the-DCMI-power-reading-and-power-limit-com.patch \
+            file://0015-Add-debug-message-for-watchdog-reset.patch \
+            file://0016-rewrite-Get-Session-Info-to-use-new-yielding-D-Bus-A.patch \
+            file://0017-Fix-the-wrong-field-value-for-session-info-commnad.patch \
+            file://0018-Add-the-detect-for-firmare-revision.patch \
+            file://0019-block-power-control-until-pervious-action-completed.patch \
+            "
+EXTRA_OECONF += "--disable-i2c-whitelist-check"
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-ipmb/ipmb-channels.json b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-ipmb/ipmb-channels.json
new file mode 100755
index 0000000..e78a2b2
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-ipmb/ipmb-channels.json
@@ -0,0 +1,10 @@
+{
+  "channels": [
+    {
+      "type": "me",
+      "slave-path": "/dev/ipmb-1",
+      "bmc-addr": 32,
+      "remote-addr": 44
+    }
+  ]
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-ipmb_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-ipmb_git.bbappend
new file mode 100755
index 0000000..51e6c24
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-ipmb_git.bbappend
@@ -0,0 +1,9 @@
+FILESEXTRAPATHS_prepend_s5549 := "${THISDIR}/${PN}:"
+
+SRC_URI_append_s5549 = " file://ipmb-channels.json"
+
+do_install_append_s5549(){
+    install -m 0644 -D ${WORKDIR}/ipmb-channels.json \
+                      ${D}/usr/share/ipmbbridge
+}
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs/0001-IPMB-support-for-NM-commands.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs/0001-IPMB-support-for-NM-commands.patch
new file mode 100755
index 0000000..e50a0ed
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs/0001-IPMB-support-for-NM-commands.patch
@@ -0,0 +1,50 @@
+From ff9cfea0e796b695ec0d53ea6a1b112a7126f73b Mon Sep 17 00:00:00 2001
+From: Varun Sampat <vsampat@twitter.com>
+Date: Thu, 23 Apr 2020 17:30:51 -0400
+Subject: [PATCH] IPMB support for NM commands
+
+---
+ kcsbridged.cpp | 16 ++++++++++++++++
+ 1 file changed, 16 insertions(+)
+
+diff --git a/kcsbridged.cpp b/kcsbridged.cpp
+index a37cf5f..c4ce50f 100644
+--- a/kcsbridged.cpp
++++ b/kcsbridged.cpp
+@@ -81,6 +81,12 @@ class SmsChannel
+     static constexpr size_t kcsMessageSize = 256;
+     static constexpr uint8_t netFnShift = 2;
+     static constexpr uint8_t lunMask = (1 << netFnShift) - 1;
++    static constexpr uint8_t netFnAppRes = 0x7;
++    static constexpr uint8_t cmdGetMsg = 0x33;
++    static constexpr uint8_t cmdSendMsg = 0x34;
++    static constexpr uint8_t ipmiCcOk = 0x0;
++
++
+ 
+     SmsChannel(std::shared_ptr<boost::asio::io_context>& io,
+                std::shared_ptr<sdbusplus::asio::connection>& bus,
+@@ -224,6 +230,11 @@ class SmsChannel
+                         entry("LUN=0x%02x", lun), entry("CMD=0x%02x", cmd),
+                         entry("CC=0x%02x", cc));
+                 }
++                if (netfn == netFnAppRes &&
++                    cmd == cmdGetMsg && cc == ipmiCcOk)
++                {
++                    clearAttention();
++                }
+                 boost::system::error_code ecWr;
+                 size_t wlen =
+                     boost::asio::write(*dev, boost::asio::buffer(rsp), ecWr);
+@@ -236,6 +247,11 @@ class SmsChannel
+                         entry("NETFN=0x%02x", netfn), entry("LUN=0x%02x", lun),
+                         entry("CMD=0x%02x", cmd), entry("CC=0x%02x", cc));
+                 }
++                if (netfn ==  netFnAppRes && cmd == cmdSendMsg &&
++                    cc == ipmiCcOk && payload.size() == 0)
++                {
++                    setAttention();
++                }
+             },
+             ipmiQueueService, ipmiQueuePath, ipmiQueueIntf, ipmiQueueMethod,
+             netfn, lun, cmd, data, options);
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs/0002-Display-debug-messsage-for-KCS.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs/0002-Display-debug-messsage-for-KCS.patch
new file mode 100755
index 0000000..5b39e2b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs/0002-Display-debug-messsage-for-KCS.patch
@@ -0,0 +1,25 @@
+From 80487fce1321ce82d58d06ace25799133e41b1bd Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 21 Jul 2020 17:56:53 +0800
+Subject: [PATCH] Display debug messsage for KCS
+
+---
+ phosphor-ipmi-kcs@.service | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/phosphor-ipmi-kcs@.service b/phosphor-ipmi-kcs@.service
+index 56c0b72..82915ee 100644
+--- a/phosphor-ipmi-kcs@.service
++++ b/phosphor-ipmi-kcs@.service
+@@ -5,7 +5,7 @@ After=phosphor-ipmi-host.service
+ 
+ [Service]
+ Restart=always
+-ExecStart=/usr/bin/kcsbridged -c "%i"
++ExecStart=/usr/bin/kcsbridged -c "%i" -v 1
+ SyslogIdentifier=kcsbridged-%i
+ 
+ [Install]
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs_git.bbappend
new file mode 100755
index 0000000..6bbb60e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-kcs_git.bbappend
@@ -0,0 +1,6 @@
+KCS_DEVICE = "ipmi-kcs2"
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-IPMB-support-for-NM-commands.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net/0001-Revert-Remove-HMAC-SHA1-from-Authentication-Integrit.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net/0001-Revert-Remove-HMAC-SHA1-from-Authentication-Integrit.patch
new file mode 100755
index 0000000..c1ae78d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net/0001-Revert-Remove-HMAC-SHA1-from-Authentication-Integrit.patch
@@ -0,0 +1,43 @@
+From 7b370ff77febf95df4d2d6420f69fc6fa0758864 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 14 Oct 2020 16:53:05 +0800
+Subject: [PATCH 1/2] Revert "Remove HMAC-SHA1 from Authentication/Integrity
+ Alg"
+
+This reverts commit 4c494398a36d9f1bdc4f256f937487c7ebcc4e95.
+---
+ auth_algo.hpp      | 3 ++-
+ integrity_algo.hpp | 3 ++-
+ 2 files changed, 4 insertions(+), 2 deletions(-)
+
+diff --git a/auth_algo.hpp b/auth_algo.hpp
+index 894a853..24e4ff3 100644
+--- a/auth_algo.hpp
++++ b/auth_algo.hpp
+@@ -107,7 +107,8 @@ class Interface
+      */
+     static bool isAlgorithmSupported(Algorithms algo)
+     {
+-        if (algo == Algorithms::RAKP_HMAC_SHA256)
++        if (algo == Algorithms::RAKP_HMAC_SHA1 ||
++            algo == Algorithms::RAKP_HMAC_SHA256)
+         {
+             return true;
+         }
+diff --git a/integrity_algo.hpp b/integrity_algo.hpp
+index cdeb617..d8c9f5a 100644
+--- a/integrity_algo.hpp
++++ b/integrity_algo.hpp
+@@ -93,7 +93,8 @@ class Interface
+      */
+     static bool isAlgorithmSupported(Algorithms algo)
+     {
+-        if (algo == Algorithms::HMAC_SHA256_128)
++        if (algo == Algorithms::HMAC_SHA1_96 ||
++            algo == Algorithms::HMAC_SHA256_128)
+         {
+             return true;
+         }
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net/0002-Add-the-max-size-limit-feature-to-SOL-Console-data.patch b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net/0002-Add-the-max-size-limit-feature-to-SOL-Console-data.patch
new file mode 100755
index 0000000..9c152ab
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net/0002-Add-the-max-size-limit-feature-to-SOL-Console-data.patch
@@ -0,0 +1,39 @@
+From 0d9962b1526defda760b33b7b3fb0f9a32224ed3 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Fri, 16 Oct 2020 14:13:55 +0800
+Subject: [PATCH 2/2] Add the max size limit feature to SOL Console data
+
+---
+ sol/console_buffer.hpp | 6 ++++++
+ 1 file changed, 6 insertions(+)
+ mode change 100644 => 100755 sol/console_buffer.hpp
+
+diff --git a/sol/console_buffer.hpp b/sol/console_buffer.hpp
+old mode 100644
+new mode 100755
+index dbb75c9..d8fa09c
+--- a/sol/console_buffer.hpp
++++ b/sol/console_buffer.hpp
+@@ -11,6 +11,8 @@ namespace sol
+ 
+ using ConsoleBuffer = std::deque<uint8_t>;
+ 
++constexpr auto MAX_CONSOLE_BUFFER_SIZE = 1048576;
++
+ /** @class ConsoleData
+  *
+  *  The console data is the buffer that holds the data that comes from the host
+@@ -51,6 +53,10 @@ class ConsoleData
+     void write(const std::vector<uint8_t>& input)
+     {
+         data.insert(data.end(), input.begin(), input.end());
++        if (data.size() >= MAX_CONSOLE_BUFFER_SIZE)
++        {
++            ConsoleData::erase(MAX_CONSOLE_BUFFER_SIZE/10);
++        }
+     }
+ 
+     /** @brief Erase console buffer.
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net_git.bbappend
new file mode 100755
index 0000000..a25e34d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/phosphor-ipmi-net_git.bbappend
@@ -0,0 +1,7 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRCREV = "07bb095158b39cedb49dae0972e489a6a2776faf"
+
+SRC_URI += "file://0001-Revert-Remove-HMAC-SHA1-from-Authentication-Integrit.patch \
+            file://0002-Add-the-max-size-limit-feature-to-SOL-Console-data.patch \
+            "
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/s5549-ipmi-sensor-map-native.bb b/meta-mct/meta-s5549/recipes-phosphor/ipmi/s5549-ipmi-sensor-map-native.bb
new file mode 100755
index 0000000..de0eadc
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/s5549-ipmi-sensor-map-native.bb
@@ -0,0 +1,24 @@
+SUMMARY = "Sensor config for phosphor-host-ipmi"
+PR = "r1"
+
+inherit native
+inherit phosphor-ipmi-host
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+PROVIDES += "virtual/phosphor-ipmi-sensor-inventory"
+
+SRC_URI += "file://config.yaml"
+
+S = "${WORKDIR}"
+
+do_install() {
+        # This recipe is supposed to create an output yaml file with
+        # sensor data extracted  from the mrw.
+        # provides a sample output file.
+
+        DEST=${D}${sensor_datadir}
+        install -d ${DEST}
+        install config.yaml ${DEST}/sensor.yaml
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/ipmi/s5549-ipmi-sensor-map/config.yaml b/meta-mct/meta-s5549/recipes-phosphor/ipmi/s5549-ipmi-sensor-map/config.yaml
new file mode 100755
index 0000000..6a04a2b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/ipmi/s5549-ipmi-sensor-map/config.yaml
@@ -0,0 +1,289 @@
+0x01: &temperature
+  sensorType: 0x01
+  path: /xyz/openbmc_project/sensors/temperature/MB_AIR_INLET
+  sensorReadingType: 0x01
+  multiplierM: 1
+  offsetB: 0
+  bExp: 0
+  unit: xyz.openbmc_project.Sensor.Value.Unit.DegreesC
+  scale: -3
+  mutability: Mutability::Read
+  serviceInterface: org.freedesktop.DBus.Properties
+  readingType: readingData
+  interfaces:
+    xyz.openbmc_project.Sensor.Value:
+      Value:
+        Offsets:
+          0x0:
+            type: int64_t
+
+0x02:
+  <<: *temperature
+  path: /xyz/openbmc_project/sensors/temperature/SYS_AIR_INLET
+
+0x03:
+  <<: *temperature
+  path: /xyz/openbmc_project/sensors/temperature/SYS_AIR_OUTLET
+
+0x08: 
+  <<: *temperature
+  path: /xyz/openbmc_project/sensors/temperature/PCH_Temp
+
+0x09:
+  <<: *temperature
+  path: /xyz/openbmc_project/sensors/temperature/PSU_TEMP
+
+0x20: &voltage
+  sensorType: 0x02
+  path: /xyz/openbmc_project/sensors/voltage/PVCCP_P0_ADC0
+  sensorReadingType: 0x01
+  multiplierM: 78
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+  unit: xyz.openbmc_project.Sensor.Value.Unit.Volts
+  scale: -3
+  mutability: Mutability::Read
+  serviceInterface: org.freedesktop.DBus.Properties
+  readingType: readingData
+  interfaces:
+    xyz.openbmc_project.Sensor.Value:
+      Value:
+        Offsets:
+          0x0:
+            type: int64_t
+
+0x21:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVCCIO_P0_ADC1
+  multiplierM: 47
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x22:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVDDQ_P0_ADC2
+  multiplierM: 59
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x23:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVPP_P0_ADC3
+  multiplierM: 110
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x24:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVCCP_P1_ADC4
+  multiplierM: 78
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x25:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVCCIO_P1_ADC5
+  multiplierM: 47
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x26:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVDDQ_P1_ADC6
+  multiplierM: 59
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x27:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVPP_P1_ADC7
+  multiplierM: 110
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x28:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVCC12_ADC8
+  multiplierM: 51
+  offsetB: 0
+  bExp: 0
+  rExp: -3
+
+0x29:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVCC5_ADC9
+  multiplierM: 235
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x2a:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVCC3_ADC10
+  multiplierM: 157
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x2b:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVCC3_AUX_ADC11
+  multiplierM: 157
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x2c:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/P1V8_PCH_ADC12
+  multiplierM: 78
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x2d:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PVNN_PCH_ADC13
+  multiplierM: 47
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x2E:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/P1V05_PCH_ADC14
+  multiplierM: 47
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x2F:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/RTC_BAT_ADC15
+  multiplierM: 137
+  offsetB: 0
+  bExp: 0
+  rExp: -4
+
+0x71: &fan_tach
+  sensorType: 0x04
+  path: /xyz/openbmc_project/sensors/fan_tach/SYS_FAN1
+  sensorReadingType: 0x01
+  multiplierM: 255
+  offsetB: 0
+  bExp: 0
+  rExp: 0
+  unit: xyz.openbmc_project.Sensor.Value.Unit.RPMS
+  scale: 0
+  mutability: Mutability::Read
+  serviceInterface: org.freedesktop.DBus.Properties
+  readingType: readingData
+  interfaces:
+    xyz.openbmc_project.Sensor.Value:
+      Value:
+        Offsets:
+          0x0:
+            type: int64_t
+0x72:
+  <<: *fan_tach
+  path: /xyz/openbmc_project/sensors/fan_tach/SYS_FAN2
+
+0x73:
+  <<: *fan_tach
+  path: /xyz/openbmc_project/sensors/fan_tach/SYS_FAN3
+
+0x74:
+  <<: *fan_tach
+  path: /xyz/openbmc_project/sensors/fan_tach/CPU0_FAN
+
+0x75:
+  <<: *fan_tach
+  path: /xyz/openbmc_project/sensors/fan_tach/CPU1_FAN
+  
+0x76:
+  <<: *fan_tach
+  path: /xyz/openbmc_project/sensors/fan_tach/PSU_FAN
+  
+0x81:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PSU_VOLTAGE_IN
+  multiplierM: 1
+  offsetB: 0
+  bExp: 0
+  rExp: 0
+
+0x82:
+  sensorType: 0x0B
+  path: /xyz/openbmc_project/sensors/power/PSU_POWER_IN
+  sensorReadingType: 0x01
+  multiplierM: 235
+  offsetB: 0
+  bExp: 0
+  rExp: -2
+  unit: xyz.openbmc_project.Sensor.Value.Unit.Watts
+  scale: -6
+  mutability: Mutability::Read
+  serviceInterface: org.freedesktop.DBus.Properties
+  readingType: readingData
+  interfaces:
+    xyz.openbmc_project.Sensor.Value:
+      Value:
+        Offsets:
+          0x0:
+            type: int64_t
+  
+0x83:
+  <<: *voltage
+  path: /xyz/openbmc_project/sensors/voltage/PSU_VOLTAGE_OUT
+  multiplierM: 59
+  offsetB: 0
+  bExp: 0
+  rExp: -3
+  
+0x84:
+  sensorType: 0x0B
+  path: /xyz/openbmc_project/sensors/power/PSU_POWER_OUT
+  sensorReadingType: 0x01
+  multiplierM: 235
+  offsetB: 0
+  bExp: 0
+  rExp: -2
+  unit: xyz.openbmc_project.Sensor.Value.Unit.Watts
+  scale: -6
+  mutability: Mutability::Read
+  serviceInterface: org.freedesktop.DBus.Properties
+  readingType: readingData
+  interfaces:
+    xyz.openbmc_project.Sensor.Value:
+      Value:
+        Offsets:
+          0x0:
+            type: int64_t
+            
+0x85:
+  sensorType: 0x03
+  path: /xyz/openbmc_project/sensors/current/PSU_CURRENT_OUT
+  sensorReadingType: 0x01
+  multiplierM: 137
+  offsetB: 0
+  bExp: 0
+  rExp: -3
+  unit: xyz.openbmc_project.Sensor.Value.Unit.Amperes
+  scale: -3
+  mutability: Mutability::Read
+  serviceInterface: org.freedesktop.DBus.Properties
+  readingType: readingData
+  interfaces:
+    xyz.openbmc_project.Sensor.Value:
+      Value:
+        Offsets:
+          0x0:
+            type: int64_t
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/leds/mct-led-manager-config-native.bb b/meta-mct/meta-s5549/recipes-phosphor/leds/mct-led-manager-config-native.bb
new file mode 100755
index 0000000..e12987b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/leds/mct-led-manager-config-native.bb
@@ -0,0 +1,19 @@
+SUMMARY = "Phosphor LED Group Management for mct system"
+PR = "r1"
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+inherit native
+
+PROVIDES += "virtual/phosphor-led-manager-config-native"
+
+SRC_URI += "file://led.yaml"
+S = "${WORKDIR}"
+
+# Overwrite the example led layout yaml file prior
+# to building the phosphor-led-manager package
+do_install() {
+    SRC=${S}
+    DEST=${D}${datadir}/phosphor-led-manager
+    install -D ${SRC}/led.yaml ${DEST}/led.yaml
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/leds/mct-led-manager-config/led.yaml b/meta-mct/meta-s5549/recipes-phosphor/leds/mct-led-manager-config/led.yaml
new file mode 100755
index 0000000..39a0aea
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/leds/mct-led-manager-config/led.yaml
@@ -0,0 +1,39 @@
+bmc_booted:
+    heartbeat:
+        Action: 'Blink'
+        DutyOn: 50
+        Period: 1000
+
+PowerOn:
+    power:
+        Action: 'On'
+        DutyOn: 50
+        Period: 0
+
+enclosure_fault:
+    fault:
+        Action: 'On'
+
+enclosure_identify_blink:
+    identify:
+        Action: 'Blink'
+        DutyOn: 50
+        Period: 1000
+
+enclosure_identify:
+    identify:
+        Action: 'On'
+
+# The Op Panel on the Romulus system holds a multicolor LED.
+# Both the 'fault' and 'identify' gpios are wired to the same LED.
+# By holding one in 'on' while the other in 'blink' state, ensures
+# the manufacturing process can verify both colors function
+lamp_test:
+    fault:
+        Action: 'On'
+    identify:
+        Action: 'On'
+        Action: 'Blink'
+        DutyOn: 50
+        Period: 1000
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power.bb b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power.bb
new file mode 100755
index 0000000..0e0d24b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power.bb
@@ -0,0 +1,41 @@
+SUMMARY = "MiTAC DCMI Power"
+DESCRIPTION = "Implement the power for IPMI DCMI"
+PR = "r1"
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+inherit autotools pkgconfig
+inherit obmc-phosphor-ipmiprovider-symlink
+inherit pythonnative
+inherit systemd
+inherit obmc-phosphor-systemd
+
+
+S = "${WORKDIR}"
+
+SRC_URI = "file://bootstrap.sh \
+           file://configure.ac \
+           file://mct-dcmi-power.cpp \
+           file://mct-dcmi-power.hpp \
+           file://utils.hpp \
+           file://LICENSE \
+           file://Makefile.am \
+           file://mct-dcmi-power.service \
+          "
+
+DEPENDS += "autoconf-archive-native"
+DEPENDS += "sdbusplus sdbusplus-native"
+DEPENDS += "phosphor-logging"
+DEPENDS += "phosphor-dbus-interfaces phosphor-dbus-interfaces-native"
+DEPENDS += "sdbus++-native"
+DEPENDS += "boost"
+DEPENDS += "phosphor-dbus-interfaces"
+
+
+RDEPENDS_${PN} += " \
+        sdbusplus \
+        phosphor-logging \
+        phosphor-dbus-interfaces \
+        "
+
+SYSTEMD_SERVICE_${PN} = "mct-dcmi-power.service"
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/LICENSE b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/LICENSE
new file mode 100755
index 0000000..120e95d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2018 Intel Corporation
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/Makefile.am b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/Makefile.am
new file mode 100755
index 0000000..4ff63b1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/Makefile.am
@@ -0,0 +1,13 @@
+sbin_PROGRAMS = mct-dcmi-power
+
+mct_dcmi_power_SOURCES = mct-dcmi-power.cpp
+mct_dcmi_power_LDFLAGS = $(SYSTEMD_LIBS) \
+                         $(SDBUSPLUS_LIBS) \
+                         -pthread \
+                         $(PTHREAD_LIBS) \
+                         $(BOOST_CPPFLAGS)
+mct_dcmi_power_CFLAGS = $(SYSTEMD_CFLAGS) \
+                        $(SDBUSPLUS_CFLAGS) \
+                        -pthread \
+                        $(PTHREAD_CFLAGS) \
+                        $(BOOST_CPPFLAGS)
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/bootstrap.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/bootstrap.sh
new file mode 100755
index 0000000..bb06e73
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/bootstrap.sh
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+AUTOCONF_FILES="Makefile.in aclocal.m4 ar-lib autom4te.cache compile \
+        config.guess config.h.in config.sub configure depcomp install-sh \
+        ltmain.sh missing *libtool test-driver"
+
+case $1 in
+    clean)
+        test -f Makefile && make maintainer-clean
+        test -f linux/bt-bmc.h && rm -rf linux/bt-bmc.h
+        test -d linux && find linux -type d -empty | xargs -r rm -rf
+        for file in ${AUTOCONF_FILES}; do
+            find -name "$file" | xargs -r rm -rf
+        done
+        exit 0
+        ;;
+esac
+
+autoreconf -i
+echo 'Run "./configure ${CONFIGURE_FLAGS} && make"'
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/configure.ac b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/configure.ac
new file mode 100755
index 0000000..4edcee2
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/configure.ac
@@ -0,0 +1,35 @@
+# Initialization
+AC_PREREQ([2.69])
+AC_INIT([mct-dcmi-power], [1.0])
+AC_LANG([C++])
+AC_CONFIG_HEADERS([config.h])
+AM_INIT_AUTOMAKE([subdir-objects -Wall -Werror foreign dist-xz])
+AM_SILENT_RULES([yes])
+
+# Checks for programs.
+AC_PROG_CC
+AM_PROG_AR
+AC_PROG_INSTALL
+AC_PROG_MAKE_SET
+
+# Checks for libraries.
+PKG_CHECK_MODULES([SYSTEMD], [libsystemd >= 221])
+PKG_CHECK_MODULES([SDBUSPLUS], [sdbusplus],,\
+                  AC_MSG_ERROR(["Requires sdbusplus package."]))
+AX_CXX_COMPILE_STDCXX_17([noext])
+
+# Checks for header files.
+AC_CHECK_HEADER(systemd/sd-bus.h, ,[AC_MSG_ERROR([Could not find systemd/sd-bus.h...systemd developement package required])])
+
+# Checks for typedefs, structures, and compiler characteristics.
+AX_APPEND_COMPILE_FLAGS([-Wall -Werror], [CFLAGS])
+
+# Checks for library functions.
+LT_INIT # Removes 'unrecognized options: --with-libtool-sysroot'
+
+# Create configured output
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
+
+
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.cpp b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.cpp
new file mode 100755
index 0000000..815d890
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.cpp
@@ -0,0 +1,390 @@
+/* Copyright 2020 MCT
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#include "mct-dcmi-power.hpp"
+
+#include <iostream>
+#include "utils.hpp"
+
+static constexpr bool DEBUG = false;
+
+int readPower(std::string path)
+{
+    std::fstream powerValueFile(path, std::ios_base::in);
+    int value;
+    int factor = 1000000;
+    powerValueFile >> value;
+    return value / factor;
+}
+
+void updatePowerValue(std::string property,const double& newValue,double& oldValue)
+{
+    if(newValue != oldValue)
+    {
+        oldValue = newValue;
+        powerInterface->set_property(property, newValue);
+    }
+}
+
+void propertyInitialize(PowerStore& powerStore)
+{
+    labelMatch = 
+    {
+        {"pout1", PSUProperty("Output Power", 3000, 0, 6)},
+        {"pout2", PSUProperty("Output Power", 3000, 0, 6)},
+        {"pout3", PSUProperty("Output Power", 3000, 0, 6)},
+        {"power1", PSUProperty("Output Power", 3000, 0, 6)}
+    };
+
+    try
+    {
+        auto service = getService(bus, PCAP_INTERFACE, PCAP_PATH);
+        auto properties = getAllDbusProperties(bus, service, PCAP_PATH,
+                                                     PCAP_INTERFACE,DBUS_TIMEOUT);
+        powerStore.powerCap = std::get<uint32_t>(properties[POWER_CAP_PROP]);
+        powerStore.powerCapEnable = std::get<bool>(properties[POWER_CAP_ENABLE_PROP]);
+        powerStore.exceptionAction = std::get<std::string>(properties[EXCEPTION_ACTION_PROP]);
+        powerStore.correctionTime = std::get<uint32_t>(properties[CORRECTION_TIME_PROP]);
+        powerStore.samplingPeriod = std::get<uint16_t>(properties[SAMPLING_PERIOD_PROP]);
+
+    }
+    catch (SdBusError& e)
+    {
+        log<level::ERR>("Error in initialize power cap parameter set",entry("ERROR=%s", e.what()));
+        propertyInitialize(powerStore);
+    }
+
+}
+
+void dbusServiceInitialize(PowerStore& powerStore)
+{
+    bus->request_name(DCMI_SERVICE);
+    sdbusplus::asio::object_server objServer(bus);
+    powerInterface=objServer.add_interface(DCMI_POWER_PATH,DCMI_POWER_INTERFACE);
+    powerInterface->register_property(
+        PERIOD_MAX_PROP, powerStore.max, sdbusplus::asio::PropertyPermission::readWrite);
+    powerInterface->register_property(
+        PERIOD_MIN_PROP, powerStore.min, sdbusplus::asio::PropertyPermission::readWrite);
+    powerInterface->register_property(
+        PERIOD_AVERAGE_PROP, powerStore.average, sdbusplus::asio::PropertyPermission::readWrite);
+    powerInterface->initialize();
+}
+
+std::string findPowerPath()
+{
+    static std::vector<std::string> pmbusNames = {
+    "isl68137", "ina219",   "ina230", "max20730", "max20734",
+    "max20796", "max34451", "pmbus",  "pxe1610", "cffps1"};
+
+    std::string powerPath = "";
+    std::vector<fs::path> pmbusPaths;
+    if (!findFiles(fs::path("/sys/class/hwmon"), "name", pmbusPaths, 1))
+    {
+        if constexpr (DEBUG)
+        {
+            std::cerr << "No PSU sensors in system\n";
+        }
+        return powerPath;
+    }
+
+    for (const auto& pmbusPath : pmbusPaths)
+    {
+        std::ifstream nameFile(pmbusPath);
+        if (!nameFile.good())
+        {
+            if constexpr (DEBUG)
+            {
+                std::cerr << "Failure finding pmbus path " << pmbusPath << "\n";
+            }
+            continue;
+        }
+        std::string pmbusName;
+        std::getline(nameFile, pmbusName);
+        nameFile.close();
+
+        if (std::find(pmbusNames.begin(), pmbusNames.end(), pmbusName) ==
+            pmbusNames.end())
+        {
+            // To avoid this error message, add your driver name to
+            // the pmbusNames vector at the top of this file.
+            if constexpr (DEBUG)
+            {
+                std::cerr << "Driver name " << pmbusName << " not found in sensor whitelist\n";
+            }
+            continue;
+        }
+        const std::string* psuName;
+        auto directory = pmbusPath.parent_path();
+
+        std::vector<fs::path> sensorPaths;
+        if (!findFiles(directory, R"(\w\d+_input$)", sensorPaths, 0))
+        {
+            if constexpr (DEBUG)
+            {
+                std::cerr << "No PSU non-label sensor in PSU\n";
+            }
+            continue;
+        }
+        for (const auto& sensorPath : sensorPaths)
+        {
+            std::string labelHead;
+            std::string sensorPathStr = sensorPath.string();
+            std::string sensorNameStr = sensorPath.filename();
+
+            auto labelPath = boost::replace_all_copy(sensorPathStr, "input", "label");
+            std::ifstream labelFile(labelPath);
+            if (!labelFile.good())
+            {
+                if constexpr (DEBUG)
+                {
+                    std::cerr << "Input file " << sensorPath << " has no corresponding label file\n";
+                }
+
+                // hwmon *_input filename with number:
+                // temp1, temp2, temp3, ...
+                labelHead = sensorNameStr.substr(0, sensorNameStr.find("_"));
+            }
+            else
+            {
+                std::string label;
+                std::getline(labelFile, label);
+                labelFile.close();
+
+                // hwmon corresponding *_label file contents:
+                // vin1, vout1, ...
+                labelHead = label.substr(0, label.find(" "));
+            }
+
+            auto findProperty = labelMatch.find(labelHead);
+            if (findProperty == labelMatch.end())
+            {
+                if constexpr (DEBUG)
+                {
+                    std::cerr << "Could not find matching default property for " << labelHead << "\n";
+                }
+                continue;
+            }
+
+            if constexpr (DEBUG)
+            {
+                std::cerr << "Sensor name \"" << sensorNameStr << "\" path \"" << sensorPathStr << "\"\n";
+            }
+
+            powerPath = sensorPathStr;
+            continue;
+        }
+
+    }
+    return powerPath;
+}
+
+void powerHandler(boost::asio::io_context& io,PowerStore& powerStore,double delay)
+{
+    static boost::asio::steady_timer timer(io);
+
+    timer.expires_after(std::chrono::microseconds((long)delay));
+
+    timer.async_wait([&io,&powerStore](const boost::system::error_code&) 
+    {
+        double start,end;
+        double max=0;
+        double min=0;
+        double average =0;
+        double averageCount = 0;
+        Power currentPower;
+
+        if(powerStore.powerPath == "")
+        {
+            powerStore.powerPath = findPowerPath();
+            if(powerStore.powerPath == "")
+            {
+                powerHandler(io, powerStore, 1*MICRO_OFFSET);
+                return; 
+            }
+        }
+
+        start = getCurrentTimeWithMs();
+
+        currentPower.time = start*MILLI_OFFSET;
+        currentPower.value = readPower(powerStore.powerPath);
+
+        if(powerStore.collectedPower.size() >= MAX_COLLECTION_POWER_SIZE){
+            powerStore.collectedPower.erase(powerStore.collectedPower.begin());
+            powerStore.collectedPower.push_back(currentPower);
+        }
+        else{
+            powerStore.collectedPower.push_back(currentPower);
+        }
+
+        timeoutHandle(currentPower,powerStore);
+        
+        for (auto it = powerStore.collectedPower.begin(); it != powerStore.collectedPower.end(); it++)
+        {
+            if(it->time+(powerStore.samplingPeriod*MILLI_OFFSET) < currentPower.time)
+            {
+                continue;
+            }
+            if(max < it->value || averageCount == 0)
+            {
+                max = it->value;
+            }
+            if(min > it->value || averageCount == 0){
+                min = it->value;
+            }
+            average = average + it->value;
+            averageCount++;
+        }
+
+        if(averageCount){
+            average = average/averageCount;
+        }
+
+        updatePowerValue(PERIOD_AVERAGE_PROP,average,powerStore.average);
+        updatePowerValue(PERIOD_MAX_PROP,max,powerStore.max);
+        updatePowerValue(PERIOD_MIN_PROP,min,powerStore.min);
+
+        end = getCurrentTimeWithMs();
+        double delayTime = (1-(end-start))*MICRO_OFFSET;
+        if(delayTime < 0){
+            delayTime = 0;
+        }
+
+        powerHandler(io,powerStore,delayTime);
+        return;
+    });
+}
+
+void timeoutHandle(Power currentPower,PowerStore& powerStore)
+{
+    if(!powerStore.actionEnable && currentPower.value < powerStore.powerCap)
+    {
+        powerStore.actionEnable = true;
+    }
+
+    if(powerStore.correctionTimeout >= powerStore.correctionTime  && powerStore.powerCapEnable && powerStore.actionEnable)
+    {
+        static constexpr char const* powerlimitSensorPath= "/xyz/openbmc_project/sensors/power_supply/DCMI_POWER_LIMIT";
+        std::vector<uint8_t> powerlimitEventData{0x06,0xFF,0x03};
+
+        powerStore.actionEnable = false;
+        if(powerStore.exceptionAction == "xyz.openbmc_project.Control.Power.Cap.Action.None")
+        {
+            std::cerr << "Action for power limit: None" << "\n";
+        }
+
+        if(powerStore.exceptionAction == "xyz.openbmc_project.Control.Power.Cap.Action.OffAndLog")
+        {
+            std::cerr << "Action for power limit: Power Off and generate SEL event" << "\n";
+            generateSELEvent(bus,powerlimitSensorPath,powerlimitEventData);
+            hostPowerControl(bus,"xyz.openbmc_project.State.Host.Transition.Off");
+        }
+
+        if(powerStore.exceptionAction == "xyz.openbmc_project.Control.Power.Cap.Action.Log")
+        {
+            std::cerr << "Action for power limit: Generate SEL event" << "\n";
+            generateSELEvent(bus,powerlimitSensorPath,powerlimitEventData);
+        }
+    }
+
+    if(currentPower.value > powerStore.powerCap &&  powerStore.powerCapEnable)
+    {
+        powerStore.correctionTimeout = powerStore.correctionTimeout + 1000;
+    }
+    else
+    {
+         powerStore.correctionTimeout = 0;
+    }
+}
+
+inline static sdbusplus::bus::match::match
+    startPowerCapMonitor(std::shared_ptr<sdbusplus::asio::connection> conn,PowerStore& powerStore)
+{
+    auto powerCapMatcherCallback = [&](sdbusplus::message::message &msg)
+    {
+        std::string interface;
+        boost::container::flat_map<std::string, std::variant<std::string, uint16_t, bool, uint32_t>> propertiesChanged;
+        msg.read(interface, propertiesChanged);
+        std::string event = propertiesChanged.begin()->first;
+
+        if (propertiesChanged.empty() || event.empty())
+        {
+            return;
+        }
+
+        if(event == "SamplingPeriod")
+        {
+            auto value = std::get_if<uint16_t>(&propertiesChanged.begin()->second);
+            powerStore.samplingPeriod = *value;
+        }
+        if(event == "PowerCapEnable")
+        {
+            auto value = std::get_if<bool>(&propertiesChanged.begin()->second);
+            powerStore.powerCapEnable = *value;
+            powerStore.actionEnable = *value;
+        }
+        if(event == "CorrectionTime")
+        {
+            auto value = std::get_if<uint32_t>(&propertiesChanged.begin()->second);
+            powerStore.correctionTime = *value;
+        }
+        if(event == "ExceptionAction")
+        {
+            auto value = std::get_if<std::string>(&propertiesChanged.begin()->second);
+            powerStore.exceptionAction = *value;
+        }
+        if(event == "PowerCap")
+        {
+            auto value = std::get_if<uint32_t>(&propertiesChanged.begin()->second);
+            powerStore.powerCap = *value;
+        }
+
+        if constexpr (DEBUG)
+        {
+            std::cerr << "Properties changed event: " << event <<"\n";
+            std::cerr << "PowerStore.samplingPeriod: " <<  powerStore.samplingPeriod <<"\n";
+            std::cerr << "PowerStore.powerCapEnable: " <<  powerStore.powerCapEnable <<"\n";
+            std::cerr << "PowerStore.correctionTime: " <<  powerStore.correctionTime <<"\n";
+            std::cerr << "PowerStore.exceptionAction: " <<  powerStore.exceptionAction <<"\n";
+            std::cerr << "PowerStore.powerCap: " <<  powerStore.powerCap <<"\n";
+        }
+
+    };
+
+    sdbusplus::bus::match::match powerCapMatcher(
+        static_cast<sdbusplus::bus::bus &>(*conn),
+        "type='signal',interface='org.freedesktop.DBus.Properties',member='"
+        "PropertiesChanged',arg0namespace='xyz.openbmc_project.Control.Power.Cap'",
+        std::move(powerCapMatcherCallback));
+
+    return powerCapMatcher;
+}
+
+int main(int argc, char *argv[])
+{
+    boost::asio::io_context io;
+    bus = std::make_shared<sdbusplus::asio::connection>(io);
+    
+    PowerStore powerStore;
+    dbusServiceInitialize(powerStore);
+    propertyInitialize(powerStore);
+
+    sdbusplus::bus::match::match powerCapMonitor = startPowerCapMonitor(bus,powerStore);
+
+    io.post(
+        [&]() { powerHandler(io,powerStore, 0); });
+    
+    io.run();
+    return 0;
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.hpp b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.hpp
new file mode 100755
index 0000000..d9efd54
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.hpp
@@ -0,0 +1,133 @@
+#pragma once
+
+#include <iostream>
+#include <vector>
+#include <variant>
+#include <filesystem>
+#include <fstream>
+#include <chrono>
+#include <unistd.h>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_map.hpp>
+#include <boost/container/flat_set.hpp>
+#include <boost/asio/io_context.hpp>
+#include <boost/asio/steady_timer.hpp>
+#include <sdbusplus/bus.hpp>
+#include <sdbusplus/server.hpp>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <phosphor-logging/elog-errors.hpp>
+#include <phosphor-logging/log.hpp>
+#include <xyz/openbmc_project/State/Host/server.hpp>
+
+
+namespace fs = std::filesystem;
+using namespace phosphor::logging;
+using namespace sdbusplus::xyz::openbmc_project::State::server;
+
+constexpr auto MILLI_OFFSET = 1000;
+constexpr auto MICRO_OFFSET = 1000000;
+constexpr auto MAX_COLLECTION_POWER_SIZE = 65535;
+
+constexpr auto DCMI_SERVICE = "xyz.openbmc_project.DCMI";
+constexpr auto DCMI_POWER_PATH = "/xyz/openbmc_project/DCMI/Power";
+constexpr auto DCMI_POWER_INTERFACE = "xyz.openbmc_project.DCMI.Value";
+constexpr auto PCAP_PATH = "/xyz/openbmc_project/control/host0/power_cap";
+constexpr auto PCAP_INTERFACE = "xyz.openbmc_project.Control.Power.Cap";
+
+constexpr auto PERIOD_MAX_PROP = "PeriodMaxValue";
+constexpr auto PERIOD_MIN_PROP = "PeriodMinValue";
+constexpr auto PERIOD_AVERAGE_PROP = "PeriodAverageValue";
+constexpr auto POWER_CAP_PROP = "PowerCap";
+constexpr auto POWER_CAP_ENABLE_PROP = "PowerCapEnable";
+constexpr auto EXCEPTION_ACTION_PROP = "ExceptionAction";
+constexpr auto CORRECTION_TIME_PROP = "CorrectionTime";
+constexpr auto SAMPLING_PERIOD_PROP = "SamplingPeriod";
+
+constexpr std::chrono::microseconds DBUS_TIMEOUT = std::chrono::microseconds(5*1000000);
+
+typedef struct{
+    double time = 0;
+    unsigned int value = 0;
+}Power;
+
+typedef struct{
+    double max=0;
+    double min=0;
+    double average=0;
+    bool powerCapEnable=false;
+    bool actionEnable=true;
+    uint16_t samplingPeriod=0;
+    uint32_t correctionTime=0;
+    uint32_t correctionTimeout=0;
+    uint32_t powerCap=0;
+    std::string exceptionAction="";
+    std::string powerPath="";
+    std::vector<Power> collectedPower;
+}PowerStore;
+
+class PSUProperty
+{
+  public:
+    PSUProperty(std::string name, double max, double min, unsigned int factor) :
+        labelTypeName(name), maxReading(max), minReading(min),
+        sensorScaleFactor(factor)
+    {
+    }
+    ~PSUProperty() = default;
+
+    std::string labelTypeName;
+    double maxReading;
+    double minReading;
+    unsigned int sensorScaleFactor;
+};
+
+static boost::container::flat_map<std::string,PSUProperty> labelMatch;
+
+/** @brief Read the value from hardware monitor path.
+ *
+ *  @param[in] path - hardware monitor path for power.
+ */
+int readPower(std::string path);
+
+/** @brief Update current power value to dbus property.
+ *
+ *  @param[in] property - Dbus property.
+ *  @param[in] newValue - Current power value.
+ *  @param[in] oldValue - Stored power value.
+ */
+void updatePowerValue(std::string property,const double& newValue,double& oldValue);
+
+/** @brief Initialize the property for match power label and power which stored at dbus.
+ *
+ *  @param[in] powerStore - Stored power struct.
+ */
+void propertyInitialize(PowerStore& powerStore);
+
+/** @brief Initialize the dbus Service for dcmi power.
+ *
+ *  @param[in] powerStore - Stored power struct.
+ */
+void dbusServiceInitialize(PowerStore& powerStore);
+
+/** @brief Find the hardware monitor path for power.
+ *
+ *  @return On success returns path with stored power.
+ */
+std::string findPowerPath();
+
+/**
+ * @brief Handle the DCMI power action
+ *
+ * @param[in] io - io context.
+ * @param[in] delay - Delay time in micro second.
+ */
+void powerHandler(boost::asio::io_context& io,PowerStore& powerStore,double delay);
+
+/** @brief Handle the correction timeout for power limit.
+ *
+ *  @param[in] currentPower - Current power with time and value.
+ *  @param[in] powerStore - Stored power struct.
+ */
+void timeoutHandle(Power currentPower,PowerStore& powerStore);
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.service b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.service
new file mode 100755
index 0000000..51388b2
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/mct-dcmi-power.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=MiTAC DCMI Power
+Requires=xyz.openbmc_project.psusensor.service
+After=xyz.openbmc_project.psusensor.service
+
+[Service]
+Restart=always
+ExecStart=/usr/bin/env mct-dcmi-power
+SyslogIdentifier=mct-dcmi-power
+TimeoutSec=infinity
+
+[Install]
+WantedBy={SYSTEMD_DEFAULT_TARGET}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/utils.hpp b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/utils.hpp
new file mode 100755
index 0000000..5aa9174
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-dcmi/mct-dcmi-power/utils.hpp
@@ -0,0 +1,215 @@
+#pragma once
+
+#include <iostream>
+#include <vector>
+#include <filesystem>
+#include <regex>
+#include <time.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sdbusplus/bus.hpp>
+#include <phosphor-logging/elog-errors.hpp>
+#include <phosphor-logging/log.hpp>
+
+namespace fs = std::filesystem;
+using namespace phosphor::logging;
+using sdbusplus::exception::SdBusError;
+
+std::shared_ptr<sdbusplus::asio::connection> bus;
+std::shared_ptr<sdbusplus::asio::dbus_interface> powerInterface;
+
+using DbusProperty = std::string;
+using Value = std::variant<bool, uint8_t, int16_t, uint16_t, int32_t, uint32_t,
+                           int64_t, uint64_t, double, std::string>;
+using PropertyMap = std::map<DbusProperty, Value>;
+
+constexpr auto IPMI_SEL_Service =    "xyz.openbmc_project.Logging.IPMI";
+constexpr auto IPMI_SEL_Path = "/xyz/openbmc_project/Logging/IPMI";
+constexpr auto IPMI_SEL_Add_Interface = "xyz.openbmc_project.Logging.IPMI";
+constexpr auto HOST_STATE_PATH ="/xyz/openbmc_project/state/host0";
+constexpr auto HOST_INTERFACE = "xyz.openbmc_project.State.Host";
+constexpr auto PROP_INTERFACE = "org.freedesktop.DBus.Properties";
+constexpr auto METHOD_SET = "Set";
+constexpr auto METHOD_GET_ALL = "GetAll";
+
+
+/**
+ * @brief Find path accroding to match string.
+ *
+ * @param[in] dirPath - Directory path.
+ * @param[in] matchString - String for match.
+ * @param[in] foundPaths - Found match path.
+ * @param[in] symlinkDepth - Symlink for directory depth.
+ * @return On success returns true.
+ */
+bool findFiles(const fs::path dirPath, const std::string& matchString,
+               std::vector<fs::path>& foundPaths, unsigned int symlinkDepth)
+{
+    if (!fs::exists(dirPath))
+        return false;
+
+    std::regex search(matchString);
+    std::smatch match;
+    for (auto& p : fs::recursive_directory_iterator(dirPath))
+    {
+        std::string path = p.path().string();
+        if (!is_directory(p))
+        {
+            if (std::regex_search(path, match, search))
+                foundPaths.emplace_back(p.path());
+        }
+        else if (is_symlink(p) && symlinkDepth)
+        {
+            findFiles(p.path(), matchString, foundPaths, symlinkDepth - 1);
+        }
+    }
+    return true;
+}
+
+/**
+ * @brief Get current timestamp in milliseconds.
+ * 
+ * @param[in] Null.
+ * @return current timestamp in milliseconds.
+ */
+double getCurrentTimeWithMs()
+{
+    time_t s;
+    long ms;
+    struct timespec spec;
+
+    clock_gettime(CLOCK_REALTIME, &spec);
+
+
+
+    s  = spec.tv_sec;
+    ms = round(spec.tv_nsec / 1.0e6); // Convert nanoseconds to milliseconds
+    if (ms > 999) {
+        s++;
+        ms = 0;
+    }
+
+    double  result = (intmax_t)s + ((double)ms/1000);
+
+    return result;
+}
+
+/**
+ * @brief Get the DBUS Service name for the input dbus path.
+
+ * @param[in] bus - DBUS Bus Object.
+ * @param[in] intf - DBUS Interface.
+ * @param[in] path - DBUS Object Path.
+ */
+std::string getService(std::shared_ptr<sdbusplus::asio::connection>& bus, const std::string& intf,
+                       const std::string& path)
+{
+    auto mapperCall =
+        bus->new_method_call("xyz.openbmc_project.ObjectMapper",
+                            "/xyz/openbmc_project/object_mapper",
+                            "xyz.openbmc_project.ObjectMapper", "GetObject");
+
+    mapperCall.append(path);
+    mapperCall.append(std::vector<std::string>({intf}));
+
+    auto mapperResponseMsg = bus->call(mapperCall);
+
+    if (mapperResponseMsg.is_method_error())
+    {
+        throw std::runtime_error("ERROR in mapper call");
+    }
+
+    std::map<std::string, std::vector<std::string>> mapperResponse;
+    mapperResponseMsg.read(mapperResponse);
+
+    if (mapperResponse.begin() == mapperResponse.end())
+    {
+        throw std::runtime_error("ERROR in reading the mapper response");
+    }
+
+    return mapperResponse.begin()->first;
+}
+
+/** @brief Gets all the properties associated with the given object
+ *         and the interface.
+ *  @param[in] bus - DBUS Bus Object.
+ *  @param[in] service - Dbus service name.
+ *  @param[in] objPath - Dbus object path.
+ *  @param[in] interface - Dbus interface.
+ *  @return On success returns the map of name value pair.
+ */
+PropertyMap getAllDbusProperties(std::shared_ptr<sdbusplus::asio::connection>& bus,
+                                 const std::string& service,
+                                 const std::string& objPath,
+                                 const std::string& interface,
+                                 std::chrono::microseconds timeout)
+{
+    PropertyMap properties;
+
+    auto method = bus->new_method_call(service.c_str(), objPath.c_str(),
+                                      PROP_INTERFACE, METHOD_GET_ALL);
+
+    method.append(interface);
+
+    auto reply = bus->call(method, timeout.count());
+
+    if (reply.is_method_error())
+    {
+        log<level::ERR>("Failed to get all properties",
+                        entry("PATH=%s", objPath.c_str()),
+                        entry("INTERFACE=%s", interface.c_str()));
+    }
+
+    reply.read(properties);
+    return properties;
+}
+
+/**
+ * @brief Generate SEL event.
+ *
+ * @param[in] bus - DBUS Bus Object.
+ * @param[in] SensorPath - Dbus service name of sensor.
+ * @param[in] eventData - SEL event data 1 to 3.
+ */
+void generateSELEvent(std::shared_ptr<sdbusplus::asio::connection>& bus,char const* SensorPath,std::vector<uint8_t> eventData)
+{
+    uint16_t generateID = 0x20;
+    bool assert=1;
+
+    sdbusplus::message::message writeSEL = bus->new_method_call(
+                            IPMI_SEL_Service, IPMI_SEL_Path, IPMI_SEL_Add_Interface, "IpmiSelAdd");
+    writeSEL.append("SEL Entry",  std::string(SensorPath), eventData, assert,generateID);
+    try
+    {
+        bus->call(writeSEL);
+    }
+    catch (sdbusplus::exception_t& e)
+    {
+        std::cerr << "call IpmiSelAdd failed\n";
+    }
+}
+
+/**
+ * @brief Control host power state.
+ *
+ * @param[in] bus - DBUS Bus Object.
+ * @param[in] control - Power state.
+ */
+void hostPowerControl(std::shared_ptr<sdbusplus::asio::connection>& bus, std::string control)
+{
+    try
+    {
+        auto service = getService(bus, HOST_INTERFACE, HOST_STATE_PATH);
+        
+        auto method =  bus->new_method_call(
+            service.c_str(), HOST_STATE_PATH, PROP_INTERFACE, METHOD_SET);
+        method.append(HOST_INTERFACE, "RequestedHostTransition", sdbusplus::message::variant<std::string>(control));
+
+        bus->call(method);
+    }
+    catch (SdBusError& e)
+    {
+        log<level::ERR>("Failed to change power state", entry("ERROR=%s", e.what()));
+    }
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/default-pwm.service b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/default-pwm.service
new file mode 100755
index 0000000..a66f554
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/default-pwm.service
@@ -0,0 +1,15 @@
+[Unit]
+Description=Set Default PWM
+Wants=obmc-chassis-poweron@0.target
+After=obmc-chassis-poweron@0.target
+After=xyz.openbmc_project.Hwmon@-ahb-apb-pwm\x2dtacho\x2dcontroller@1e786000.service
+Conflicts=obmc-power-on@0.target
+[Service]
+RemainAfterExit=no
+Type=simple
+ExecStart=/usr/bin/env default-pwm.sh
+SyslogIdentifier=default-pwm
+
+[Install]
+RequiredBy=obmc-chassis-poweron@0.target
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/default-pwm.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/default-pwm.sh
new file mode 100755
index 0000000..a4279a5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/default-pwm.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+if [ ! -f /var/tmp/acflag ]; then
+
+echo "After ac, restart service to fix sensor"
+systemctl stop xyz.openbmc_project.fansensor.service
+systemctl start xyz.openbmc_project.fansensor.service
+
+
+systemctl stop xyz.openbmc_project.ipmbsensor.service
+systemctl start xyz.openbmc_project.ipmbsensor.service
+
+systemctl stop xyz.openbmc_project.adcsensor.service
+systemctl start xyz.openbmc_project.adcsensor.service
+
+systemctl stop xyz.openbmc_project.psusensor.service
+systemctl start xyz.openbmc_project.psusensor.service
+
+touch /var/tmp/acflag
+fi
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/disable-sw2.service b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/disable-sw2.service
new file mode 100755
index 0000000..eda9d31
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/disable-sw2.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Disable SW2
+Wants=xyz.openbmc_project.State.BMC.service
+After=xyz.openbmc_project.State.BMC.service
+After=xyz.openbmc_project.hwmontempsensor.service
+
+[Service]
+Type=simple
+ExecStart=/usr/bin/env disable-sw2.sh
+SyslogIdentifier=disable-sw2
+
+[Install]
+WantedBy=multi-user.target
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/disable-sw2.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/disable-sw2.sh
new file mode 100755
index 0000000..b671e24
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/disable-sw2.sh
@@ -0,0 +1,49 @@
+#!/bin/bash
+
+service="xyz.openbmc_project.State.BMC"
+interface="xyz.openbmc_project.State.BMC"
+object="/xyz/openbmc_project/state/bmc0"
+property="CurrentBMCState"
+BMC_state="NotReady"
+
+while [ $BMC_state != "Ready" ]; do
+    BMC_state=$(busctl get-property $service $object $interface $property | awk -F'"' '{print $2}' | awk -F'.' '{print $6}')
+    sleep 5
+done
+
+if [ ! -d "/sys/bus/i2c/devices/14-001f/hwmon" ]; then
+    echo " Didn't have switch port1 OCP card"
+    echo 0x1f > /sys/bus/i2c/devices/i2c-14/delete_device
+
+    pservice="xyz.openbmc_project.State.Chassis"
+    pinterface="xyz.openbmc_project.State.Chassis"
+    pobject="/xyz/openbmc_project/state/chassis0"
+    pproperty="CurrentPowerState"
+    Power_state="Off"
+
+    # check switch port4 OCP card (Intel-V710) when system power on
+    while [ $Power_state != "On" ]; do
+        Power_state=$(busctl get-property $pservice $pobject $pinterface $pproperty | awk -F'"' '{print $2}' | awk -F'.' '{print $6}')
+        sleep 5
+    done
+
+    if [ ! -d "/sys/bus/i2c/devices/17-001f/hwmon" ]; then
+        echo " Dir .../17-001f/hwmon does not exists , Re-scan port4 OCP card "
+        echo 0x1f > /sys/bus/i2c/devices/i2c-17/delete_device
+        echo tmp75 0x1f > /sys/bus/i2c/devices/i2c-17/new_device
+
+        if [ ! -d "/sys/bus/i2c/devices/17-001f/hwmon" ]; then
+            echo 0x51 > /sys/bus/i2c/devices/i2c-17/delete_device
+            echo 0x1f > /sys/bus/i2c/devices/i2c-17/delete_device
+            /usr/bin/gpioset gpiochip0 49=1
+            echo " Both OCP card does not exists , disable SW2 "
+        else
+            echo " switch port4 OCP card exists , re-scan FruDevice"
+            systemctl restart xyz.openbmc_project.FruDevice.service
+        fi
+    fi
+else
+    echo 0x51 > /sys/bus/i2c/devices/i2c-17/delete_device
+    echo 0x1f > /sys/bus/i2c/devices/i2c-17/delete_device
+    echo "Didn't have switch port4 OCP card"
+fi
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/initFruFlag.service b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/initFruFlag.service
new file mode 100755
index 0000000..6060cfe
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/initFruFlag.service
@@ -0,0 +1,15 @@
+[Unit]
+Description=initialize Fru Flag and Fru Data
+Wants=xyz.openbmc_project.State.BMC.service
+After=xyz.openbmc_project.State.BMC.service
+Requires=phosphor-ipmi-host.service
+After=phosphor-ipmi-host.service
+
+[Service]
+Type=simple
+ExecStart=/usr/bin/env initFruFlag.sh
+SyslogIdentifier=initFruFlag
+
+[Install]
+WantedBy=multi-user.target
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/initFruFlag.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/initFruFlag.sh
new file mode 100755
index 0000000..e7ccb8c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/initFruFlag.sh
@@ -0,0 +1,8 @@
+#! /bin/sh
+
+echo " Init Fru Flag & Get Fru Data "
+
+$(echo 1 > /usr/sbin/fruFlag)
+command=`ipmitool fru print 0`
+$(echo $command > /usr/sbin/fruData)
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/relinkLan.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/relinkLan.sh
new file mode 100755
index 0000000..696d208
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/relinkLan.sh
@@ -0,0 +1,5 @@
+#! /bin/sh
+
+echo " Start Re-link Lan Port "
+`ip link set eth0 down`
+`ip link set eth0 up`
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/restartNetIpmi.service b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/restartNetIpmi.service
new file mode 100755
index 0000000..2df9477
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/restartNetIpmi.service
@@ -0,0 +1,17 @@
+[Unit]
+Description=check ipmi command response and re-start NetIpmid service
+Wants=xyz.openbmc_project.State.BMC.service
+After=xyz.openbmc_project.State.BMC.service
+Requires=phosphor-ipmi-host.service
+After=phosphor-ipmi-host.service
+After=phosphor-ipmi-net@eth0.socket
+
+[Service]
+Restart=always
+Type=simple
+ExecStart=/usr/bin/env restartNetIpmi.sh
+SyslogIdentifier=restartNetIpmi
+
+[Install]
+WantedBy=multi-user.target
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/restartNetIpmi.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/restartNetIpmi.sh
new file mode 100755
index 0000000..0b8011d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/restartNetIpmi.sh
@@ -0,0 +1,40 @@
+#!/bin/bash
+
+echo " Start Check NetIpmid service"
+error=0
+
+while true; do
+
+    BMC_IP=$(ipmitool lan print | awk '/^IP Address  /{print $4}')
+
+    if [ "$BMC_IP" != "0.0.0.0" ]; then
+
+        # get device ID via out-band ipmi command
+        DeviceID_rep=$(ipmitool -I lanplus -H $BMC_IP -U root -P root raw 6 1)
+
+        if [ -z "$DeviceID_rep" ]; then
+
+            for (( i=0; i<5; i++))
+            do
+                DeviceID_rep=$(ipmitool -I lanplus -H $BMC_IP -U root -P root raw 6 1)
+                if [ -z "$DeviceID_rep" ]; then
+                    (( error++ ))
+                fi
+            done
+            
+            # check error >= 5 , re-start phosphor-ipmi-net@.service
+            if [ $error -ge 5 ]; then
+                echo " Re-Start phosphor-ipmi-net service"
+                systemctl restart phosphor-ipmi-net@eth0.service
+                error=0
+                sleep 10
+            fi
+        else
+            error=0
+            sleep 10
+        fi
+    else
+        error=0
+        sleep 10
+    fi
+done
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/writeFRU.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/writeFRU.sh
new file mode 100755
index 0000000..d94226f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/files/writeFRU.sh
@@ -0,0 +1,20 @@
+#! /bin/sh
+
+echo " Start Write Fru Data "
+
+i=0
+
+while read line
+do
+    str[$i]=$line
+    data=`ipmitool fru edit 0 field ${str[$i]}`
+
+    sleep 3
+    i=`expr $i + 1`
+done < /usr/sbin/fruWrite
+
+`rm -rf /usr/sbin/fruWrite`
+
+echo " writeFRU : finish update fru data , clear flag to 0 "
+`echo 0 > /usr/sbin/fruFlag`
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/mct-default-action.bb b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/mct-default-action.bb
new file mode 100755
index 0000000..6f0000a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-default-action/mct-default-action.bb
@@ -0,0 +1,32 @@
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+FILESEXTRAPATHS_append := "${THISDIR}/files:"
+
+inherit systemd
+inherit obmc-phosphor-systemd
+
+S = "${WORKDIR}/"
+
+SRC_URI = " \
+           file://initFruFlag.service \
+           file://initFruFlag.sh \
+           file://writeFRU.sh \
+           file://relinkLan.sh \
+           "
+
+DEPENDS = "systemd"
+RDEPENDS_${PN} = "bash"
+
+SYSTEMD_PACKAGES = "${PN}"
+SYSTEMD_SERVICE_${PN} = " \
+                         initFruFlag.service \
+                         "
+
+
+do_install() {
+    install -d ${D}/usr/sbin
+    install -m 0755 ${S}initFruFlag.sh ${D}/${sbindir}/
+    install -m 0755 ${S}writeFRU.sh ${D}/${sbindir}/
+    install -m 0755 ${S}relinkLan.sh ${D}/${sbindir}/
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/CMakeLists.txt b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/CMakeLists.txt
new file mode 100755
index 0000000..e2c57bb
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/CMakeLists.txt
@@ -0,0 +1,58 @@
+cmake_minimum_required (VERSION 3.5 FATAL_ERROR)
+
+cmake_policy (SET CMP0054 NEW)
+
+option (YOCTO "Use YOCTO depedencies system" OFF)
+include (ExternalProject)
+set (CMAKE_CXX_STANDARD 17)
+set (CMAKE_CXX_STANDARD_REQUIRED ON)
+set (CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})
+
+set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-rtti")
+
+project (mct-ipmi-oem CXX)
+
+add_definitions (-DBOOST_ERROR_CODE_HEADER_ONLY)
+add_definitions (-DBOOST_SYSTEM_NO_DEPRECATED)
+add_definitions (-DBOOST_ALL_NO_LIB)
+add_definitions (-DBOOST_NO_RTTI)
+add_definitions (-DBOOST_NO_TYPEID)
+add_definitions (-DBOOST_ASIO_DISABLE_THREADS)
+add_definitions (-DBOOST_COROUTINES_NO_DEPRECATION_WARNING)
+add_definitions (-Wno-psabi)
+
+if (YOCTO)
+    find_package (PkgConfig REQUIRED)
+    pkg_check_modules (LOGGING phosphor-logging REQUIRED)
+    include_directories (${LOGGING_INCLUDE_DIRS})
+    link_directories (${LOGGING_LIBRARY_DIRS})
+
+    pkg_check_modules (LIBIPMID libipmid REQUIRED)
+    include_directories (${LIBIPMID_INCLUDE_DIRS})
+    link_directories (${LIBIPMID_LIBRARY_DIRS})
+
+endif ()
+
+include_directories (${CMAKE_CURRENT_SOURCE_DIR})
+
+#
+# import OpenSSL (crypto)
+find_package (OpenSSL REQUIRED)
+include_directories (${OPENSSL_INCLUDE_DIR})
+
+add_library (
+    mctoemcmds SHARED oemcmd.cpp
+)
+set_target_properties (mctoemcmds PROPERTIES VERSION "0.1.0")
+set_target_properties (mctoemcmds PROPERTIES SOVERSION "0")
+target_link_libraries (mctoemcmds stdc++fs)
+target_link_libraries (mctoemcmds ipmid)
+target_link_libraries (mctoemcmds sdbusplus)
+target_link_libraries (mctoemcmds phosphor_logging)
+target_link_libraries (mctoemcmds -luserlayer)
+target_link_libraries (mctoemcmds -lchannellayer)
+target_link_libraries (mctoemcmds gpiodcxx)
+target_link_libraries (mctoemcmds ${OPENSSL_CRYPTO_LIBRARY})
+target_link_libraries (mctoemcmds peci)
+
+install (TARGETS mctoemcmds DESTINATION lib/ipmid-providers)
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/LICENSE b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/LICENSE
new file mode 100755
index 0000000..8f71f43
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/LICENSE
@@ -0,0 +1,202 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/oemcmd.cpp b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/oemcmd.cpp
new file mode 100755
index 0000000..eb7ed5f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/oemcmd.cpp
@@ -0,0 +1,1576 @@
+#include "oemcmd.hpp"
+#include <host-ipmid/ipmid-api.h>
+#include <fstream>
+#include <stdio.h>
+#include <string.h>
+#include <systemd/sd-bus.h>
+#include <endian.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <iostream>
+#include <boost/algorithm/string.hpp>
+
+#include <linux/types.h>
+#include <sdbusplus/bus.hpp>
+#include <sdbusplus/bus/match.hpp>
+#include <sdbusplus/message.hpp>
+#include <sdbusplus/vtable.hpp>
+#include <sdbusplus/server/interface.hpp>
+#include <sdbusplus/timer.hpp>
+#include <gpiod.hpp>
+
+#include <ipmid/api.hpp>
+#include <ipmid/utils.hpp>
+#include <phosphor-logging/log.hpp>
+#include <phosphor-logging/elog-errors.hpp>
+#include <sdbusplus/bus.hpp>
+#include <sdbusplus/message/types.hpp>
+#include <peci.h>
+#include <nlohmann/json.hpp>
+
+
+#include "xyz/openbmc_project/Control/Power/RestorePolicy/server.hpp"
+
+#define FSC_SERVICE "xyz.openbmc_project.EntityManager"
+#define FSC_OBJECTPATH "/xyz/openbmc_project/inventory/system/board/s5549_Baseboard/Pid_"
+#define PID_INTERFACE "xyz.openbmc_project.Configuration.Pid.Zone"
+#define PROPERTY_INTERFACE "org.freedesktop.DBus.Properties"
+
+#include<filesystem>
+
+using phosphor::logging::level;
+using phosphor::logging::log;
+
+using namespace phosphor::logging;
+using namespace sdbusplus::xyz::openbmc_project::Control::Power::server;
+
+namespace fs = std::filesystem;
+
+namespace ipmi
+{
+
+static int getProperty(sdbusplus::bus::bus& bus, const std::string& path,
+                 const std::string& property, double& value, const std::string service, const std::string interface)
+{
+    sdbusplus::message::variant<double> valuetmp;
+    auto method = bus.new_method_call(service.c_str(), path.c_str(), PROPERTY_INTERFACE, "Get");
+    method.append(interface.c_str(),property);
+    try
+    {
+        auto reply=bus.call(method);
+        if (reply.is_method_error())
+        {
+            std::printf("Error looking up services, PATH=%s",interface.c_str());
+            return -1;
+        }
+        reply.read(valuetmp);
+    }
+    catch (const sdbusplus::exception::SdBusError& e){
+        return -1;
+    }
+
+    value = std::get<double>(valuetmp);
+    return 0;
+}
+
+static void setProperty(sdbusplus::bus::bus& bus, const std::string& path,
+                 const std::string& property, const double value)
+{
+    auto method = bus.new_method_call(FSC_SERVICE, path.c_str(),
+                                      PROPERTY_INTERFACE, "Set");
+    method.append(PID_INTERFACE, property, sdbusplus::message::variant<double>(value));
+	
+    bus.call_noreply(method);
+
+    return;
+}
+
+void register_netfn_mct_oem() __attribute__((constructor));
+
+int execmd(char* cmd,char* result) {
+        char buffer[128];
+        FILE* pipe = popen(cmd, "r");
+        if (!pipe)
+                return -1;
+
+        while(!feof(pipe)) {
+                if(fgets(buffer, 128, pipe)){
+                        strcat(result,buffer);
+                }
+        }
+        pclose(pipe);
+        return 0;
+}
+
+std::unique_ptr<phosphor::Timer> clrCmosTimer = nullptr;
+#define AST_GPIO_F1_PIN 41 
+bool clrCmos()
+{
+#if 0    
+    //todo : move to device tree by assigned name 
+    auto line = gpiod::find_line("CLR_CMOS");
+        
+    if (!line)
+    {
+        return false;
+    }
+#endif 
+    auto chip = gpiod::chip("gpiochip0");
+    auto line = chip.get_line(AST_GPIO_F1_PIN);
+    if (!line)
+    {
+        std::cerr << "Error requesting gpio AST_GPIO_F1_PIN\n";
+        return false;
+    }
+#if 0
+    auto dir = line.direction();
+    std::cerr << "direction :" <<dir<<"\n";
+#endif 
+    int value = 1;
+
+    try
+    {
+        line.request({"ipmid", gpiod::line_request::DIRECTION_OUTPUT,0}, value);
+    }
+    catch (std::system_error&)
+    {
+        std::cerr << "Error requesting gpio\n";
+        return false;
+    }
+
+    line.set_value(0);
+    sleep(3);
+    line.set_value(1);
+    
+    line.release();
+    return true;
+
+}
+void createTimer()
+{
+    if (clrCmosTimer == nullptr)
+    {
+        clrCmosTimer = std::make_unique<phosphor::Timer>(clrCmos);
+    }
+}
+
+/* Clear CMOS command
+NetFun: 0x30
+Cmd : 0x3A
+Request:
+
+Response:
+        Byte 1 : Completion Code
+*/
+ipmi::RspType<> ipmi_opma_clear_cmos()
+{
+    //todo, check pgood status
+    createTimer();
+    if (clrCmosTimer == nullptr)
+    {
+        return ipmi::responseResponseError();
+    }
+    
+    if(clrCmosTimer->isRunning())
+    {
+        return ipmi::responseResponseError();
+    }
+    clrCmosTimer->start(std::chrono::duration_cast<std::chrono::microseconds>(
+    std::chrono::seconds(0)));    
+   
+    return ipmi::responseSuccess();
+}
+//===============================================================
+/* Set Fan Control Enable Command
+NetFun: 0x2E
+Cmd : 0x06
+Request:
+        Byte 1-3 : Tyan Manufactures ID (FD 19 00)
+        Byte 4 :  0h - Fan Control Disable
+                  1h - Fan Control Enable
+                  ffh - Get Current Fan Control Status
+Response:
+        Byte 1 : Completion Code
+        Byte 2-4 : Tyan Manufactures ID
+        Byte (5) : Current Fan Control Status , present if FFh passed to Enable Fan Control in Request
+*/
+ipmi::RspType<uint8_t> ipmi_tyan_ManufactureMode(uint8_t mode)
+{
+    std::fstream file;
+    int rc=0;
+    char command[100];
+    char FSCStatus[100];
+    uint8_t currentStatus;
+    char Object[100];
+    auto bus = sdbusplus::bus::new_default();
+
+    if (mode == 0)
+    {
+        // Disable Fan Control
+        memset(command,0,sizeof(command));
+        sprintf(command, "systemctl stop phosphor-pid-control.service");
+        rc = system(command);
+    
+        memset(command,0,sizeof(command));
+        sprintf(command, "echo 0 > /usr/sbin/fsc");
+        system(command);
+
+		// Set all fan to Full Duty
+		for(size_t i = 1; i <= 5; i++)
+		{
+			memset(command,0,sizeof(command));
+			sprintf(command, "echo 255 > /sys/class/hwmon/hwmon0/pwm%d",i);
+			rc = system(command);
+		}
+    }
+    else if (mode == 1)
+    {
+        // Enable Fan Control
+        memset(command,0,sizeof(command));
+        sprintf(command, "systemctl start phosphor-pid-control.service");
+        rc = system(command);
+
+        memset(command,0,sizeof(command));
+        sprintf(command, "echo 1 > /usr/sbin/fsc");
+        system(command);
+
+        //Set Floor Duty Cycle control by sensors
+        for(size_t i = 1; i <= 5; i++)
+        {
+            memset(Object,0,sizeof(Object));
+            snprintf(Object,sizeof(Object),"%s%d",FSC_OBJECTPATH,i);
+            setProperty(bus,Object,"CommandSet",0);
+        }
+    }
+    else if (mode == 0xff)
+    {
+        // Get Current Fan Control Status
+        file.open("/usr/sbin/fsc",std::ios::in);
+        if(!file)
+        {
+            memset(command,0,sizeof(command));
+            sprintf(command, "touch /usr/sbin/fsc");
+            system(command);
+
+            memset(command,0,sizeof(command));
+            sprintf(command, "echo 1 > /usr/sbin/fsc");
+            system(command);
+
+            currentStatus=1;
+        }
+        else
+        {
+            file.read(FSCStatus,sizeof(FSCStatus));
+            currentStatus = strtol(FSCStatus,NULL,16);
+        }
+        file.close();
+        return ipmi::responseSuccess(currentStatus);
+    }
+    else
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    if (rc != 0)
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess();
+}
+//===============================================================
+
+/* Set Fan Control PWM Duty Command
+NetFun: 0x2E
+Cmd : 0x05
+Request:
+        Byte 1-3 : Tyan Manufactures ID (FD 19 00)
+        Byte 4 : PWM ID ( 0h-PWM1 , ... , 4h-PWM5 )
+        Byte 5 : Duty Cycle
+            0-64h - manual control duty cycle (0%-100%)
+            FEh - Get current duty cycle
+            FFh - Return to automatic control
+Response:
+        Byte 1 : Completion Code
+        Byte 2-4 : Tyan Manufactures ID
+        Byte (5) : Current Duty Cycle , present if 0xFE passed to Duty Cycle in Request
+*/
+ipmi::RspType<uint8_t> ipmi_tyan_FanPwmDuty(uint8_t pwmId, uint8_t duty)
+{
+    std::fstream file;
+    int rc=0;
+    char command[100];
+    char temp[50];
+    uint8_t responseDuty;
+    uint8_t pwmValue = 0;
+    char FSCStatus[100];
+    uint8_t currentStatus;
+
+    if (duty == 0xfe)
+    {
+        // Get current duty cycle
+        switch (pwmId)
+        {
+            case 0:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "cat /sys/class/hwmon/hwmon0/pwm1");
+                    break;
+            case 1:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "cat /sys/class/hwmon/hwmon0/pwm2");
+                    break;
+            case 2:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "cat /sys/class/hwmon/hwmon0/pwm3");
+                    break;
+            case 3:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "cat /sys/class/hwmon/hwmon0/pwm4");
+                    break;
+            case 4:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "cat /sys/class/hwmon/hwmon0/pwm5");
+                    break;
+            default:
+                    return ipmi::responseParmOutOfRange();
+        }
+
+        memset(temp, 0, sizeof(temp));
+        rc = execmd((char *)command, temp);
+
+        if (rc != 0)
+        {
+            return ipmi::responseUnspecifiedError();
+        }
+
+        pwmValue = strtol(temp,NULL,10);
+        responseDuty = pwmValue*100/255;
+        return ipmi::responseSuccess(responseDuty);
+    }
+    else if (duty == 0xff)
+    {
+        // Return to automatic control
+        memset(command,0,sizeof(command));
+        sprintf(command, "systemctl start phosphor-pid-control.service");
+        rc = system(command);
+
+        memset(command,0,sizeof(command));
+        sprintf(command, "echo 1 > /usr/sbin/fsc");
+        system(command);
+    }
+    else if (duty <= 0x64)
+    {
+        // Get Current Fan Control Status
+        file.open("/usr/sbin/fsc",std::ios::in);
+        if(!file)
+        {
+            currentStatus=1;
+        }
+        else
+        {
+            file.read(FSCStatus,sizeof(FSCStatus));
+            currentStatus = strtol(FSCStatus,NULL,16);
+        }
+        file.close();
+
+        if(currentStatus == 0x0)
+        {
+            // control duty cycle (0%-100%)
+            pwmValue = duty*255/100;
+
+            switch (pwmId)
+            {
+                case 0:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "echo %d > /sys/class/hwmon/hwmon0/pwm1", pwmValue);
+                    break;
+                case 1:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "echo %d > /sys/class/hwmon/hwmon0/pwm2", pwmValue);
+                    break;
+                case 2:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "echo %d > /sys/class/hwmon/hwmon0/pwm3", pwmValue);
+                    break;
+                case 3:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "echo %d > /sys/class/hwmon/hwmon0/pwm4", pwmValue);
+                    break;
+                case 4:
+                    memset(command,0,sizeof(command));
+                    sprintf(command, "echo %d > /sys/class/hwmon/hwmon0/pwm5", pwmValue);
+                    break;
+                default:
+                    return ipmi::responseParmOutOfRange();
+            }
+            rc = system(command);
+        }
+        else
+        {
+            // fan control is Enable , can't control fan duty
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else
+    {
+        return ipmi::responseParmOutOfRange();
+    }
+
+    if (rc != 0)
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess();
+}
+//===============================================================
+/* Set Floor Duty Command
+NetFun: 0x2E
+Cmd : 0x07
+Request:
+        Byte 1-3 : Tyan Manufactures ID (FD 19 00)
+        Byte 4 :  0h~64h - Floor Duty cycle
+                     ffh - Get Current Floor Duty Cycle
+Response:
+        Byte 1 : Completion Code
+        Byte 2-4 : Tyan Manufactures ID
+        Byte (5) : Current Floor Duty Cycle , present if FFh passed to Byte4 in Request
+        	[7] : Floor Duty Cycle control source 
+        		0b - by sensor.
+        		1b - by command.
+        	[6:0] : Floor Duty cycle.
+*/
+ipmi::RspType<uint8_t> ipmi_tyan_FloorDuty(uint8_t floorDuty)
+{
+    int rc=0;
+    char Object[100];
+	double responseData;
+    uint8_t currentFloorDuty;
+	uint8_t controlSource;
+	
+	auto bus = sdbusplus::bus::new_default();
+
+    if (floorDuty <= 0x64)
+    {
+        //Set Floor Duty Cycle
+		for(size_t i = 1; i <= 5; i++)
+		{
+			memset(Object,0,sizeof(Object));
+			snprintf(Object,sizeof(Object),"%s%d",FSC_OBJECTPATH,i);
+			setProperty(bus,Object,"CommandSet",1);
+			setProperty(bus,Object,"FloorDuty",static_cast<double>(floorDuty));
+		}
+    }
+    else if (floorDuty == 0xff)
+    {
+        // Get Floor Duty Cycle
+		memset(Object,0,sizeof(Object));
+		snprintf(Object,sizeof(Object),"%s%d",FSC_OBJECTPATH,1);
+		
+		rc = getProperty(bus,Object,"FloorDuty",responseData,FSC_SERVICE,PID_INTERFACE);
+		if(rc<0)
+		{
+			return ipmi::responseUnspecifiedError();
+		}
+
+		currentFloorDuty = static_cast<uint8_t>(responseData);
+		
+		rc = getProperty(bus,Object,"CommandSet",responseData,FSC_SERVICE,PID_INTERFACE);
+		if(rc<0)
+		{
+			return ipmi::responseUnspecifiedError();
+		}
+
+		controlSource = static_cast<uint8_t>(responseData);
+		if (controlSource == 1)
+		{
+			currentFloorDuty = currentFloorDuty + 0x80;
+		}
+		
+		return ipmi::responseSuccess(currentFloorDuty);
+
+    }
+	else if (floorDuty == 0xfe)
+	{
+		//Set Floor Duty Cycle control by sensors 
+		for(size_t i = 1; i <= 5; i++)
+		{
+			memset(Object,0,sizeof(Object));
+			snprintf(Object,sizeof(Object),"%s%d",FSC_OBJECTPATH,i);
+			setProperty(bus,Object,"CommandSet",0);
+		}
+	}
+	else
+	{
+		return ipmi::responseParmOutOfRange();
+	}
+    
+    return ipmi::responseSuccess();
+}
+//===============================================================
+/* Config EccLeaky Bucket Command
+NetFun: 0x2E
+Cmd : 0x1A
+Request:
+        Byte 1-3 : Tyan Manufactures ID (FD 19 00)
+        Byte (4) : optional, set T1 
+        Byte (5) : optional, set T2 
+
+Response:
+        Byte 1 : Completion Code
+        Byte 2-4 : Tyan Manufactures ID
+        Byte (5) : Return current T1 if request length = 3. 
+        Byte (6) : Return current T2 if request length = 3.
+*/
+ipmi::RspType<std::optional<uint8_t>, // T1 
+              std::optional<uint8_t>  // T2
+              >
+    ipmi_tyan_ConfigEccLeakyBucket(std::optional<uint8_t> T1, std::optional<uint8_t> T2)
+{
+
+    constexpr const char* leakyBucktPath =
+        "/xyz/openbmc_project/leakyBucket/HOST_DIMM_ECC";
+    constexpr const char* leakyBucktIntf =
+        "xyz.openbmc_project.Sensor.Value";
+    std::shared_ptr<sdbusplus::asio::connection> busp = getSdBus();
+    uint8_t t1;
+    uint8_t t2;
+    ipmi::Value result;
+
+    auto service = ipmi::getService(*busp, leakyBucktIntf, leakyBucktPath);
+    
+    //get t1,t2
+    if(!T1) 
+    {
+        try
+        {
+            result = ipmi::getDbusProperty(
+                    *busp, service, leakyBucktPath, leakyBucktIntf, "T1");    
+            t1 = std::get<uint8_t>(result);
+
+            result = ipmi::getDbusProperty(
+                *busp, service, leakyBucktPath, leakyBucktIntf, "T2");
+            t2 = std::get<uint8_t>(result);
+        
+        }
+        catch (const std::exception& e)
+        {
+            return ipmi::responseUnspecifiedError();
+        }
+        return ipmi::responseSuccess(t1,t2);
+    }
+
+    //t1 found 
+    try
+    {
+       ipmi::setDbusProperty(
+                *busp, service, leakyBucktPath, leakyBucktIntf, "T1", T1.value());    
+    }
+    catch (const std::exception& e)
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    if(T2)
+    {
+        try
+        {
+            ipmi::setDbusProperty(
+                    *busp, service, leakyBucktPath, leakyBucktIntf, "T2", T2.value());    
+        }
+        catch (const std::exception& e)
+        {
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    return ipmi::responseSuccess();
+   
+}
+
+
+
+//================================================================================================
+static boost::container::flat_map<uint8_t, std::string> eccMap;
+
+//MCT ecc filter
+static constexpr const char* sdrFile = "/usr/share/ipmi-providers/sdr.json";
+constexpr static const uint16_t biosId = 0x3f;
+constexpr static const uint8_t sensorTypeMemory = 0xc;
+constexpr static const uint8_t eventDataMemCorrectableEcc = 0;
+
+static void loadEccMap(void)
+{
+    static bool loaded = false;
+    uint16_t ownerId;
+    uint8_t sensorNum;
+    uint8_t sensorType;
+    std::string sensorName;
+    
+    if(loaded)
+    {
+        return; 
+    }
+    loaded = true; 
+
+    eccMap.clear();
+    std::ifstream sdrStream(sdrFile);
+    if(!sdrStream.is_open())
+    {
+        std::cerr << "NO defined SDR found\n";
+    }
+    else
+    {
+        auto data = nlohmann::json::parse(sdrStream, nullptr, false);
+        if (data.is_discarded())
+        {
+            std::cerr << "syntax error in " << sdrFile << "\n";
+        }
+        else
+        {
+            int idx = 0;
+            while (!data[idx].is_null())
+            {
+                ownerId = std::stoul((std::string)data[idx]["ownerId"], nullptr, 16);  
+                sensorNum = std::stoul((std::string)data[idx]["sensorNumber"], nullptr, 16);   
+                sensorType = std::stoul((std::string)data[idx]["sensorType"], nullptr, 16);
+                sensorName = data[idx]["sensorName"];
+                if(biosId == ownerId && sensorTypeMemory == sensorType)
+                {
+                    eccMap[sensorNum] = sensorName;
+                }
+                idx++;
+            }
+        }
+        sdrStream.close();
+    }
+   
+    for(auto const& pair:eccMap)
+    {
+        std::cerr << (unsigned)pair.first << ":" << pair.second << '\n';
+    }
+   
+}
+
+/*-------------------------------------
+ * OemGetEccCount(NetFn: 0x2E, Cmd: 0x1B)
+ * Request:
+ *   Byte 1: 0xfd
+ *   Byte 2: 0x19
+ *   Byte 3: 0x00
+ *   Byte 4: DIMM (Sensor Number for ECC event)
+ * Response:
+ *   Byte 1: Completion Code
+ *   Byte 2: 0xfd
+ *   Byte 3: 0x19
+ *   Byte 4: 0x00
+ *   Byte 5: Correctable ECC Count
+ *------------------------------------*/
+ipmi::RspType<uint8_t> ipmiGetEccCount(uint8_t sensorNum)
+{
+
+    constexpr const char* leakyBucktPath =
+        "/xyz/openbmc_project/leakyBucket/HOST_DIMM_ECC";
+    constexpr const char* leakyBucktIntf =
+        "xyz.openbmc_project.Sensor.Value";
+    std::shared_ptr<sdbusplus::asio::connection> busp = getSdBus();
+    ipmi::Value result;
+    uint8_t count;
+    loadEccMap();
+
+    auto ecc = eccMap.find(sensorNum);
+    //find ecc in eccMap
+    if (ecc == eccMap.end())
+    {
+        return ipmi::responseInvalidFieldRequest();
+    }
+
+    std::string sensorPath = "/xyz/openbmc_project/leakyBucket/HOST_DIMM_ECC/"+ecc->second;
+    
+    auto service = ipmi::getService(*busp, leakyBucktIntf, leakyBucktPath);
+
+    //get count
+    try
+    {
+        result = ipmi::getDbusProperty(
+                    *busp, service, sensorPath, leakyBucktIntf, "count");    
+        count = std::get<uint8_t>(result);
+    }
+    catch (const std::exception& e)
+    {
+        //ecc bucket is not created, return count as 0;    
+        return ipmi::responseSuccess(0);
+    }
+    return ipmi::responseSuccess(count);
+   
+}
+
+//======================================================================================================
+/* get gpio status Command (for manufacturing) 
+NetFun: 0x2E
+Cmd : 0x41
+Request:
+        Byte 1-3 : Tyan IANA ID (FD 19 00)
+        Byte 4 : gpio number 
+Response:
+        Byte 1 : Completion Code
+        Byte 2-4 : Tyan IANA
+        Byte 5 : gpio direction 
+        Byte 6 : gpio data
+*/
+ipmi::RspType<uint8_t,
+              uint8_t>
+    ipmi_tyan_getGpio(uint8_t gpioNo)
+{
+    auto chip = gpiod::chip("gpiochip0");
+    auto line = chip.get_line(gpioNo);
+    
+    if (!line)
+    {
+        std::cerr << "Error requesting gpio\n";
+        return ipmi::responseUnspecifiedError();
+    }
+    auto dir = line.direction();
+
+    bool resp;
+    try
+    {
+        line.request({"ipmid", gpiod::line_request::DIRECTION_INPUT,0});
+        resp = line.get_value();
+    }
+    catch (std::system_error&)
+    {
+        std::cerr << "Error reading gpio: " << (unsigned)gpioNo << "\n";
+        return ipmi::responseUnspecifiedError();
+    }
+  
+    line.release();
+    return ipmi::responseSuccess((uint8_t)dir, (uint8_t)resp);
+}
+
+//===============================================================
+/* Power Node Manager Oem Get Reading
+NetFun: 0x30
+Cmd : 0xE2
+Request:
+        Byte 1 : [0:3] Domain ID / [4:7] Reading Type
+        Byte 2 : Optional Parameter.
+        Byte 3 : Reserved. Write as 00h.
+
+Response:
+        Byte 1 : Completion Code
+        Byte 2 : [0:3] Domain ID / [4:7] Reading Type
+        Byte 3-4 : Reading value 16-bit encoding 2s-complement signed integer.
+*/
+
+#define PIN_OBJECT "/xyz/openbmc_project/sensors/power/PSU0_Input_Power"
+#define PIN_SERVICE "xyz.openbmc_project.PSUSensor"
+#define PIN_INTERFACE "xyz.openbmc_project.Sensor.Value"
+
+ipmi::RspType<std::vector<uint8_t>> ipmi_Pnm_GetReading(uint8_t type, uint8_t reserved1, uint8_t reserved2)
+{
+    uint8_t domainID;
+    uint8_t readingType;
+    uint8_t highByte;
+    uint8_t lowByte;
+    int rc=0;
+    double readingValue;
+    std::vector<uint8_t> responseData(3,0);
+
+    auto bus = sdbusplus::bus::new_default();
+
+    domainID = type & 0x0F;
+    readingType = type >> 4;
+    if (readingType == 0x00 || readingType == 0x06)
+    {
+        // get PSU PIN sensor reading value
+        rc = getProperty(bus,PIN_OBJECT,"Value",readingValue,PIN_SERVICE,PIN_INTERFACE);
+        if(rc<0)
+        {
+            return ipmi::responseUnspecifiedError();
+        }
+
+        highByte = static_cast<uint16_t>(readingValue) >> 8;
+        lowByte = static_cast<uint16_t>(readingValue) & 0x00FF;
+        responseData[1]=lowByte;
+        responseData[2]=highByte;
+    }
+
+    responseData[0]=type;
+
+    return ipmi::responseSuccess(responseData);
+}
+
+//===============================================================
+/* Set FRU Field Command
+NetFun: 0x2E
+Cmd : 0x0B
+Request:
+    Byte 1-3 : Tyan Manufactures ID (FD 19 00)
+    Byte 4 :  FRU ID
+    Byte 5 :  Item
+        [7:4] : Area (1-Chassis Info , 2-Board Info , 3-Product Info)
+        [3:0] : Field
+    Byte 6-N : Data
+Response:
+    Byte 1 : Completion Code
+    Byte 2-4 : Tyan Manufactures ID
+*/
+ipmi::RspType<> ipmi_setFruField(uint8_t fruId, uint4_t field, uint4_t area, std::vector<uint8_t> dataInfo)
+
+{
+    std::string s;
+    size_t pos;
+    char command[100];
+    char cmd[100];
+    char string[100];
+
+    if(fruId != 0)
+    {
+        // Currently, only support FRU ID 0
+        return ipmi::responseReqDataLenInvalid();
+    }
+
+    for(int i=0; i<dataInfo.size(); i++)
+    {
+        s += (char)dataInfo[i];
+    }
+
+    strcpy(string,s.c_str());
+    memset(command,0,sizeof(command));
+
+    switch ((uint8_t)area)
+    {
+        case 0:
+            // flag
+            snprintf(command,sizeof(command),"echo %d > /usr/sbin/fruFlag",dataInfo[0]);
+
+            if(dataInfo[0] == 2)
+            {
+                memset(cmd,0,sizeof(cmd));
+                snprintf(cmd,sizeof(cmd),"/usr/sbin/writeFRU.sh &",dataInfo[0]);
+                system(cmd);
+            }
+            break;
+        case 1:
+            // chassis information are
+            snprintf(command,sizeof(command),"echo c %d %s >> /usr/sbin/fruWrite",(int)field-1,string);
+            break;
+        case 2:
+            // board information area
+            snprintf(command,sizeof(command),"echo b %d %s >> /usr/sbin/fruWrite",(int)field,string);
+            break;
+        case 3:
+            // product information area
+            snprintf(command,sizeof(command),"echo p %d %s >> /usr/sbin/fruWrite",(int)field,string);
+            break;
+        default:
+            return ipmi::responseParmOutOfRange();
+    }
+
+    system(command);
+    return ipmi::responseSuccess();
+}
+
+std::string getFruData()
+{
+    std::string str;
+    char command[100];
+
+    if(fs::exists("/usr/sbin/fruData"))
+    {
+        std::ifstream file("/usr/sbin/fruData", std::ios::in);
+
+        auto data = std::vector<uint8_t>(std::istreambuf_iterator<char>(file),
+                                     std::istreambuf_iterator<char>());
+        if (file.fail())
+        {
+            std::cout << "read FRU Data fail" << std::endl;
+        }
+        file.close();
+
+        for(int i=0; i<data.size(); i++)
+        {
+            str += (char)data[i];
+        }
+    }
+    else
+    {
+        memset(command,0,sizeof(command));
+        sprintf(command, "ipmitool fru print 0 > /usr/sbin/fruData &");
+        system(command);
+    }
+    return str;
+}
+
+std::string areaData(std::string str, std::string str1, std::string str2)
+{
+    std::string string;
+    std::string::size_type pos,pos1;
+    std::string STR;
+
+    pos = str.find(str1);
+    if(pos != std::string::npos)
+    {
+        string = str.substr(pos);
+        pos = string.find(":");
+        pos1 = string.find(str2);
+        if(pos1 != std::string::npos)
+        {
+            STR = string.substr(pos+2,(pos1-pos-3));
+        }
+        else
+        {
+            STR = string.substr (pos+2);
+        }
+    }
+    return STR;
+}
+
+//===============================================================
+/* Get FRU Field Command
+NetFun: 0x2E
+Cmd : 0x0C
+Request:
+    Byte 1-3 : Tyan Manufactures ID (FD 19 00)
+    Byte 4 :  FRU ID
+    Byte 5 :  Item
+        [7:4] : Area (1-Chassis Info , 2-Board Info , 3-Product Info)
+        [3:0] : Field
+Response:
+    Byte 1 : Completion Code
+    Byte 2-4 : Tyan Manufactures ID
+    Byte 5-N : Data
+*/
+ipmi::RspType<std::vector<uint8_t>> ipmi_getFruField(uint8_t fruId, uint4_t field, uint4_t area)
+{
+
+    int rc=0;
+    char command[100],temp[50];
+    char string[100];
+    size_t pos;
+    std::string str,str1,str2;
+    uint8_t f;
+
+    if(fruId != 0)
+    {
+        // Currently, only support FRU ID 0
+        return ipmi::responseReqDataLenInvalid();
+    }
+
+    if(area > 0x3)
+    {
+        //fail Area
+        return ipmi::responseInvalidFieldRequest();
+    }
+    else if(area == 0x0)
+    {
+        //flag
+        if(fs::exists("/usr/sbin/fruFlag"))
+        {
+            memset(command,0,sizeof(command));
+            memset(temp, 0, sizeof(temp));
+            sprintf(command, "cat /usr/sbin/fruFlag");
+            rc = execmd((char *)command, temp);
+            if (rc != 0)
+            {
+                return ipmi::responseUnspecifiedError();
+            }
+
+            f = strtol(temp,NULL,10);
+            std::vector<uint8_t> flag = {f};
+            return ipmi::responseSuccess(flag);
+        }
+        else
+        {
+            return ipmi::responseInvalidFieldRequest();
+        }
+    }
+    else
+    {
+        str=getFruData();
+
+        switch ((uint8_t)area)
+        {
+            case 1:
+                // chassis information are
+                switch((uint8_t)field)
+                {
+                    case 0:
+                        // chassis type
+                        str2 = areaData(str,"Chassis Type","Chassis Part");
+                        break;
+                    case 1:
+                        // chassis part number
+                        str2 = areaData(str,"Chassis Part","Chassis Serial");
+                        break;
+                    case 2:
+                        // chassis serial number
+                        str2 = areaData(str,"Chassis Serial","Chassis Extra");
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case 2:
+                // board information area
+                pos = str.find("Board Mfg Date");
+                str1 = str.substr(pos+14);
+                switch((uint8_t)field)
+                {
+                    case 0:
+                        // board manufacturer
+                        str2 = areaData(str1,"Board Mfg","Board Product");
+                        break;
+                    case 1:
+                        // board product name
+                        str2 = areaData(str1,"Board Product","Board Serial");
+                        break;
+                    case 2:
+                        // board serial number
+                        str2 = areaData(str1,"Board Serial","Board Part");
+                        break;
+                    case 3:
+                        // board part number
+                        str2 = areaData(str1,"Board Part","Product Name");
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case 3:
+                // product information area
+                switch((uint8_t)field)
+                {
+                    case 0:
+                        // product manufacturer
+                        str2 = areaData(str,"Product Manufacturer","Product Name");
+                        break;
+                    case 1:
+                        // product name
+                        str2 = areaData(str,"Product Name","Product Part");
+                        break;
+                    case 2:
+                        // product part / model number
+                        str2 = areaData(str,"Product Part","Product Version");
+                        break;
+                    case 3:
+                        // product version
+                        str2 = areaData(str,"Product Version","Product Serial");
+                        break;
+                    case 4:
+                        // product serial number
+                        str2 = areaData(str,"Product Serial","Product Asset");
+                        break;
+                    default:
+                        break;
+                }
+                break;
+        }
+    }
+
+    if(str2.length()== 0)
+    {
+        return ipmi::responseInvalidFieldRequest();
+    }
+
+    if((char)str2[str2.length()-1] == 0xa)
+    {
+        str2.pop_back();
+    }
+
+    std::vector<uint8_t> DATA(str2.begin(), str2.end());
+    return ipmi::responseSuccess(DATA);
+}
+
+//===============================================================
+/* Get Firmware String Command
+NetFun: 0x2E
+Cmd : 0x10
+Request:
+    Byte 1-3 : Tyan Manufactures ID (FD 19 00)
+Response:
+    Byte 1 : Completion Code
+    Byte 2-4 : Tyan Manufactures ID
+    Byte 5-N : Firmware String
+*/
+ipmi::RspType<std::vector<uint8_t>> ipmi_getFirmwareString()
+{
+    std::vector<uint8_t>firmwareString(3,0);
+    std::string osReleasePath = "/etc/os-release";
+    std::string searchFirmwareString = "BMC_NAME";
+    std::string readText;
+    std::ifstream readFile(osReleasePath);
+
+    while(getline(readFile, readText)) {
+        std::size_t found = readText.find(searchFirmwareString);
+        if (found!=std::string::npos){
+            std::vector<std::string> readTextSplite;
+            boost::split(readTextSplite, readText, boost::is_any_of( "\"" ) );
+            firmwareString.assign(readTextSplite[1].length()+1, 0);
+            std::copy(readTextSplite[1].begin(), readTextSplite[1].end(), firmwareString.begin());
+        }
+    }
+
+    readFile.close();
+
+    return ipmi::responseSuccess(firmwareString);
+}
+
+//===============================================================
+
+ipmi::RspType<std::vector<uint8_t>>
+    ipmi_sendRawPeci(uint8_t clientAddr, uint8_t writeLength, uint8_t readLength,
+                        std::vector<uint8_t> writeData)
+{
+    if (readLength > PECI_BUFFER_SIZE)
+    {
+        log<level::ERR>("sendRawPeci command: Read length exceeds limit");
+        return ipmi::responseParmOutOfRange();
+    }
+    std::vector<uint8_t> rawResp(readLength);
+    if (peci_raw(clientAddr, readLength, writeData.data(), writeData.size(),
+                             rawResp.data(), rawResp.size()) != PECI_CC_SUCCESS)
+    {
+        log<level::ERR>("sendRawPeci command: PECI command failed");
+        return ipmi::responseResponseError();
+    }
+
+    return ipmi::responseSuccess(rawResp);
+
+}
+
+//===============================================================
+/* Set/Get Ramdom Delay AC Restore Power ON Command
+NetFun: 0x30
+Cmd : 0x18
+Request:
+    Byte 1 : Op Code
+        [7] : 0-Get 1-Set
+        [6:0] :
+            00h-Disable Delay
+            01h-Enable Delay, Random Delay Time
+            02h-Enable Delay, Fixed Delay Time
+    Byte 2-3 : Delay Time, LSB first (Second base)
+Response:
+    Byte 1 : Completion Code
+    Byte 2 :  Op Code
+    Byte 3-4 : Delay Time, LSB first (Second base)
+*/
+ipmi::RspType<uint8_t, uint8_t, uint8_t> ipmi_tyan_RamdomDelayACRestorePowerON(uint8_t opCode, uint8_t delayTimeLSB,uint8_t delayTimeMSB)
+{
+    std::uint8_t opCodeResponse, delayTimeLSBResponse, delayTimeMSBResponse;;
+
+    constexpr auto service = "xyz.openbmc_project.Settings";
+    constexpr auto path = "/xyz/openbmc_project/control/host0/power_restore_policy";
+    constexpr auto powerRestoreInterface = "xyz.openbmc_project.Control.Power.RestorePolicy";
+    constexpr auto alwaysOnPolicy = "PowerRestoreAlwaysOnPolicy";
+    constexpr auto delay = "PowerRestoreDelay";
+
+    auto bus = sdbusplus::bus::new_default();
+
+    if(opCode & 0x80)
+    {
+        //Set
+        opCodeResponse = opCode;
+        delayTimeLSBResponse = delayTimeLSB;
+        delayTimeMSBResponse = delayTimeMSB;
+        try
+        {
+            auto method = bus.new_method_call(service, path, PROPERTY_INTERFACE,"Set");
+            method.append(powerRestoreInterface, alwaysOnPolicy, sdbusplus::message::variant<std::string>(RestorePolicy::convertAlwaysOnPolicyToString((RestorePolicy::AlwaysOnPolicy)(opCode & 0x7F))));
+            bus.call_noreply(method);
+
+            uint32_t delayValue = delayTimeLSB | (delayTimeMSB << 8);
+
+            auto methodDelay = bus.new_method_call(service, path, PROPERTY_INTERFACE, "Set");
+            methodDelay.append(powerRestoreInterface, delay, sdbusplus::message::variant<uint32_t>(delayValue));
+            bus.call_noreply(methodDelay);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            log<level::ERR>("Error in RamdomDelayACRestorePowerON Set",entry("ERROR=%s", e.what()));
+            return ipmi::responseParmOutOfRange();
+        }
+    }
+    else
+    {
+        //Get
+        auto method = bus.new_method_call(service, path, PROPERTY_INTERFACE,"Get");
+        method.append(powerRestoreInterface, alwaysOnPolicy);
+
+        sdbusplus::message::variant<std::string> result;
+        try
+        {
+            auto reply = bus.call(method);
+            reply.read(result);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            log<level::ERR>("Error in PowerRestoreAlwaysOnPolicy Get",entry("ERROR=%s", e.what()));
+            return ipmi::responseUnspecifiedError();
+        }
+        auto powerAlwaysOnPolicy = sdbusplus::message::variant_ns::get<std::string>(result);
+
+        auto methodDelay = bus.new_method_call(service, path, PROPERTY_INTERFACE, "Get");
+        methodDelay.append(powerRestoreInterface, delay);
+
+        sdbusplus::message::variant<uint32_t> resultDelay;
+        try
+        {
+            auto reply = bus.call(methodDelay);
+            reply.read(resultDelay);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            log<level::ERR>("Error in PowerRestoreDelay Get",entry("ERROR=%s", e.what()));
+            return ipmi::responseUnspecifiedError();
+        }
+        auto powerRestoreDelay = sdbusplus::message::variant_ns::get<uint32_t>(resultDelay);
+
+        opCodeResponse = (opCode & 0x80) | (uint8_t)RestorePolicy::convertAlwaysOnPolicyFromString(powerAlwaysOnPolicy);
+
+        uint8_t *delayValue = (uint8_t *)&powerRestoreDelay;
+        delayTimeLSBResponse = delayValue[0];
+        delayTimeMSBResponse = delayValue[1];
+    }
+
+    return ipmi::responseSuccess(opCodeResponse,delayTimeLSBResponse,delayTimeMSBResponse);
+}
+
+//===============================================================
+/* Set specified service enable or disable
+NetFun: 0x30
+Cmd : 0x0D
+Request:
+    Byte 1 : Set service status
+        [7-1] : reserved
+        [0] :
+            0h-Disable web service
+            1h-Enable web service
+Response:
+    Byte 1 : Completion Code
+*/
+ipmi::RspType<> ipmi_SetService(uint8_t serviceSetting)
+{
+    constexpr auto service = "xyz.openbmc_project.Settings";
+    constexpr auto path = "/xyz/openbmc_project/oem/ServiceStatus";
+    constexpr auto serviceStatusInterface = "xyz.openbmc_project.OEM.ServiceStatus";
+    constexpr auto webService = "WebService";
+
+    auto bus = sdbusplus::bus::new_default();
+
+    //Set web service status
+    try
+    {
+        auto method = bus.new_method_call(service, path, PROPERTY_INTERFACE,"Set");
+        method.append(serviceStatusInterface, webService, sdbusplus::message::variant<bool>(serviceSetting & 0x01));
+        bus.call_noreply(method);
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        log<level::ERR>("Error in RamdomDelayACRestorePowerON Set",entry("ERROR=%s", e.what()));
+        return ipmi::responseParmOutOfRange();
+    }
+
+    return ipmi::responseSuccess();
+}
+
+//===============================================================
+/* Get specified service enable or disable status
+NetFun: 0x30
+Cmd : 0x0E
+Request:
+
+Response:
+    Byte 1 : Completion Code
+    Byte 2 : Set service status
+        [7-1] : reserved
+        [0] :
+            0h-Web service is disable
+            1h-Web service is enable
+*/
+ipmi::RspType<uint8_t> ipmi_GetService()
+{
+    uint8_t serviceResponse = 0;
+
+    constexpr auto service = "xyz.openbmc_project.Settings";
+    constexpr auto path = "/xyz/openbmc_project/oem/ServiceStatus";
+    constexpr auto serviceStatusInterface = "xyz.openbmc_project.OEM.ServiceStatus";
+    constexpr auto webService = "WebService";
+
+    auto bus = sdbusplus::bus::new_default();
+
+    //Get web service status
+    auto method = bus.new_method_call(service, path, PROPERTY_INTERFACE, "Get");
+    method.append(serviceStatusInterface, webService);
+
+    sdbusplus::message::variant<bool> result;
+    try
+    {
+        auto reply = bus.call(method);
+        reply.read(result);
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        log<level::ERR>("Error in PowerRestoreDelay Get",entry("ERROR=%s", e.what()));
+        return ipmi::responseUnspecifiedError();
+    }
+    auto webServiceStatus = sdbusplus::message::variant_ns::get<bool>(result);
+
+    serviceResponse = (uint8_t)(webServiceStatus);
+
+    return ipmi::responseSuccess(serviceResponse);
+}
+
+//===============================================================
+/* Get the latest 20 BIOS post codes
+NetFun: 0x30
+Cmd : 0x10
+Request:
+
+Response:
+    Byte 1 : Completion Code
+    Byte 2-21 : latest 20 BIOS post codes
+*/
+ipmi::RspType<std::vector<uint8_t>> ipmi_GetPostCode()
+{
+    constexpr auto postCodeInterface = "xyz.openbmc_project.State.Boot.PostCode";
+    constexpr auto postCodeObjPath   = "/xyz/openbmc_project/State/Boot/PostCode";
+    constexpr auto postCodeService   = "xyz.openbmc_project.State.Boot.PostCode";
+
+    uint16_t bootCycleIndex = 0;
+    std::vector<uint64_t> tmpBuffer;
+    int tmpBufferIndex = 0;
+    std::shared_ptr<sdbusplus::asio::connection> dbus = getSdBus();
+    std::vector<uint8_t> dataInfo;
+
+    try
+    {
+        /* Get CurrentBootCycleIndex property */
+        auto value = ipmi::getDbusProperty(*dbus, postCodeService, postCodeObjPath,
+                               postCodeInterface, "CurrentBootCycleIndex");
+        bootCycleIndex = std::get<uint16_t>(value);
+
+        /* Set the argument for method call */
+        auto msg = dbus->new_method_call(postCodeService, postCodeObjPath,
+                                         postCodeInterface, "GetPostCodes");
+        msg.append(bootCycleIndex);
+
+        /* Get the post code of CurrentBootCycleIndex */
+        auto reply = dbus->call(msg);
+        reply.read(tmpBuffer);
+
+        int tmpBufferSize = tmpBuffer.size();
+
+        // Set command return length to return the last 20 post code.
+        if (tmpBufferSize > retPostCodeLen)
+        {
+            tmpBufferIndex = tmpBufferSize - retPostCodeLen;
+        }
+        else
+        {
+            tmpBufferIndex = 0;
+        }
+
+        /* Get post code data */
+        for (int i = 0; ((i < retPostCodeLen) && (tmpBufferIndex < tmpBufferSize)); i++, tmpBufferIndex++)
+        {
+            dataInfo.push_back(tmpBuffer[tmpBufferIndex]);
+        }
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        sd_journal_print(LOG_ERR,"IPMI GetPostCode Failed in call method, %s\n",e.what());
+        return ipmi::responseUnspecifiedError();
+    }
+    return ipmi::responseSuccess(dataInfo);
+}
+
+//===============================================================
+/* re-link Lan port
+NetFun: 0x30
+Cmd : 0x12
+*/
+ipmi::RspType<> ipmi_RelinkLan()
+{
+    char command[100];
+
+    memset(command,0,sizeof(command));
+    sprintf(command,"/usr/sbin/relinkLan.sh &");
+    system(command);
+
+    return ipmi::responseSuccess();
+}
+//=================================================================
+const static constexpr char* solPatternService = "xyz.openbmc_project.SolPatternSensor";
+const static constexpr char* solPatternInterface = "xyz.openbmc_project.Sensor.SOLPattern";
+const static constexpr char* solPatternObjPrefix = "/xyz/openbmc_project/sensors/pattern/Pattern";
+
+/*
+    Set SOL pattern func
+    NetFn: 0x3E / CMD: 0xB2
+*/
+ipmi::RspType<> ipmiSetSolPattern(uint8_t patternNum, std::vector<uint8_t> patternData)
+{
+    /* Pattern Number */
+    if((patternNum < 1) || (patternNum > 4))
+    {
+        sd_journal_print(LOG_CRIT, "[%s] invalid pattern number %d\n",
+                         __FUNCTION__, patternNum);
+        return ipmi::responseParmOutOfRange();;
+    }
+
+    /* Set pattern to dbus */
+    std::string solPatternObjPath = solPatternObjPrefix + std::to_string((patternNum));
+    std::string s(patternData.begin(), patternData.end());
+    std::shared_ptr<sdbusplus::asio::connection> dbus = getSdBus();
+    try
+    {
+        ipmi::setDbusProperty(*dbus, solPatternService, solPatternObjPath,
+                               solPatternInterface, "Pattern", s);
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess();
+}
+
+//=================================================================
+/*
+    Get SOL pattern func
+    NetFn: 0x3E / CMD: 0xB3
+*/
+ipmi::RspType<std::vector<uint8_t>> ipmiGetSolPattern(uint8_t patternNum)
+{
+
+    /* Pattern Number */
+    if((patternNum < 1) || (patternNum > 4))
+    {
+        sd_journal_print(LOG_CRIT, "[%s] invalid pattern number %d\n",
+                         __FUNCTION__, patternNum);
+        return ipmi::responseParmOutOfRange();;
+    }
+
+    /* Get pattern to dbus */
+    std::string solPatternObjPath = solPatternObjPrefix + std::to_string((patternNum));
+    std::string patternData;
+
+    std::shared_ptr<sdbusplus::asio::connection> dbus = getSdBus();
+    try
+    {
+        auto value = ipmi::getDbusProperty(*dbus, solPatternService, solPatternObjPath,
+                               solPatternInterface, "Pattern");
+        patternData = std::get<std::string>(value);
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+    
+    std::vector<uint8_t> v(patternData.begin(), patternData.end());
+    return ipmi::responseSuccess(v);
+}
+
+//=======================================================================
+/* Get OCP card status
+NetFun: 0x30
+Cmd : 0x14
+Request:
+    Byte 1 : Status
+        01h : E810-CQDA1 100G OCP card
+Response:
+
+*/
+ipmi::RspType<> ipmi_GetOcpCard(uint8_t status)
+{
+
+    std::cerr << " set OCP card status to " << (int)status << '\n';
+
+    char command[100];
+    std::fstream file;
+
+    // Get Current OCP Card Status
+    file.open("/usr/sbin/ocpCard",std::ios::in);
+    if(!file)
+    {
+        memset(command,0,sizeof(command));
+        sprintf(command, "touch /usr/sbin/ocpCard");
+        system(command);
+    }
+    file.close();
+
+    memset(command,0,sizeof(command));
+    snprintf(command,sizeof(command),"echo %d > /usr/sbin/ocpCard",(int)status);
+    system(command);
+
+    return ipmi::responseSuccess();
+}
+
+//===============================================================
+/* BMC internal Generate crashdump
+NetFun: 0x30
+Cmd : 0x03
+Request:
+
+Response:
+    Byte 1 : Completion Code
+
+*/
+ipmi::RspType<> ipmi_GenCrashdump()
+{
+    uint8_t serviceResponse = 0;
+
+    constexpr auto service = "com.intel.crashdump";
+    constexpr auto path = "/com/intel/crashdump";
+    constexpr auto interface = "com.intel.crashdump.Stored";
+    constexpr auto genMethod = "IERR";
+
+    auto bus = sdbusplus::bus::new_default();
+
+    auto method = bus.new_method_call(service, path, interface, "GenerateStoredLog");
+    method.append(genMethod);
+
+    try
+    {
+        auto reply = bus.call(method);
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        log<level::ERR>("Error in Generate IERR",entry("ERROR=%s", e.what()));
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess();
+}
+
+void register_netfn_mct_oem()
+{
+    ipmi::registerOemHandler(ipmi::prioMax, 0x0019fd, IPMI_CMD_FanPwmDuty, ipmi::Privilege::Admin, ipmi_tyan_FanPwmDuty);
+    ipmi::registerOemHandler(ipmi::prioMax, 0x0019fd, IPMI_CMD_ManufactureMode, ipmi::Privilege::Admin, ipmi_tyan_ManufactureMode);
+	ipmi::registerOemHandler(ipmi::prioMax, IANA_TYAN, IPMI_CMD_FloorDuty, ipmi::Privilege::Admin, ipmi_tyan_FloorDuty);
+    ipmi::registerOemHandler(ipmi::prioMax, IANA_TYAN, IPMI_CMD_ConfigEccLeakyBucket, ipmi::Privilege::Admin, ipmi_tyan_ConfigEccLeakyBucket);
+    ipmi::registerOemHandler(ipmi::prioMax, IANA_TYAN, IPMI_CMD_GetEccCount, ipmi::Privilege::Admin, ipmiGetEccCount);
+    ipmi::registerOemHandler(ipmi::prioMax, IANA_TYAN, IPMI_CMD_gpioStatus, ipmi::Privilege::Admin, ipmi_tyan_getGpio);
+    // ipmi::registerOemHandler(ipmi::prioMax, IANA_TYAN, IPMI_CMD_SetFruField, ipmi::Privilege::Admin, ipmi_setFruField);
+    ipmi::registerOemHandler(ipmi::prioMax, IANA_TYAN, IPMI_CMD_GetFruField, ipmi::Privilege::Admin, ipmi_getFruField);
+    ipmi::registerOemHandler(ipmi::prioMax, IANA_TYAN, IPMI_CMD_GetFirmwareString, ipmi::Privilege::Admin, ipmi_getFirmwareString);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_ClearCmos, ipmi::Privilege::Admin, ipmi_opma_clear_cmos);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_PnmGetReading, ipmi::Privilege::Admin, ipmi_Pnm_GetReading);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_SendRawPeci, ipmi::Privilege::Admin, ipmi_sendRawPeci);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_RamdomDelayACRestorePowerON, ipmi::Privilege::Admin, ipmi_tyan_RamdomDelayACRestorePowerON);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_SetService, ipmi::Privilege::Admin, ipmi_SetService);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_GetService, ipmi::Privilege::Admin, ipmi_GetService);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_GetPostCode, ipmi::Privilege::Admin, ipmi_GetPostCode);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_RelinkLan, ipmi::Privilege::Admin, ipmi_RelinkLan);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_GET_SOL_PATTERN, ipmi::Privilege::Admin, ipmiGetSolPattern);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_SET_SOL_PATTERN, ipmi::Privilege::Admin, ipmiSetSolPattern);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_GetOcpCard, ipmi::Privilege::Admin, ipmi_GetOcpCard);
+    ipmi::registerHandler(ipmi::prioMax, NETFUN_TWITTER_OEM, IPMI_CMD_GenCrashdump, ipmi::Privilege::Admin, ipmi_GenCrashdump);
+}
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/oemcmd.hpp b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/oemcmd.hpp
new file mode 100755
index 0000000..4fba969
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/files/oemcmd.hpp
@@ -0,0 +1,35 @@
+#include <stdint.h>
+#include <host-ipmid/ipmid-api.h>
+
+static const size_t retPostCodeLen = 20;
+
+enum ipmi_net_fns_oem
+{
+    NETFUN_TWITTER_OEM = 0x30,
+};
+
+#define IANA_TYAN 0x0019fd
+enum ipmi_net_fns_oem_cmds
+{
+    IPMI_CMD_GenCrashdump = 0x03,
+    IPMI_CMD_FanPwmDuty = 0x05,
+    IPMI_CMD_ManufactureMode = 0x06,
+    IPMI_CMD_FloorDuty = 0x07,
+    IPMI_CMD_SetFruField = 0x0B,
+    IPMI_CMD_GetFruField = 0x0C,
+    IPMI_CMD_SetService = 0x0D,
+    IPMI_CMD_GetService = 0x0E,
+    IPMI_CMD_GetFirmwareString = 0x10,
+    IPMI_CMD_ConfigEccLeakyBucket = 0x1A,
+    IPMI_CMD_GetEccCount = 0x1B,
+    IPMI_CMD_ClearCmos = 0x3A,
+    IPMI_CMD_gpioStatus = 0x41,
+    IPMI_CMD_SET_SOL_PATTERN = 0xB2,
+    IPMI_CMD_GET_SOL_PATTERN = 0xB3,
+    IPMI_CMD_PnmGetReading = 0xE2,
+    IPMI_CMD_SendRawPeci = 0xE6, //Intel RAW PECI NetFn=0x30, cmd = 0xE6
+    IPMI_CMD_RamdomDelayACRestorePowerON = 0x18,
+    IPMI_CMD_GetPostCode = 0x10,
+    IPMI_CMD_RelinkLan = 0x12,
+    IPMI_CMD_GetOcpCard = 0x14,
+};
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/mct-ipmi-oem.bb b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/mct-ipmi-oem.bb
new file mode 100755
index 0000000..bdaac23
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-ipmi-oem/mct-ipmi-oem.bb
@@ -0,0 +1,35 @@
+SUMMARY = "MiTAC OEM IPMI commands"
+DESCRIPTION = "MiTAC OEM Commands"
+PR = "r1"
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+S = "${WORKDIR}/"
+
+SRC_URI = "file://CMakeLists.txt\
+           file://LICENSE \
+           file://oemcmd.cpp \
+	       file://oemcmd.hpp "
+
+DEPENDS = "boost phosphor-ipmi-host phosphor-logging systemd intel-dbus-interfaces"
+DEPENDS += "libgpiod libpeci"
+
+inherit cmake obmc-phosphor-ipmiprovider-symlink
+EXTRA_OECMAKE="-DYOCTO=1"
+
+
+LIBRARY_NAMES = "libmctoemcmds.so"
+
+FILES_${PN}_append = " ${libdir}/ipmid-providers/lib*${SOLIBS}"
+FILES_${PN}_append = " ${libdir}/host-ipmid/lib*${SOLIBS}"
+FILES_${PN}_append = " ${libdir}/net-ipmid/lib*${SOLIBS}"
+FILES_${PN}-dev_append = " ${libdir}/ipmid-providers/lib*${SOLIBSDEV}"
+
+#linux-libc-headers guides this way to include custom uapi headers
+CFLAGS_append = " -I ${STAGING_KERNEL_DIR}/include/uapi"
+CFLAGS_append = " -I ${STAGING_KERNEL_DIR}/include"
+CXXFLAGS_append = " -I ${STAGING_KERNEL_DIR}/include/uapi"
+CXXFLAGS_append = " -I ${STAGING_KERNEL_DIR}/include"
+do_configure[depends] += "virtual/kernel:do_shared_workdir"
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-gpio.service b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-gpio.service
new file mode 100755
index 0000000..159b3cc
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-gpio.service
@@ -0,0 +1,9 @@
+[Unit]
+Description=Configure GPIOs for Host Power Control
+
+[Service]
+Restart=no
+RemainAfterExit=true
+Type=oneshot
+ExecStart=/usr/bin/env init_once.sh
+SyslogIdentifier=init_once.sh
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-powercyclelog.service b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-powercyclelog.service
new file mode 100755
index 0000000..17c0f67
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-powercyclelog.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=Log Power Cycle Event
+Requires=host-gpio.service
+After=host-gpio.service
+
+[Service]
+RemainAfterExit=no
+Type=oneshot
+ExecStart=/usr/bin/env powercyclelog.sh
+SyslogIdentifier=Power Cycle
+
+[Install]
+WantedBy=obmc-host-reboot@0.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-poweroff.service b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-poweroff.service
new file mode 100755
index 0000000..6dfa3cf
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-poweroff.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Stop Host
+Requires=host-gpio.service
+After=host-gpio.service
+Conflicts=obmc-chassis-poweron@0.target
+
+[Service]
+RemainAfterExit=no
+Type=oneshot
+ExecStart=/usr/bin/env poweroff.sh
+SyslogIdentifier=poweroff.sh
+
+[Install]
+WantedBy=obmc-chassis-poweroff@0.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-poweron.service b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-poweron.service
new file mode 100755
index 0000000..1ffc24b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-poweron.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Start Host
+Requires=host-gpio.service
+After=host-gpio.service
+Conflicts=obmc-chassis-poweroff@0.target
+
+[Service]
+RemainAfterExit=no
+Type=oneshot
+ExecStart=/usr/bin/env poweron.sh
+SyslogIdentifier=poweron.sh
+
+[Install]
+WantedBy=obmc-chassis-poweron@0.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-powerreset.service b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-powerreset.service
new file mode 100755
index 0000000..b2a5f70
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/host-powerreset.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=Host Reset System service
+Requires=host-gpio.service
+After=host-gpio.service
+
+[Service]
+RemainAfterExit=no
+Type=oneshot
+ExecStart=/usr/bin/env powerreset.sh
+SyslogIdentifier=powerreset.sh
+
+[Install]
+WantedBy=obmc-host-force-warm-reboot@0.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/init_once.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/init_once.sh
new file mode 100755
index 0000000..b77f190
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/init_once.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+# Set all output GPIOs as such and drive them with reasonable values.
+echo "MCT power control init once script";
+
+exit 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/powercyclelog.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/powercyclelog.sh
new file mode 100755
index 0000000..003d611
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/powercyclelog.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+SERVICE="xyz.openbmc_project.Logging.IPMI"
+OBJECT="/xyz/openbmc_project/Logging/IPMI"
+INTERFACE="xyz.openbmc_project.Logging.IPMI"
+METHOD="IpmiSelAdd"
+
+busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/fru_state/IPMI_POWER_CYCLE" 3 {0x02,0x01,0xff} yes 0x20
+
+exit 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/poweroff.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/poweroff.sh
new file mode 100755
index 0000000..b70fbb1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/poweroff.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+
+echo "Enter Power off System action"
+
+pwrstatus=$(busctl get-property org.openbmc.control.Power /org/openbmc/control/power0 org.openbmc.control.Power pgood | cut -d' ' -f2)
+if [ $pwrstatus -eq 1 ]; then   
+    # *** Push power button ***
+    # GPIO E1
+    echo "Execute Power off"
+    /usr/bin/gpioset `gpiofind PWRBTN_OUT`=0
+    for (( i=0; i<=6; i=i+1 ))
+    do
+        sleep 1
+        pwrstatus=$(busctl get-property org.openbmc.control.Power /org/openbmc/control/power0 org.openbmc.control.Power pgood | cut -d' ' -f2)
+        if [ $pwrstatus -eq 0 ]; then
+             break;    
+        fi
+    done    
+    /usr/bin/gpioset `gpiofind PWRBTN_OUT`=1
+    sleep 1
+fi
+
+obmcutil chassisoff
+
+echo "Exit Power off System action"
+exit 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/poweron.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/poweron.sh
new file mode 100755
index 0000000..93cc181
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/poweron.sh
@@ -0,0 +1,29 @@
+#!/bin/bash
+
+echo "Enter Power on System action"
+
+for (( i=0; i<=6; i=i+1 ))
+do
+    duringPowerOff=$(systemctl is-active host-poweroff.service)
+    if [ "inactive" != $duringPowerOff ]; then
+        echo "During power off: $duringPowerOff"
+        sleep 1
+    else
+        break
+    fi
+done
+pwrstatus=$(busctl get-property org.openbmc.control.Power /org/openbmc/control/power0 org.openbmc.control.Power pgood | cut -d' ' -f2)
+if [ $pwrstatus -eq 0 ]; then
+    /usr/bin/gpioget `gpiofind PWRBTN_OUT` > /dev/null 
+    sleep 1	
+    echo "Execute Power on"
+    # *** Push power button ***
+    # GPIO E1 for power on
+    /usr/bin/gpioset `gpiofind PWRBTN_OUT`=0
+    sleep 2
+    /usr/bin/gpioset `gpiofind PWRBTN_OUT`=1 
+
+fi
+
+echo "Exit Power on System action"
+exit 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/powerreset.sh b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/powerreset.sh
new file mode 100755
index 0000000..d0c0087
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/files/powerreset.sh
@@ -0,0 +1,27 @@
+/bin/bash
+
+echo "Enter Power Reset System Action"
+
+SERVICE="xyz.openbmc_project.Logging.IPMI"
+OBJECT="/xyz/openbmc_project/Logging/IPMI"
+INTERFACE="xyz.openbmc_project.Logging.IPMI"
+METHOD="IpmiSelAdd"
+
+echo "action: host reset"
+pwrstatus=$(busctl get-property org.openbmc.control.Power /org/openbmc/control/power0 org.openbmc.control.Power pgood | cut -d' ' -f2)
+if [ $pwrstatus -eq 1 ]; then
+
+    # *** Reset ***
+    /usr/bin/gpioset `gpiofind RSTBTN_OUT`=0
+    sleep 1
+    /usr/bin/gpioset `gpiofind RSTBTN_OUT`=1
+
+    busctl call $SERVICE $OBJECT $INTERFACE $METHOD ssaybq "SEL Entry" "/xyz/openbmc_project/sensors/restart/SYSTEM_RESTART" 3 {0x07,0x01,0x00} yes 0x20
+
+else
+    echo "System is off state."
+
+fi
+
+echo "Exit Power reset System action"
+exit 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/mct-powerctrl.bb b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/mct-powerctrl.bb
new file mode 100755
index 0000000..663ac09
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/mct-powerctrl/mct-powerctrl.bb
@@ -0,0 +1,32 @@
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+FILESEXTRAPATHS_append := "${THISDIR}/files:"
+
+inherit systemd
+inherit obmc-phosphor-systemd
+
+S = "${WORKDIR}/"
+
+SRC_URI = "file://init_once.sh \
+           file://poweroff.sh \
+           file://poweron.sh \
+           file://powerreset.sh \
+           file://host-gpio.service \
+           file://host-poweroff.service \
+           file://host-poweron.service \
+           file://host-powerreset.service \
+           "
+
+DEPENDS = "systemd"
+RDEPENDS_${PN} = "bash"
+
+SYSTEMD_PACKAGES = "${PN}"
+SYSTEMD_SERVICE_${PN} = "host-gpio.service host-poweron.service host-poweroff.service host-powerreset.service"
+
+do_install() {
+    install -d ${D}/usr/sbin
+    install -m 0755 ${S}init_once.sh ${D}/${sbindir}/
+    install -m 0755 ${S}poweroff.sh ${D}/${sbindir}/
+    install -m 0755 ${S}poweron.sh ${D}/${sbindir}/
+    install -m 0755 ${S}powerreset.sh ${D}/${sbindir}/
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/network/phosphor-network/0001-Add-try-and-catch-to-system-configuration.patch b/meta-mct/meta-s5549/recipes-phosphor/network/phosphor-network/0001-Add-try-and-catch-to-system-configuration.patch
new file mode 100755
index 0000000..577c8eb
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/network/phosphor-network/0001-Add-try-and-catch-to-system-configuration.patch
@@ -0,0 +1,58 @@
+From 917bb5f98f4fe16b962ef0a634aae616e223ce24 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 12 May 2020 14:01:06 +0800
+Subject: [PATCH] Add try and catch to system configuration
+
+Fix the issue for dbus method failed to call
+---
+ system_configuration.cpp | 30 +++++++++++++++++++-----------
+ 1 file changed, 19 insertions(+), 11 deletions(-)
+ mode change 100644 => 100755 system_configuration.cpp
+
+diff --git a/system_configuration.cpp b/system_configuration.cpp
+old mode 100644
+new mode 100755
+index 4c5700e..f4d07e2
+--- a/system_configuration.cpp
++++ b/system_configuration.cpp
+@@ -69,21 +69,29 @@ std::string SystemConfiguration::hostName(std::string name)
+ std::string SystemConfiguration::getHostNameFromSystem() const
+ {
+     sdbusplus::message::variant<std::string> name;
+-    auto method = bus.new_method_call(HOSTNAMED_SERVICE, HOSTNAMED_SERVICE_PATH,
+-                                      PROPERTY_INTERFACE, METHOD_GET);
+-
+-    method.append(HOSTNAMED_INTERFACE, "Hostname");
+-
+-    auto reply = bus.call(method);
+-
+-    if (reply)
++    try
+     {
+-        reply.read(name);
++        auto method = bus.new_method_call(HOSTNAMED_SERVICE, HOSTNAMED_SERVICE_PATH,
++                                        PROPERTY_INTERFACE, METHOD_GET);
++
++        method.append(HOSTNAMED_INTERFACE, "Hostname");
++
++        auto reply = bus.call(method);
++
++        if (reply)
++        {
++            reply.read(name);
++        }
++        else
++        {
++            log<level::ERR>("Failed to get hostname");
++            report<InternalFailure>();
++            return "";
++        }
+     }
+-    else
++    catch (const sdbusplus::exception::SdBusError& e)
+     {
+         log<level::ERR>("Failed to get hostname");
+-        report<InternalFailure>();
+         return "";
+     }
+     return sdbusplus::message::variant_ns::get<std::string>(name);
diff --git a/meta-mct/meta-s5549/recipes-phosphor/network/phosphor-network_%.bbappend b/meta-mct/meta-s5549/recipes-phosphor/network/phosphor-network_%.bbappend
new file mode 100755
index 0000000..1b3c945
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/network/phosphor-network_%.bbappend
@@ -0,0 +1,4 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-Add-try-and-catch-to-system-configuration.patch"
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/packagegroups/packagegroup-mct-apps.bbappend b/meta-mct/meta-s5549/recipes-phosphor/packagegroups/packagegroup-mct-apps.bbappend
new file mode 100755
index 0000000..e50ac5f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/packagegroups/packagegroup-mct-apps.bbappend
@@ -0,0 +1,4 @@
+RDEPENDS_${PN}-chassis += " \
+                            obmc-phosphor-buttons-signals \
+                            obmc-phosphor-buttons-handler \
+                            "
diff --git a/meta-mct/meta-s5549/recipes-phosphor/phosphor-u-boot-mgr/phosphor-u-boot-mgr_git.bb b/meta-mct/meta-s5549/recipes-phosphor/phosphor-u-boot-mgr/phosphor-u-boot-mgr_git.bb
new file mode 100755
index 0000000..8b23d2f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/phosphor-u-boot-mgr/phosphor-u-boot-mgr_git.bb
@@ -0,0 +1,18 @@
+SUMMARY = "Phosphor U-Boot environment manager"
+DESCRIPTION = "Daemon to read or write U-Boot environment variables"
+
+PV = "1.0+git${SRCPV}"
+
+S = "${WORKDIR}/git/phosphor-u-boot-env-mgr"
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://LICENSE;md5=e3fc50a88d0a364313df4b21ef20c29e"
+
+SRC_URI = "git://git@github.com/Intel-BMC/provingground.git;protocol=ssh"
+
+SRCREV = "226ca2842e0a14ad56b4ebeedfd82ac2ea7e145e"
+
+inherit cmake systemd
+SYSTEMD_SERVICE_${PN} = "xyz.openbmc_project.U_Boot.Environment.Manager.service"
+
+DEPENDS = "boost sdbusplus phosphor-logging"
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor.bb b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor.bb
new file mode 100755
index 0000000..0eaf36b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor.bb
@@ -0,0 +1,42 @@
+SUMMARY = "MiTAC Regiser Monitor"
+DESCRIPTION = "Implement the regiser monitor"
+PR = "r1"
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+inherit autotools pkgconfig
+inherit obmc-phosphor-ipmiprovider-symlink
+inherit pythonnative
+inherit systemd
+inherit obmc-phosphor-systemd
+inherit obmc-phosphor-dbus-service
+
+
+S = "${WORKDIR}"
+
+SRC_URI = "file://bootstrap.sh \
+           file://configure.ac \
+           file://LICENSE \
+           file://Makefile.am \
+           file://utils.hpp \
+           file://lpc-interrupt-monitor.cpp \
+           file://lpc-interrupt-monitor.hpp \
+           file://lpc-interrupt-monitor.service \
+          "
+
+DEPENDS += "autoconf-archive-native"
+DEPENDS += "sdbusplus sdbusplus-native"
+DEPENDS += "phosphor-logging"
+DEPENDS += "phosphor-dbus-interfaces phosphor-dbus-interfaces-native"
+DEPENDS += "sdbus++-native"
+DEPENDS += "boost"
+DEPENDS += "phosphor-dbus-interfaces"
+
+
+RDEPENDS_${PN} += " \
+        sdbusplus \
+        phosphor-logging \
+        phosphor-dbus-interfaces \
+        "
+
+SYSTEMD_SERVICE_${PN} = "lpc-interrupt-monitor.service"
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/LICENSE b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/LICENSE
new file mode 100755
index 0000000..120e95d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2018 Intel Corporation
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/Makefile.am b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/Makefile.am
new file mode 100755
index 0000000..de66278
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/Makefile.am
@@ -0,0 +1,15 @@
+sbin_PROGRAMS = lpc-interrupt-monitor
+
+lpc_interrupt_monitor_SOURCES = lpc-interrupt-monitor.cpp
+lpc_interrupt_monitor_LDFLAGS = $(SYSTEMD_LIBS) \
+                         $(SDBUSPLUS_LIBS) \
+                         -pthread \
+                         $(PTHREAD_LIBS) \
+                         $(PHOSPHOR_DBUS_INTERFACES_LIBS) \
+                         $(BOOST_CPPFLAGS)
+lpc_interrupt_monitor_CFLAGS = $(SYSTEMD_CFLAGS) \
+                        $(SDBUSPLUS_CFLAGS) \
+                        -pthread \
+                        $(PTHREAD_CFLAGS) \
+                        $(PHOSPHOR_DBUS_INTERFACES_CFLAGS) \
+                        $(BOOST_CPPFLAGS)
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/bootstrap.sh b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/bootstrap.sh
new file mode 100755
index 0000000..bb06e73
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/bootstrap.sh
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+AUTOCONF_FILES="Makefile.in aclocal.m4 ar-lib autom4te.cache compile \
+        config.guess config.h.in config.sub configure depcomp install-sh \
+        ltmain.sh missing *libtool test-driver"
+
+case $1 in
+    clean)
+        test -f Makefile && make maintainer-clean
+        test -f linux/bt-bmc.h && rm -rf linux/bt-bmc.h
+        test -d linux && find linux -type d -empty | xargs -r rm -rf
+        for file in ${AUTOCONF_FILES}; do
+            find -name "$file" | xargs -r rm -rf
+        done
+        exit 0
+        ;;
+esac
+
+autoreconf -i
+echo 'Run "./configure ${CONFIGURE_FLAGS} && make"'
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/configure.ac b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/configure.ac
new file mode 100755
index 0000000..e0ffbda
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/configure.ac
@@ -0,0 +1,37 @@
+# Initialization
+AC_PREREQ([2.69])
+AC_INIT([mct-register-monitor], [1.0])
+AC_LANG([C++])
+AC_CONFIG_HEADERS([config.h])
+AM_INIT_AUTOMAKE([subdir-objects -Wall -Werror foreign dist-xz])
+AM_SILENT_RULES([yes])
+
+# Checks for programs.
+AC_PROG_CC
+AM_PROG_AR
+AC_PROG_INSTALL
+AC_PROG_MAKE_SET
+
+# Checks for libraries.
+PKG_CHECK_MODULES([SYSTEMD], [libsystemd >= 221])
+PKG_CHECK_MODULES([SDBUSPLUS], [sdbusplus],,\
+                  AC_MSG_ERROR(["Requires sdbusplus package."]))
+PKG_CHECK_MODULES([PHOSPHOR_DBUS_INTERFACES], [phosphor-dbus-interfaces])
+PKG_CHECK_MODULES([PHOSPHOR_LOGGING], [phosphor-logging])
+AX_CXX_COMPILE_STDCXX_17([noext])
+
+# Checks for header files.
+AC_CHECK_HEADER(systemd/sd-bus.h, ,[AC_MSG_ERROR([Could not find systemd/sd-bus.h...systemd developement package required])])
+
+# Checks for typedefs, structures, and compiler characteristics.
+AX_APPEND_COMPILE_FLAGS([-Wall -Werror], [CFLAGS])
+
+# Checks for library functions.
+LT_INIT # Removes 'unrecognized options: --with-libtool-sysroot'
+
+# Create configured output
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
+
+
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.cpp b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.cpp
new file mode 100755
index 0000000..144466a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.cpp
@@ -0,0 +1,197 @@
+/* Copyright 2020 MCT
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#include "lpc-interrupt-monitor.hpp"
+
+#include <iostream>
+#include "utils.hpp"
+
+static constexpr bool DEBUG = false;
+
+void propertyInitialize()
+{
+    registerMatch = 
+    {
+        lpc_rst,
+        interrupt
+    };
+}
+
+std::vector<std::string> findRegisterPath()
+{
+    std::vector<std::string> storedPath;
+    std::string parentPath;
+
+    std::vector<fs::path> registerPaths;
+    if (!findFiles(fs::path("/sys/bus/platform/drivers/aspeed-bmc-misc"), registerMatch[0], registerPaths, 1))
+    {
+        if constexpr (DEBUG)
+        {
+            std::cerr << "Could not monitor register in system\n";
+        }
+        return storedPath;
+    }
+
+    for (const auto& registerPath : registerPaths)
+    {
+        std::ifstream registerFile(registerPath);
+        if (!registerFile.good())
+        {
+            if constexpr (DEBUG)
+            {
+                std::cerr << "Failure finding register path " << registerPath << "\n";
+            }
+            continue;
+        }
+        parentPath = registerPath.parent_path().string();
+        break;
+    }
+
+    for (const auto& registerName : registerMatch)
+    {
+        storedPath.push_back(parentPath+"/"+registerName);
+    }
+    
+    return storedPath;
+}
+
+void interruptHandler(std::string lpcPath,std::string interruptPath)
+{
+    struct inotify_event *event = NULL;
+    struct pollfd fds[2];
+    char buf[BUF_LEN];
+    nfds_t nfds;
+    int fd, ret, status;
+
+    fd = inotify_init1(IN_NONBLOCK);
+    if (fd == -1)
+    {
+        if constexpr (DEBUG)
+        {
+            std::cerr << "Could not access the inotify API\n";
+        }
+        return;
+    }
+
+    ret = inotify_add_watch(fd, interruptPath.c_str(), IN_MODIFY);
+    if (ret == -1)
+    {
+        if constexpr (DEBUG)
+        {
+            std::cerr << "Cannot watch " << interruptPath <<" \n";
+        }
+        close(fd);
+        return;
+    }
+
+    nfds = 2;
+    fds[0].fd = STDIN_FILENO;
+    fds[0].events = 0;
+    fds[1].fd = fd;
+    fds[1].events = POLLIN;
+
+    while (1)
+    {
+        ret = poll(fds, nfds, -1);
+        if (ret > 0)
+        {
+            if (fds[1].revents & POLLIN)
+            {
+                int len = read(fd, buf, BUF_LEN);
+                char* p = buf;
+                while (p < buf + len) {
+                    event = (struct inotify_event*)p;
+                    uint32_t mask = event->mask;
+                    if (mask & IN_MODIFY) {
+                        if constexpr (DEBUG)
+                        {
+                            std::cerr<<"LPC interrupt occurred\n";
+                        }
+                        status = readFileValue(lpcPath);
+                        if(status)
+                        {
+                            interruptAction(lpcPath,status);
+                        }
+                    }
+                    p += sizeof(struct inotify_event) + event->len;
+                }
+            }
+        }
+    }
+    close(fd);
+}
+
+void registerHandler(boost::asio::io_context& io,double delay)
+{
+    static boost::asio::steady_timer timer(io);
+
+    timer.expires_after(std::chrono::microseconds((long)delay));
+
+    timer.async_wait([&io](const boost::system::error_code&) 
+    {
+        if(findPath.empty())
+        {
+            findPath = findRegisterPath();
+            if(registerMatch.size()!=findPath.size())
+            {
+                findPath.clear();
+                registerHandler(io, 1*MICRO_OFFSET);
+                return; 
+            }
+        }
+
+        std::vector<std::string>::iterator element;
+
+        element = find(registerMatch.begin(), registerMatch.end(), lpc_rst);
+        int lpcPosition = distance(registerMatch.begin(),element);
+
+        element = find(registerMatch.begin(), registerMatch.end(), interrupt);
+        int interruptPosition = distance(registerMatch.begin(),element);
+
+        interruptHandler(findPath.at(lpcPosition),findPath.at(interruptPosition));
+
+        registerHandler(io,0);
+        return;
+    });
+}
+
+void interruptAction(std::string lpcPath, int status)
+{   
+    constexpr auto objectPath = "/";
+    constexpr auto interface = "org.freedesktop.DBus";
+    constexpr auto signal = "LpcReset";
+    uint8_t responseStatus = status & 0x01;
+
+    auto bus = sdbusplus::bus::new_default();
+    auto msg = bus.new_signal(objectPath, interface, signal);
+    uint32_t parameter = responseStatus;
+    msg.append(parameter);
+    msg.signal_send();
+    writeFileValue(lpcPath,0);
+}
+
+int main(int argc, char *argv[])
+{
+    boost::asio::io_context io;
+    bus = std::make_shared<sdbusplus::asio::connection>(io);
+
+    propertyInitialize();
+
+    io.post(
+        [&]() { registerHandler(io, 0); });
+    
+    io.run();
+    return 0;
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.hpp b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.hpp
new file mode 100755
index 0000000..0c5953f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.hpp
@@ -0,0 +1,74 @@
+#pragma once
+
+#include <iostream>
+#include <vector>
+#include <variant>
+#include <filesystem>
+#include <fstream>
+#include <chrono>
+#include <climits>
+#include <unistd.h>
+#include <sys/inotify.h>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_map.hpp>
+#include <boost/container/flat_set.hpp>
+#include <boost/asio/io_context.hpp>
+#include <boost/asio/steady_timer.hpp>
+#include <sdbusplus/bus.hpp>
+#include <sdbusplus/server.hpp>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <phosphor-logging/elog-errors.hpp>
+#include <phosphor-logging/log.hpp>
+
+#define BUF_LEN (10 * (sizeof(struct inotify_event) + NAME_MAX + 1))
+
+namespace fs = std::filesystem;
+using namespace phosphor::logging;
+
+static constexpr auto MILLI_OFFSET = 1000;
+static constexpr auto MICRO_OFFSET = 1000000;
+
+static constexpr auto lpc_rst = "lpc-rst";
+static constexpr auto interrupt = "interrupt";
+
+static std::vector<std::string> registerMatch;
+static std::vector<std::string> findPath;
+
+
+/** @brief Initialize the property for match LPC interrupt register
+ *
+ */
+void propertyInitialize();
+
+
+/** @brief Find the monitor register path for LPC interrupt.
+ *
+ *  @return On success returns path with stored LPC interrupt.
+ */
+std::vector<std::string> findRegisterPath();
+
+/**
+ * @brief Handler the interrupt for input path
+ *
+ * @param[in] lpcPath - Path for LPC reset register.
+ * @param[in] interruptPath - Path for LPC interrupt.
+ */
+void interruptHandler(std::string lpcPath,std::string interruptPath);
+
+/**
+ * @brief Get current timestamp in milliseconds.
+ * 
+ * @param[in] io - io context.
+ * @param[in] delay - Delay time in micro second.
+ */
+void registerHandler(boost::asio::io_context& io,double delay);
+
+/**
+ * @brief Action for interrupt occurred.
+ *
+ * @param[in] lpcPath - Path for LPC reset register.
+ * @param[in] status - Status for handler getting.
+ */
+void interruptAction(std::string lpcPath, int status);
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.service b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.service
new file mode 100755
index 0000000..487d756
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/lpc-interrupt-monitor.service
@@ -0,0 +1,16 @@
+[Unit]
+Description=MiTAC LPC Interrupt Monitor
+Wants=xyz.openbmc_project.State.BMC.service
+After=xyz.openbmc_project.State.BMC.service
+Requires=phosphor-ipmi-host.service
+After=phosphor-ipmi-host.service
+
+
+[Service]
+Restart=always
+ExecStart=/usr/bin/env lpc-interrupt-monitor
+SyslogIdentifier=lpc-interrupt-monitor
+TimeoutSec=infinity
+
+[Install]
+WantedBy={SYSTEMD_DEFAULT_TARGET}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/utils.hpp b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/utils.hpp
new file mode 100755
index 0000000..4d7d4e4
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/register/mct-register-monitor/utils.hpp
@@ -0,0 +1,194 @@
+#pragma once
+
+#include <iostream>
+#include <vector>
+#include <fstream>
+#include <filesystem>
+#include <regex>
+#include <time.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sdbusplus/bus.hpp>
+#include <phosphor-logging/elog-errors.hpp>
+#include <phosphor-logging/log.hpp>
+
+namespace fs = std::filesystem;
+using namespace phosphor::logging;
+using sdbusplus::exception::SdBusError;
+
+std::shared_ptr<sdbusplus::asio::connection> bus;
+
+constexpr auto ROOT_PATH = "/";
+constexpr auto ROOT_INTERFACE = "org.freedesktop.DBus";
+
+constexpr auto STATUS_PATH = "/xyz/openbmc_project/oem/SensorStatus";
+constexpr auto STATUS_INTERFACE = "xyz.openbmc_project.OEM.SensorStatus";
+constexpr auto PROP_INTERFACE = "org.freedesktop.DBus.Properties";
+constexpr auto METHOD_SET = "Set";
+
+/**
+ * @brief Find path accroding to match string.
+ *
+ * @param[in] dirPath - Directory path.
+ * @param[in] matchString - String for match.
+ * @param[in] foundPaths - Found match path.
+ * @param[in] symlinkDepth - Symlink for directory depth.
+ * @return On success returns true.
+ */
+bool findFiles(const fs::path dirPath, const std::string& matchString,
+               std::vector<fs::path>& foundPaths, unsigned int symlinkDepth)
+{
+    if (!fs::exists(dirPath))
+        return false;
+
+    std::regex search(matchString);
+    std::smatch match;
+    for (auto& p : fs::recursive_directory_iterator(dirPath))
+    {
+        std::string path = p.path().string();
+        if (!is_directory(p))
+        {
+            if (std::regex_search(path, match, search))
+                foundPaths.emplace_back(p.path());
+        }
+        else if (is_symlink(p) && symlinkDepth)
+        {
+            findFiles(p.path(), matchString, foundPaths, symlinkDepth - 1);
+        }
+    }
+    return true;
+}
+
+/** @brief Read the value from specific path.
+ *
+ *  @param[in] path - Specific path for reading.
+ */
+int readFileValue(std::string path)
+{
+    std::fstream registerFile(path, std::ios_base::in);
+    int value;
+    registerFile >> value;
+    return value;
+}
+
+/** @brief Write the value for specific path.
+ *
+ *  @param[in] path - Specific path for writing.
+ *  @param[in] value - Value for writing.
+ */
+void writeFileValue(std::string path, int value)
+{
+    std::fstream registerFile(path, std::ios_base::out);
+
+    registerFile << value;
+}
+
+/**
+ * @brief Get current timestamp in milliseconds.
+ * 
+ * @param[in] Null.
+ * @return current timestamp in milliseconds.
+ */
+double getCurrentTimeWithMs()
+{
+    time_t s;
+    long ms;
+    struct timespec spec;
+
+    clock_gettime(CLOCK_REALTIME, &spec);
+
+
+
+    s  = spec.tv_sec;
+    ms = round(spec.tv_nsec / 1.0e6); // Convert nanoseconds to milliseconds
+    if (ms > 999) {
+        s++;
+        ms = 0;
+    }
+
+    double  result = (intmax_t)s + ((double)ms/1000);
+
+    return result;
+}
+
+/**
+ * @brief Get the DBUS Service name for the input dbus path.
+
+ * @param[in] bus - DBUS Bus Object.
+ * @param[in] intf - DBUS Interface.
+ * @param[in] path - DBUS Object Path.
+ */
+std::string getService(std::shared_ptr<sdbusplus::asio::connection>& bus, const std::string& intf,
+                       const std::string& path)
+{
+    auto mapperCall =
+        bus->new_method_call("xyz.openbmc_project.ObjectMapper",
+                            "/xyz/openbmc_project/object_mapper",
+                            "xyz.openbmc_project.ObjectMapper", "GetObject");
+
+    mapperCall.append(path);
+    mapperCall.append(std::vector<std::string>({intf}));
+
+    auto mapperResponseMsg = bus->call(mapperCall);
+
+    if (mapperResponseMsg.is_method_error())
+    {
+        throw std::runtime_error("ERROR in mapper call");
+    }
+
+    std::map<std::string, std::vector<std::string>> mapperResponse;
+    mapperResponseMsg.read(mapperResponse);
+
+    if (mapperResponse.begin() == mapperResponse.end())
+    {
+        throw std::runtime_error("ERROR in reading the mapper response");
+    }
+
+    return mapperResponse.begin()->first;
+}
+
+/**
+ * @brief Send signal to DBUS.
+ *
+ * @param[in] bus - DBUS Bus Object.
+ * @param[in] signal - Send signal.
+ * @param[in] parameter - Parameter for send signal.
+ */
+template <typename T>
+void sendDbusSignal(std::shared_ptr<sdbusplus::asio::connection>& bus, std::string signal, T parameter)
+{
+    try
+    {
+        auto msg = bus->new_signal(ROOT_PATH, ROOT_INTERFACE, signal.c_str());
+        msg.append(parameter);
+        msg.signal_send();
+    }
+    catch (SdBusError& e)
+    {
+        log<level::ERR>("Failed to send signal to DBUS", entry("ERROR=%s", e.what()));
+    }
+}
+
+/**
+ * @brief Set sensor status.
+ *
+ * @param[in] bus - DBUS Bus Object.
+ * @param[in] signal - Send propertie.
+ * @param[in] control - DIMM sensor status.
+ */
+void setSensorStatus(std::shared_ptr<sdbusplus::asio::connection>& bus, std::string propertie, uint32_t control)
+{
+    try
+    {
+        auto service = getService(bus, STATUS_INTERFACE, STATUS_PATH);
+        auto method =  bus->new_method_call(
+            service.c_str(), STATUS_PATH, PROP_INTERFACE, METHOD_SET);
+        method.append(STATUS_INTERFACE, propertie.c_str(), sdbusplus::message::variant<uint32_t>(control));
+        bus->call(method);
+    }
+    catch (SdBusError& e)
+    {
+        log<level::ERR>("Failed to change sensor status", entry("ERROR=%s", e.what()));
+    }
+}
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0001-Add-CATERR-sel-log-monitor.patch b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0001-Add-CATERR-sel-log-monitor.patch
new file mode 100755
index 0000000..f7e5eec
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0001-Add-CATERR-sel-log-monitor.patch
@@ -0,0 +1,264 @@
+From eefdf535172f1aeb179c83e0a3f105cecfbddaff Mon Sep 17 00:00:00 2001
+From: jeannie <jeannie@localhost.localdomain>
+Date: Fri, 3 May 2019 11:20:19 +0800
+Subject: [PATCH] Add CATERR sel log monitor
+
+---
+ CMakeLists.txt                      |   8 +++
+ include/caterr_event_monitor.hpp    | 136 ++++++++++++++++++++++++++++++++++++
+ include/sel_logger.hpp              |   8 ++-
+ include/threshold_event_monitor.hpp |   4 +-
+ src/sel_logger.cpp                  |  14 ++--
+ 5 files changed, 163 insertions(+), 7 deletions(-)
+ create mode 100755 include/caterr_event_monitor.hpp
+ mode change 100644 => 100755 include/sel_logger.hpp
+ mode change 100644 => 100755 include/threshold_event_monitor.hpp
+ mode change 100644 => 100755 src/sel_logger.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index e843eca..f4b98fa 100644
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -19,10 +19,18 @@ option (
+     OFF
+ )
+ 
++option (
++    SEL_LOGGER_MONITOR_CATERR_EVENTS
++    "Enable logger to monitor and automatically
++     log SEL records for caterr sensor events"
++    ON
++)
++
+ target_compile_definitions (
+     sel-logger PRIVATE
+     $<$<BOOL:${SEL_LOGGER_MONITOR_THRESHOLD_EVENTS}>: -DSEL_LOGGER_MONITOR_THRESHOLD_EVENTS>
+     $<$<BOOL:${REDFISH_LOG_MONITOR_PULSE_EVENTS}>: -DREDFISH_LOG_MONITOR_PULSE_EVENTS>
++    $<$<BOOL:${SEL_LOGGER_MONITOR_CATERR_EVENTS}>: -DSEL_LOGGER_MONITOR_CATERR_EVENTS>
+ )
+ 
+ target_include_directories (sel-logger PRIVATE ${CMAKE_SOURCE_DIR})
+diff --git a/include/caterr_event_monitor.hpp b/include/caterr_event_monitor.hpp
+new file mode 100755
+index 0000000..edf9752
+--- /dev/null
++++ b/include/caterr_event_monitor.hpp
+@@ -0,0 +1,136 @@
++/*
++// Copyright (c) 2019 Intel Corporation
++//
++// Licensed under the Apache License, Version 2.0 (the "License");
++// you may not use this file except in compliance with the License.
++// You may obtain a copy of the License at
++//
++//      http://www.apache.org/licenses/LICENSE-2.0
++//
++// Unless required by applicable law or agreed to in writing, software
++// distributed under the License is distributed on an "AS IS" BASIS,
++// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++// See the License for the specific language governing permissions and
++// limitations under the License.
++*/
++
++#pragma once
++#include <sdbusplus/asio/object_server.hpp>
++#include <sel_logger.hpp>
++#include <sensorutils.hpp>
++
++inline static sdbusplus::bus::match::match
++    startCaterrEventMonitor(std::shared_ptr<sdbusplus::asio::connection> conn)
++{
++    auto caterrEventMatcherCallback = [conn](sdbusplus::message::message &msg) {
++        std::string thresholdInterface;
++        boost::container::flat_map<std::string,
++                                   sdbusplus::message::variant<std::string>>
++            propertiesChanged;
++        msg.read(thresholdInterface, propertiesChanged);
++        std::string_view sensorName(msg.get_path());
++		//Processor
++		uint8_t sensorType=0x7;
++		uint8_t eventType=0x6f;
++		
++        if (propertiesChanged.empty())
++        {
++            return;
++        }
++		
++		
++        std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
++        bool assert=0;
++        //set eventdata1 to 0xb  , for now unspecified byte2 & btye3 , not implement A0 in bit[7:4]
++        eventData[0] |= eventData[0] =
++                static_cast<uint8_t>(0xb);  		
++
++        std::string event = propertiesChanged.begin()->first;
++	 
++        auto variant = sdbusplus::message::variant_ns::get_if<std::string>(
++	      &propertiesChanged.begin()->second);
++        
++            
++
++        if (event.empty() || nullptr == variant)
++        {
++            return;
++        }
++
++		
++		
++		// Get the sensor reading to put in the event data
++        sdbusplus::message::message getSensorValue =
++            conn->new_method_call(msg.get_sender(), msg.get_path(),
++                                  "org.freedesktop.DBus.Properties", "Get");
++            getSensorValue.append("xyz.openbmc_project.Control.Processor","SensorNumber");
++        
++       			
++        sdbusplus::message::variant<uint16_t> sensorValue;	
++			
++        try
++        {
++            sdbusplus::message::message getSensorValueResp =
++                conn->call(getSensorValue);
++            getSensorValueResp.read(sensorValue);
++        }
++        catch (sdbusplus::exception_t &)
++        {
++            std::cerr << "error getting sensor value from " << msg.get_path()
++                      << "\n";
++            return;
++        }
++		
++		uint16_t sensorNumber = 0;
++		sensorNumber=std::get<uint16_t>(sensorValue);
++  		
++        if (event == "ProcessorStatus")
++        {
++            if (*variant == "xyz.openbmc_project.Control.Processor.State.CATERR")
++            {
++                std::string message("CATERR occur");
++                assert=1;
++                std::string redfishMsgId("CATERR!");
++                sd_journal_send("MESSAGE=%s", message.c_str(),
++                                "REDFISH_MESSAGE_ID=%s", redfishMsgId.c_str(), NULL);
++                                
++								
++		 //fp=fopen("/var/tmp/sellog","a");
++                //fprintf(fp,"variant == :xyz.openbmc_project.Control.Processor.State.CATERR\n");
++                //fprintf(fp,"path=%s\n",msg.get_path());
++                //fclose(fp);				
++            }
++			
++            //deassert event  no need (resesrve, add for test)
++#if 0
++            else if (*variant == "xyz.openbmc_project.Control.Processor.State.NORMAL")
++            {         
++            
++                std::string message("no CATERR occure");
++                assert=0;
++
++                			
++                //fp=fopen("/var/tmp/sellog","a");
++                //fprintf(fp,"variant == :xyz.openbmc_project.Control.Processor.State.NORMAL\n");
++                //fclose(fp);		
++            }
++#endif
++            std::string journalMsg("Add Caterr event");
++            selAddSystemRecord(journalMsg, std::string(msg.get_path()), eventData,
++                               assert, selEventOnlyType, selBIOSGenID,
++                               "IPMI_SEL_SENSOR_TYPE=%x", sensorType,
++                               "IPMI_SEL_EVENT_TYPE=%x", eventType,
++			        "IPMI_SEL_SENSOR_NUMBER=%x",sensorNumber);
++			
++			
++        }
++    };
++
++    sdbusplus::bus::match::match caterrEventMatcher(
++        static_cast<sdbusplus::bus::bus &>(*conn),
++        "type='signal',interface='org.freedesktop.DBus.Properties',member='"
++        "PropertiesChanged',arg0namespace='xyz.openbmc_project.Control.Processor'",
++        std::move(caterrEventMatcherCallback));
++
++    return caterrEventMatcher;
++}
+diff --git a/include/sel_logger.hpp b/include/sel_logger.hpp
+old mode 100644
+new mode 100755
+index 28214e3..426346c
+--- a/include/sel_logger.hpp
++++ b/include/sel_logger.hpp
+@@ -25,7 +25,13 @@ static constexpr char const *ipmiSelAddInterface =
+ // SEL entries.  Helps with filtering SEL entries in the journal.
+ static constexpr char const *selMessageId = "b370836ccf2f4850ac5bee185b77893a";
+ static constexpr int selPriority = 5; // notice
++
++//Record Type
+ static constexpr uint8_t selSystemType = 0x02;
++static constexpr uint8_t selEventOnlyType = 0x03;
++
++
++static constexpr uint16_t selBIOSGenID = 0x0001;
+ static constexpr uint16_t selBMCGenID = 0x0020;
+ static constexpr uint16_t selInvalidRecID =
+     std::numeric_limits<uint16_t>::max();
+@@ -35,5 +41,5 @@ static constexpr size_t selOemDataMaxSize = 13;
+ template <typename... T>
+ static uint16_t
+     selAddSystemRecord(const std::string &message, const std::string &path,
+-                       const std::vector<uint8_t> &selData, const bool &assert,
++                       const std::vector<uint8_t> &selData, const bool &assert, const uint8_t &selType, 
+                        const uint16_t &genId, T &&... metadata);
+diff --git a/src/sel_logger.cpp b/src/sel_logger.cpp
+old mode 100644
+new mode 100755
+index 6068e20..68d7d2b
+--- a/src/sel_logger.cpp
++++ b/src/sel_logger.cpp
+@@ -25,6 +25,7 @@
+ #include <sel_logger.hpp>
+ #include <sstream>
+ #include <threshold_event_monitor.hpp>
++#include <caterr_event_monitor.hpp>
+ 
+ struct DBusInternalError final : public sdbusplus::exception_t
+ {
+@@ -108,7 +109,7 @@ static void toHexStr(const std::vector<uint8_t> &data, std::string &hexStr)
+ template <typename... T>
+ static uint16_t
+     selAddSystemRecord(const std::string &message, const std::string &path,
+-                       const std::vector<uint8_t> &selData, const bool &assert,
++                       const std::vector<uint8_t> &selData, const bool &assert,  const uint8_t &selType,
+                        const uint16_t &genId, T &&... metadata)
+ {
+     // Only 3 bytes of SEL event data are allowed in a system record
+@@ -122,7 +123,7 @@ static uint16_t
+     unsigned int recordId = getNewRecordId();
+     sd_journal_send("MESSAGE=%s", message.c_str(), "PRIORITY=%i", selPriority,
+                     "MESSAGE_ID=%s", selMessageId, "IPMI_SEL_RECORD_ID=%d",
+-                    recordId, "IPMI_SEL_RECORD_TYPE=%x", selSystemType,
++                    recordId, "IPMI_SEL_RECORD_TYPE=%x", selType,
+                     "IPMI_SEL_GENERATOR_ID=%x", genId,
+                     "IPMI_SEL_SENSOR_PATH=%s", path.c_str(),
+                     "IPMI_SEL_EVENT_DIR=%x", assert, "IPMI_SEL_DATA=%s",
+@@ -168,8 +169,8 @@ int main(int argc, char *argv[])
+     ifaceAddSel->register_method(
+         "IpmiSelAdd", [](const std::string &message, const std::string &path,
+                          const std::vector<uint8_t> &selData,
+-                         const bool &assert, const uint16_t &genId) {
+-            return selAddSystemRecord(message, path, selData, assert, genId);
++                         const bool &assert, const uint8_t &selType, const uint16_t &genId) {
++            return selAddSystemRecord(message, path, selData, assert,selType, genId);
+         });
+     // Add a new OEM SEL entry
+     ifaceAddSel->register_method(
+@@ -190,6 +191,11 @@ int main(int argc, char *argv[])
+         startPulseEventMonitor(conn);
+ #endif
+ 
++#ifdef SEL_LOGGER_MONITOR_CATERR_EVENTS
++    sdbusplus::bus::match::match caterrEventMatcher =
++        startCaterrEventMonitor(conn);
++#endif
++
+     io.run();
+ 
+     return 0;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0001-Change-ipmi_sel-location-to-persistent-folder.patch b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0001-Change-ipmi_sel-location-to-persistent-folder.patch
new file mode 100755
index 0000000..15c3683
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0001-Change-ipmi_sel-location-to-persistent-folder.patch
@@ -0,0 +1,22 @@
+From 27a740fd346df41eaced23f3497ad4dfd3a7866a Mon Sep 17 00:00:00 2001
+From: Mirage Su <mirage.su@mic.com.tw>
+Date: Wed, 13 Nov 2019 17:07:15 +0800
+Subject: [PATCH] Change ipmi_sel location to persistent folder
+
+---
+ include/sel_logger.hpp | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/include/sel_logger.hpp b/include/sel_logger.hpp
+index bd40dff..bef6f8f 100644
+--- a/include/sel_logger.hpp
++++ b/include/sel_logger.hpp
+@@ -33,7 +33,7 @@ static constexpr uint16_t selInvalidRecID =
+ static constexpr size_t selEvtDataMaxSize = 3;
+ static constexpr size_t selOemDataMaxSize = 13;
+ 
+-static const std::filesystem::path selLogDir = "/var/log";
++static const std::filesystem::path selLogDir = "/var/lib/ipmi";
+ static const std::string selLogFilename = "ipmi_sel";
+ 
+ template <typename... T>
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0002-Alert-led-when-happen-warning.patch b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0002-Alert-led-when-happen-warning.patch
new file mode 100755
index 0000000..562d433
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0002-Alert-led-when-happen-warning.patch
@@ -0,0 +1,65 @@
+From 74dceab15d998984e2b2b82a6df78cf6e71361b1 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Tue, 7 Jan 2020 14:36:58 +0800
+Subject: [PATCH] Alert-led-when-happen-warning
+
+---
+ include/threshold_event_monitor.hpp | 35 +++++++++++++++++++++++++++++++++++
+ 1 file changed, 35 insertions(+)
+ mode change 100644 => 100755 include/threshold_event_monitor.hpp
+
+diff --git a/include/threshold_event_monitor.hpp b/include/threshold_event_monitor.hpp
+old mode 100644
+new mode 100755
+index b1f2eed..49331e3
+--- a/include/threshold_event_monitor.hpp
++++ b/include/threshold_event_monitor.hpp
+@@ -19,6 +19,23 @@
+ #include <sensorutils.hpp>
+ #include <string_view>
+ #include <variant>
++#include <xyz/openbmc_project/Led/Physical/server.hpp>
++
++#define LED_OBJECTPATH_BASE "/xyz/openbmc_project/led/physical/hw_fault"
++#define LED_INTERFACE "xyz.openbmc_project.Led.Physical"
++#define LED_SERVICE "xyz.openbmc_project.LED.Controller.hw_fault"
++constexpr auto PROPERTY_INTERFACE = "org.freedesktop.DBus.Properties";
++
++static int assertCount;
++
++static void setProperty(sdbusplus::bus::bus& bus, const std::string& path,
++    const std::string& property, const std::string& value,const std::string& service)
++{
++    auto method = bus.new_method_call(service.c_str(), path.c_str(), PROPERTY_INTERFACE, "Set");
++    method.append(LED_INTERFACE, property, sdbusplus::message::variant<std::string>(value));
++    bus.call_noreply(method);
++    return;
++}
+ 
+ enum class thresholdEventOffsets : uint8_t
+ {
+@@ -279,6 +296,24 @@ inline static sdbusplus::bus::match::match startThresholdEventMonitor(
+                                " Threshold=" + std::to_string(thresholdVal) +
+                                ".");
+ 
++        auto bus = sdbusplus::bus::new_default();
++        if (assert == true)
++        {
++            assertCount++;
++            if (assertCount == 1)
++            {
++                setProperty(bus, LED_OBJECTPATH_BASE, "State","xyz.openbmc_project.Led.Physical.Action.On",LED_SERVICE);
++            }
++        }
++        else
++        {
++            assertCount--;
++            if (assertCount == 0)
++            {
++                setProperty(bus, LED_OBJECTPATH_BASE, "State","xyz.openbmc_project.Led.Physical.Action.Off",LED_SERVICE);
++            }
++        }
++
+         selAddSystemRecord(
+             journalMsg, std::string(msg.get_path()), eventData, assert,
+             selBMCGenID, "REDFISH_MESSAGE_ID=%s", redfishMessageID.c_str(),
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0003-fix-sensor-reading-not-match-assert-value-issue.patch b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0003-fix-sensor-reading-not-match-assert-value-issue.patch
new file mode 100755
index 0000000..a2adedc
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0003-fix-sensor-reading-not-match-assert-value-issue.patch
@@ -0,0 +1,31 @@
+From c699b3b59abe4000f4a5d870523f4d3902fea2cb Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 16 Jun 2020 10:29:23 +0800
+Subject: [PATCH 1/1] fix sensor reading not match assert value issue
+
+---
+ include/threshold_event_monitor.hpp | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
+
+diff --git a/include/threshold_event_monitor.hpp b/include/threshold_event_monitor.hpp
+index 49331e3..e5681ca 100755
+--- a/include/threshold_event_monitor.hpp
++++ b/include/threshold_event_monitor.hpp
+@@ -157,7 +157,13 @@ inline static sdbusplus::bus::match::match startThresholdEventMonitor(
+             min = std::visit(ipmi::VariantToDoubleVisitor(), findMin->second);
+         }
+         double sensorVal = 0;
+-        auto findVal = sensorValue.find("Value");
++        //auto findVal = sensorValue.find("Value");
++        std::string valStr = (assert) ? "ValueAssert" : "Value";
++        auto findVal = sensorValue.find(valStr);
++        if (findVal == sensorValue.end())
++        {
++            findVal = sensorValue.find("Value");
++        }
+         if (findVal != sensorValue.end())
+         {
+             sensorVal =
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0004-Bypass-SYS-Air-Inlet-sensor-for-alert-led.patch b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0004-Bypass-SYS-Air-Inlet-sensor-for-alert-led.patch
new file mode 100755
index 0000000..6c1503e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger/0004-Bypass-SYS-Air-Inlet-sensor-for-alert-led.patch
@@ -0,0 +1,47 @@
+From 5afbdf5d2fffce4a09c89b31c4d03501421e619d Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Thu, 6 Aug 2020 13:17:40 +0800
+Subject: [PATCH] bypass SYS Air Inlet sensor for alert led
+
+---
+ include/threshold_event_monitor.hpp | 23 +++++++++++++----------
+ 1 file changed, 13 insertions(+), 10 deletions(-)
+
+diff --git a/include/threshold_event_monitor.hpp b/include/threshold_event_monitor.hpp
+index e5681ca..026b05a 100755
+--- a/include/threshold_event_monitor.hpp
++++ b/include/threshold_event_monitor.hpp
+@@ -303,20 +303,23 @@ inline static sdbusplus::bus::match::match startThresholdEventMonitor(
+                                ".");
+ 
+         auto bus = sdbusplus::bus::new_default();
+-        if (assert == true)
++        if (std::string(sensorName) != "SYS_Air_Inlet")
+         {
+-            assertCount++;
+-            if (assertCount == 1)
++            if (assert == true)
+             {
+-                setProperty(bus, LED_OBJECTPATH_BASE, "State","xyz.openbmc_project.Led.Physical.Action.On",LED_SERVICE);
++                assertCount++;
++                if (assertCount == 1)
++                {
++                    setProperty(bus, LED_OBJECTPATH_BASE, "State","xyz.openbmc_project.Led.Physical.Action.On",LED_SERVICE);
++                }
+             }
+-        }
+-        else
+-        {
+-            assertCount--;
+-            if (assertCount == 0)
++            else
+             {
+-                setProperty(bus, LED_OBJECTPATH_BASE, "State","xyz.openbmc_project.Led.Physical.Action.Off",LED_SERVICE);
++                assertCount--;
++                if (assertCount == 0)
++                {
++                    setProperty(bus, LED_OBJECTPATH_BASE, "State","xyz.openbmc_project.Led.Physical.Action.Off",LED_SERVICE);
++                }
+             }
+         }
+ 
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger_git.bbappend
new file mode 100755
index 0000000..485b9b8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sel-logger/phosphor-sel-logger_git.bbappend
@@ -0,0 +1,13 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+#Enable threshold monitoring
+EXTRA_OECMAKE += "-DSEL_LOGGER_MONITOR_THRESHOLD_EVENTS=ON"
+EXTRA_OECMAKE += "-DREDFISH_LOG_MONITOR_PULSE_EVENTS=ON"
+#SRC_URI += "file://0001-Add-CATERR-sel-log-monitor.patch"
+
+SRC_URI += "file://0001-Change-ipmi_sel-location-to-persistent-folder.patch \
+            file://0002-Alert-led-when-happen-warning.patch \
+            file://0003-fix-sensor-reading-not-match-assert-value-issue.patch \
+            file://0004-Bypass-SYS-Air-Inlet-sensor-for-alert-led.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0001-add-supported-pmbus-name-cffps1.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0001-add-supported-pmbus-name-cffps1.patch
new file mode 100755
index 0000000..6fb8103
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0001-add-supported-pmbus-name-cffps1.patch
@@ -0,0 +1,28 @@
+From 21c86f521cfaaaacfadb0eb550a4ab04236fc443 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 11 Mar 2020 20:53:30 +0800
+Subject: [PATCH 1/1] add supported pmbus name : cffps1
+
+---
+ src/PSUSensorMain.cpp | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+ mode change 100644 => 100755 src/PSUSensorMain.cpp
+
+diff --git a/src/PSUSensorMain.cpp b/src/PSUSensorMain.cpp
+old mode 100644
+new mode 100755
+index 0367d2a..d5d5937
+--- a/src/PSUSensorMain.cpp
++++ b/src/PSUSensorMain.cpp
+@@ -50,7 +50,7 @@ static constexpr std::array<const char*, 7> sensorTypes = {
+ 
+ static std::vector<std::string> pmbusNames = {
+     "isl68137", "ina219",   "ina230", "max20730", "max20734",
+-    "max20796", "max34451", "pmbus",  "pxe1610"};
++    "max20796", "max34451", "pmbus",  "pxe1610", "cffps1"};
+ 
+ namespace fs = std::filesystem;
+ 
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0002-Filter-out-FAN-threshold-event-during-power-transiti.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0002-Filter-out-FAN-threshold-event-during-power-transiti.patch
new file mode 100755
index 0000000..c440179
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0002-Filter-out-FAN-threshold-event-during-power-transiti.patch
@@ -0,0 +1,61 @@
+From d5b486a309f9fdac10eb66588a054aaee5146693 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 10 Dec 2019 21:53:52 +0800
+Subject: [PATCH 1/1] Filter out FAN threshold event during power transitio
+
+---
+ include/TachSensor.hpp | 1 +
+ src/TachSensor.cpp     | 5 ++++-
+ 2 files changed, 5 insertions(+), 1 deletion(-)
+ mode change 100644 => 100755 include/TachSensor.hpp
+ mode change 100644 => 100755 src/TachSensor.cpp
+
+diff --git a/include/TachSensor.hpp b/include/TachSensor.hpp
+old mode 100644
+new mode 100755
+index c7c1b0e..1c15982
+--- a/include/TachSensor.hpp
++++ b/include/TachSensor.hpp
+@@ -87,6 +87,7 @@ class TachSensor : public Sensor
+     void setupRead(void);
+     void handleResponse(const boost::system::error_code& err);
+     void checkThresholds(void) override;
++    thresholds::ThresholdTimer thresholdTimer;
+ };
+ 
+ inline void logFanInserted(const std::string& device)
+diff --git a/src/TachSensor.cpp b/src/TachSensor.cpp
+old mode 100644
+new mode 100755
+index 91a08c1..25cf6fd
+--- a/src/TachSensor.cpp
++++ b/src/TachSensor.cpp
+@@ -53,7 +53,7 @@ TachSensor::TachSensor(const std::string& path, const std::string& objectType,
+     objServer(objectServer), redundancy(redundancy),
+     presence(std::move(presenceSensor)),
+     inputDev(io, open(path.c_str(), O_RDONLY)), waitTimer(io), path(path),
+-    errCount(0)
++    errCount(0), thresholdTimer(io, this)
+ {
+     sensorInterface = objectServer.add_interface(
+         "/xyz/openbmc_project/sensors/fan_tach/" + name,
+@@ -208,6 +208,8 @@ void TachSensor::checkThresholds(void)
+         return;
+     }
+ 
++    thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
++# if 0    
+     bool status = thresholds::checkThresholds(this);
+ 
+     if (redundancy && *redundancy)
+@@ -215,6 +217,7 @@ void TachSensor::checkThresholds(void)
+         (*redundancy)
+             ->update("/xyz/openbmc_project/sensors/fan_tach/" + name, !status);
+     }
++#endif    
+ }
+ 
+ PresenceSensor::PresenceSensor(const size_t index, bool inverted,
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0003-New-processor-sensor-to-replace-gpio-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0003-New-processor-sensor-to-replace-gpio-sensor.patch
new file mode 100755
index 0000000..e0e013c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0003-New-processor-sensor-to-replace-gpio-sensor.patch
@@ -0,0 +1,243 @@
+From 69f338bd2e77f3e1303059ea9710df551187ee1c Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 11 Mar 2020 22:10:52 +0800
+Subject: [PATCH 1/1] New processor sensor to replace gpio sensor
+
+---
+ CMakeLists.txt                                |  15 ++
+ ...yz.openbmc_project.processorsensor.service |  12 ++
+ src/ProcessorSensorMain.cpp                   | 156 ++++++++++++++++++
+ 3 files changed, 183 insertions(+)
+ mode change 100644 => 100755 CMakeLists.txt
+ create mode 100644 service_files/xyz.openbmc_project.processorsensor.service
+ create mode 100755 src/ProcessorSensorMain.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+old mode 100644
+new mode 100755
+index f9d6d31..399faf1
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -47,6 +47,8 @@ option (DISABLE_MCUTEMP "Disable installing MCU temperature sensor" OFF)
+ option (DISABLE_PSU "Disable installing PSU sensor" OFF)
+ option (DISABLE_NVME "Disable installing NVME sensor" ON)
+ 
++option (DISABLE_PROCESSOR "Disable installing processor sensor" OFF)
++
+ include ("cmake/HunterGate.cmake")
+ 
+ huntergate (URL "https://github.com/ruslo/hunter/archive/v0.18.64.tar.gz" SHA1
+@@ -196,6 +198,10 @@ add_executable (psusensor src/PSUSensorMain.cpp ${PSU_SRC_FILES})
+ add_dependencies (psusensor sdbusplus-project)
+ target_link_libraries (psusensor ${SENSOR_LINK_LIBS})
+ 
++add_executable (processorsensor src/ProcessorSensorMain.cpp)
++add_dependencies (processorsensor sdbusplus-project)
++target_link_libraries (processorsensor ${SENSOR_LINK_LIBS})
++
+ if (NOT DISABLE_NVME)
+     add_executable (nvmesensor ${NVME_SRC_FILES})
+     add_dependencies (nvmesensor sdbusplus-project)
+@@ -212,6 +218,7 @@ if (NOT YOCTO)
+     add_dependencies (ipmbsensor ${EXTERNAL_PACKAGES})
+     add_dependencies (mcutempsensor ${EXTERNAL_PACKAGES})
+     add_dependencies (psusensor ${EXTERNAL_PACKAGES})
++    add_dependencies (processorsensor ${EXTERNAL_PACKAGES})
+ endif ()
+ 
+ set (SERVICE_FILE_SRC_DIR ${PROJECT_SOURCE_DIR}/service_files)
+@@ -292,3 +299,11 @@ if (NOT DISABLE_NVME)
+                  ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.nvmesensor.service
+                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+ endif ()
++
++if (NOT DISABLE_PROCESSOR)
++    install (TARGETS processorsensor DESTINATION bin)
++    install (FILES
++                 ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.processorsensor.service
++                 DESTINATION ${SERVICE_FILE_INSTALL_DIR})
++endif ()
++
+diff --git a/service_files/xyz.openbmc_project.processorsensor.service b/service_files/xyz.openbmc_project.processorsensor.service
+new file mode 100644
+index 0000000..eb6e063
+--- /dev/null
++++ b/service_files/xyz.openbmc_project.processorsensor.service
+@@ -0,0 +1,12 @@
++[Unit]
++Description=IPMI defined Proecssor Sensor
++StopWhenUnneeded=false
++After=xyz.openbmc_project.EntityManager.service
++[Service]
++Restart=always
++RestartSec=5
++ExecStart=/usr/bin/env processorsensor
++SyslogIdentifier=processor-sensor
++
++[Install]
++WantedBy=multi-user.target
+diff --git a/src/ProcessorSensorMain.cpp b/src/ProcessorSensorMain.cpp
+new file mode 100755
+index 0000000..8e9986a
+--- /dev/null
++++ b/src/ProcessorSensorMain.cpp
+@@ -0,0 +1,156 @@
++/*
++// Copyright (c) 2018 Intel Corporation
++//
++// Licensed under the Apache License, Version 2.0 (the "License");
++// you may not use this file except in compliance with the License.
++// You may obtain a copy of the License at
++//
++//      http://www.apache.org/licenses/LICENSE-2.0
++//
++// Unless required by applicable law or agreed to in writing, software
++// distributed under the License is distributed on an "AS IS" BASIS,
++// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++// See the License for the specific language governing permissions and
++// limitations under the License.
++*/
++
++//#include <GPIOSensor.hpp>
++#include <Utils.hpp>
++#include <boost/algorithm/string/predicate.hpp>
++#include <boost/asio.hpp>
++#include <chrono>
++#include <ctime>
++#include <iostream>
++#include <sdbusplus/asio/connection.hpp>
++#include <sdbusplus/asio/object_server.hpp>
++#include <sdbusplus/asio/sd_event.hpp>
++#include <sdbusplus/bus.hpp>
++#include <sdbusplus/exception.hpp>
++#include <sdbusplus/server.hpp>
++#include <sdbusplus/timer.hpp>
++#include <sensor.hpp>
++#include <systemd/sd-journal.h>
++
++
++static constexpr bool DEBUG = true;
++
++static constexpr char const* ipmiSELService =    "xyz.openbmc_project.Logging.IPMI";
++static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
++static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
++
++static const std::string ipmiSELAddMessage = "SEL Entry";
++static constexpr size_t selEvtDataMaxSize = 3;
++
++
++int main()
++{
++    int gpioIndex = -1;
++    bool gpioInverted = false;
++    int baseconfigureflag=0;
++    uint64_t sensorNumber=0;
++    std::string sensorName;
++    std::string sensorInterface;
++    std::string sensorStateNormal;
++    std::string sensorStateActive;
++    std::string sensorProperty;
++    // setup connection to dbus
++    boost::asio::io_service io;
++    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
++    auto objServer = sdbusplus::asio::object_server(systemBus);
++
++    // setup object server, define interface
++    systemBus->request_name("xyz.openbmc_project.ProcessorSensor");
++
++#if 0 //TODO get sensor name from entity manager 
++    if (getGPIOSensorConfig(systemBus, &gpioIndex, &gpioInverted, &sensorNumber, sensorName, sensorInterface, sensorStateNormal, sensorStateActive, sensorProperty))
++    {
++        baseconfigureflag=1;
++    }else
++    {
++        return -1;
++    }
++#endif 
++    std::shared_ptr<sdbusplus::asio::dbus_interface> iface =
++        objServer.add_interface("/xyz/openbmc_project/sensors/processor/CATERR",sensorValueInterface);
++
++    double value = 0;
++    //ray__ test value
++    iface->register_property("Value", value);
++    iface->initialize();
++    
++    auto caterrEventMatcherCallback =
++        [systemBus](sdbusplus::message::message& message) {
++            boost::container::flat_map<std::string, sdbusplus::message::variant<std::string>> propertiesChanged;
++            std::string objectName;
++            std::cerr << "ray__ callback caterrEventMatcher!!!\n";
++            if (message.is_method_error())
++            {
++                std::cerr << "callback method error\n";
++                return;
++            }
++
++            if (DEBUG)
++            {
++                std::cout << message.get_path() << " is changed\n";
++            }
++            std::string sensorPath =  message.get_path();
++            message.read(objectName, propertiesChanged);
++            std::string event = propertiesChanged.begin()->first;
++	 
++            auto variant = sdbusplus::message::variant_ns::get_if<std::string>(
++	        &propertiesChanged.begin()->second);
++
++            if (event.empty() || nullptr == variant)
++            {
++                return;
++            }
++            if (event == "ProcessorStatus")
++            {
++                if (*variant == "xyz.openbmc_project.Control.Processor.State.CATERR")
++                {
++                    //log redfish
++                    std::string errMsg("CATERR occur");
++                    bool assert=1;
++                    std::string redfishMsgId("CATERR!");
++                    sd_journal_send("MESSAGE=%s", errMsg.c_str(),
++                                    "REDFISH_MESSAGE_ID=%s", redfishMsgId.c_str(), NULL);
++
++                    //log SEL
++                    //Processor
++                    uint16_t genid = 0x20;
++
++                    std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
++                    //set eventdata1 to 0xb  , for now unspecified byte2 & btye3 , not implement A0 in bit[7:4]
++                    eventData[0] = static_cast<uint8_t>(0xb);  
++                    sdbusplus::message::message writeSEL = systemBus->new_method_call(
++                        ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++                    writeSEL.append(ipmiSELAddMessage,  std::string("/xyz/openbmc_project/sensors/processor/CATERR"), eventData, assert,
++                        genid);
++
++                    
++                    try
++                    {
++                        systemBus->call(writeSEL);
++                    }
++                        catch (sdbusplus::exception_t& e)
++                    {
++                        std::cerr << "call IpmiSelAdd failed\n";
++                    }
++                      
++                }
++                
++            }
++
++        };
++
++    //event trigger, this can move to poll the gpio service.
++    sdbusplus::bus::match::match caterrEventMatcher(
++        static_cast<sdbusplus::bus::bus&>(*systemBus),
++        "type='signal',interface='org.freedesktop.DBus.Properties',member='"
++        "PropertiesChanged',arg0namespace='xyz.openbmc_project.Control.Processor'",
++        std::move(caterrEventMatcherCallback));
++
++    io.run();
++
++    return 0;
++}
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0004-support-ipmi-ACPI-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0004-support-ipmi-ACPI-sensor.patch
new file mode 100755
index 0000000..41df2d8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0004-support-ipmi-ACPI-sensor.patch
@@ -0,0 +1,216 @@
+From 986804831c2a2cf2d0bc734a688fa88c5c790b1a Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 10:46:57 +0800
+Subject: [PATCH 1/1] support ipmi ACPI sensor
+
+---
+ CMakeLists.txt                                |  14 ++
+ .../xyz.openbmc_project.acpisensor.service    |  12 ++
+ src/AcpiSensorMain.cpp                        | 133 ++++++++++++++++++
+ 3 files changed, 159 insertions(+)
+ create mode 100644 service_files/xyz.openbmc_project.acpisensor.service
+ create mode 100755 src/AcpiSensorMain.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 399faf1..b0f44de 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -48,6 +48,7 @@ option (DISABLE_PSU "Disable installing PSU sensor" OFF)
+ option (DISABLE_NVME "Disable installing NVME sensor" ON)
+ 
+ option (DISABLE_PROCESSOR "Disable installing processor sensor" OFF)
++option (DISABLE_ACPI "Disable installing acpi sensor" OFF)
+ 
+ include ("cmake/HunterGate.cmake")
+ 
+@@ -202,6 +203,10 @@ add_executable (processorsensor src/ProcessorSensorMain.cpp)
+ add_dependencies (processorsensor sdbusplus-project)
+ target_link_libraries (processorsensor ${SENSOR_LINK_LIBS})
+ 
++add_executable (acpisensor src/AcpiSensorMain.cpp)
++add_dependencies (acpisensor sdbusplus-project)
++target_link_libraries (acpisensor ${SENSOR_LINK_LIBS})
++
+ if (NOT DISABLE_NVME)
+     add_executable (nvmesensor ${NVME_SRC_FILES})
+     add_dependencies (nvmesensor sdbusplus-project)
+@@ -219,6 +224,7 @@ if (NOT YOCTO)
+     add_dependencies (mcutempsensor ${EXTERNAL_PACKAGES})
+     add_dependencies (psusensor ${EXTERNAL_PACKAGES})
+     add_dependencies (processorsensor ${EXTERNAL_PACKAGES})
++    add_dependencies (acpisensor ${EXTERNAL_PACKAGES})
+ endif ()
+ 
+ set (SERVICE_FILE_SRC_DIR ${PROJECT_SOURCE_DIR}/service_files)
+@@ -307,3 +313,11 @@ if (NOT DISABLE_PROCESSOR)
+                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+ endif ()
+ 
++if (NOT DISABLE_ACPI)
++    install (TARGETS acpisensor DESTINATION bin)
++    install (FILES
++                 ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.acpisensor.service
++                 DESTINATION ${SERVICE_FILE_INSTALL_DIR})
++endif ()
++
++
+diff --git a/service_files/xyz.openbmc_project.acpisensor.service b/service_files/xyz.openbmc_project.acpisensor.service
+new file mode 100644
+index 0000000..f3e83c6
+--- /dev/null
++++ b/service_files/xyz.openbmc_project.acpisensor.service
+@@ -0,0 +1,12 @@
++[Unit]
++Description=IPMI defined acpi Sensor
++StopWhenUnneeded=false
++After=xyz.openbmc_project.EntityManager.service
++[Service]
++Restart=always
++RestartSec=5
++ExecStart=/usr/bin/env acpisensor
++SyslogIdentifier=acpi-sensor
++
++[Install]
++WantedBy=multi-user.target
+diff --git a/src/AcpiSensorMain.cpp b/src/AcpiSensorMain.cpp
+new file mode 100755
+index 0000000..6cd8285
+--- /dev/null
++++ b/src/AcpiSensorMain.cpp
+@@ -0,0 +1,133 @@
++/*
++// Copyright (c) 2018 Intel Corporation
++//
++// Licensed under the Apache License, Version 2.0 (the "License");
++// you may not use this file except in compliance with the License.
++// You may obtain a copy of the License at
++//
++//      http://www.apache.org/licenses/LICENSE-2.0
++//
++// Unless required by applicable law or agreed to in writing, software
++// distributed under the License is distributed on an "AS IS" BASIS,
++// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++// See the License for the specific language governing permissions and
++// limitations under the License.
++*/
++
++#include <Utils.hpp>
++#include <boost/algorithm/string/predicate.hpp>
++#include <boost/asio.hpp>
++#include <chrono>
++#include <ctime>
++#include <iostream>
++#include <sdbusplus/asio/connection.hpp>
++#include <sdbusplus/asio/object_server.hpp>
++#include <sdbusplus/asio/sd_event.hpp>
++#include <sdbusplus/bus.hpp>
++#include <sdbusplus/exception.hpp>
++#include <sdbusplus/server.hpp>
++#include <sdbusplus/timer.hpp>
++#include <sensor.hpp>
++#include <systemd/sd-journal.h>
++
++
++static constexpr bool DEBUG = true;
++
++static constexpr char const* ipmiSELService =    "xyz.openbmc_project.Logging.IPMI";
++static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
++static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
++
++static const std::string ipmiSELAddMessage = "SEL Entry";
++static const std::string sensorPath = "/xyz/openbmc_project/sensors/acpi/ACPI_POWER_STATE";
++
++static constexpr size_t selEvtDataMaxSize = 3;
++
++int main()
++{
++    int gpioIndex = -1;
++    bool gpioInverted = false;
++    int baseconfigureflag=0;
++    uint64_t sensorNumber=0;
++    std::string sensorName;
++    std::string sensorInterface;
++    std::string sensorStateNormal;
++    std::string sensorStateActive;
++    std::string sensorProperty;
++    // setup connection to dbus
++    boost::asio::io_service io;
++    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
++    auto objServer = sdbusplus::asio::object_server(systemBus);
++
++    // setup object server, define interface
++    systemBus->request_name("xyz.openbmc_project.AcpiSensor");
++
++    // add acpi interface into sensor tree
++    std::shared_ptr<sdbusplus::asio::dbus_interface> iface =
++        objServer.add_interface(sensorPath,sensorValueInterface);
++
++    double value = 0;
++    //dummy value, just identifier for sdr command   
++    iface->register_property("Value", value);
++    iface->initialize();
++    
++    auto PgoodEventMatcherCallback =
++        [systemBus](sdbusplus::message::message& message) {
++            boost::container::flat_map<std::string, std::variant<int>> propertiesChanged;
++            std::string objectName;
++            if (message.is_method_error())
++            {
++                std::cerr << "callback method error\n";
++                return;
++            }
++
++            if (DEBUG)
++            {
++                std::cout << message.get_path() << " is changed\n";
++            }
++            message.read(objectName, propertiesChanged);
++            std::string event = propertiesChanged.begin()->first;
++            int *pgood = std::get_if<int>(&propertiesChanged.begin()->second);
++
++            if (!pgood)
++            {
++                std::cerr << "event has invalid type\n";
++                return;
++            }
++           
++            if (event == "pgood")
++            {
++                //log SEL
++                uint16_t genid = 0x20;
++                bool assert=1;
++                std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
++                eventData[0] = (*pgood == 1) ? 0:5;
++                       
++                sdbusplus::message::message writeSEL = systemBus->new_method_call(
++                            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++                writeSEL.append(ipmiSELAddMessage,  std::string(sensorPath), eventData, assert,
++                        genid);
++                    
++                try
++                {
++                    systemBus->call(writeSEL);
++                }
++                    catch (sdbusplus::exception_t& e)
++                {
++                    std::cerr << "call IpmiSelAdd failed\n";
++                }
++               
++            }
++
++        };
++
++    //event trigger, this can move to poll the gpio service.
++    sdbusplus::bus::match::match caterrEventMatcher(
++        static_cast<sdbusplus::bus::bus&>(*systemBus),
++        "type='signal',interface='org.freedesktop.DBus.Properties',member='"
++        "PropertiesChanged',arg0namespace='org.openbmc.control.Power'",
++        std::move(PgoodEventMatcherCallback));
++
++    io.run();
++
++    return 0;
++}
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0005-add-event-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0005-add-event-sensor.patch
new file mode 100755
index 0000000..51b3a5d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0005-add-event-sensor.patch
@@ -0,0 +1,187 @@
+From ec01da87a278212c878c9a07d2fc09f25660779f Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 11:03:32 +0800
+Subject: [PATCH 1/1] add event sensor
+
+---
+ CMakeLists.txt                                |   7 +
+ .../xyz.openbmc_project.eventsensor.service   |  12 ++
+ src/eventSensor.cpp                           | 124 ++++++++++++++++++
+ 3 files changed, 143 insertions(+)
+ create mode 100644 service_files/xyz.openbmc_project.eventsensor.service
+ create mode 100755 src/eventSensor.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index b0f44de..7cef855 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -207,6 +207,10 @@ add_executable (acpisensor src/AcpiSensorMain.cpp)
+ add_dependencies (acpisensor sdbusplus-project)
+ target_link_libraries (acpisensor ${SENSOR_LINK_LIBS})
+ 
++add_executable (eventsensor src/eventSensor.cpp)
++add_dependencies (eventsensor sdbusplus-project)
++target_link_libraries (eventsensor ${SENSOR_LINK_LIBS})
++
+ if (NOT DISABLE_NVME)
+     add_executable (nvmesensor ${NVME_SRC_FILES})
+     add_dependencies (nvmesensor sdbusplus-project)
+@@ -320,4 +324,7 @@ if (NOT DISABLE_ACPI)
+                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+ endif ()
+ 
++install (TARGETS eventsensor DESTINATION bin)
++install (FILES ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.eventsensor.service
++            DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+ 
+diff --git a/service_files/xyz.openbmc_project.eventsensor.service b/service_files/xyz.openbmc_project.eventsensor.service
+new file mode 100644
+index 0000000..d62a5a8
+--- /dev/null
++++ b/service_files/xyz.openbmc_project.eventsensor.service
+@@ -0,0 +1,12 @@
++[Unit]
++Description=IPMI Event-only Sensor
++StopWhenUnneeded=false
++After=xyz.openbmc_project.EntityManager.service
++
++[Service]
++Restart=always
++RestartSec=5
++ExecStart=/usr/bin/eventsensor
++
++[Install]
++WantedBy=multi-user.target
+diff --git a/src/eventSensor.cpp b/src/eventSensor.cpp
+new file mode 100755
+index 0000000..6674c30
+--- /dev/null
++++ b/src/eventSensor.cpp
+@@ -0,0 +1,124 @@
++/*
++// Copyright (c) 2018 Intel Corporation
++//
++// Licensed under the Apache License, Version 2.0 (the "License");
++// you may not use this file except in compliance with the License.
++// You may obtain a copy of the License at
++//
++//      http://www.apache.org/licenses/LICENSE-2.0
++//
++// Unless required by applicable law or agreed to in writing, software
++// distributed under the License is distributed on an "AS IS" BASIS,
++// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++// See the License for the specific language governing permissions and
++// limitations under the License.
++*/
++
++#include <Utils.hpp>
++#include <boost/algorithm/string/predicate.hpp>
++#include <boost/asio.hpp>
++#include <chrono>
++#include <ctime>
++#include <iostream>
++#include <sdbusplus/asio/connection.hpp>
++#include <sdbusplus/asio/object_server.hpp>
++#include <sdbusplus/asio/sd_event.hpp>
++#include <sdbusplus/bus.hpp>
++#include <sdbusplus/exception.hpp>
++#include <sdbusplus/server.hpp>
++#include <sdbusplus/timer.hpp>
++#include <sensor.hpp>
++#include <systemd/sd-journal.h>
++
++static constexpr bool DEBUG = false;
++
++//{sensor name, sensor type}
++const static boost::container::flat_map<std::string, std::string>eventsensors
++    {
++        {"IPMI_Power_Diag","fru_state"}
++    };
++
++struct eventSensor 
++{
++    eventSensor(
++                sdbusplus::asio::object_server& objectServer,
++                std::shared_ptr<sdbusplus::asio::connection>& conn,
++                boost::asio::io_service& io, const std::string& sensorName, const std::string& sensorType):
++                objectServer(objectServer), dbusConnection(conn)
++    {
++        std::string sensorPath = "/xyz/openbmc_project/sensors/"+sensorType+"/"+sensorName;
++        if (DEBUG)
++        {
++            std::cerr << sensorPath << "\n";
++        }
++        if (!conn)
++        {
++            std::cerr << "Connection not created\n";
++            return;
++        }
++        
++        intf = objectServer.add_interface(sensorPath,sensorValueInterface);
++        intf->register_property("Value", value);
++        if (!intf->initialize())    
++        {
++            std::cerr << "error initializing value interface\n";    
++        }
++    }
++    ~eventSensor()
++    {
++         objectServer.remove_interface(intf);
++    }
++    void init(void);
++
++  private:
++    sdbusplus::asio::object_server& objectServer;
++    std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
++    std::shared_ptr<sdbusplus::asio::dbus_interface> intf;
++    double value = 0;
++};
++
++void eventSensor::init(void)
++{
++   //do nothing for now;
++}
++
++void createSensors(
++    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
++    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection, 
++    boost::container::flat_map<std::string, std::unique_ptr<eventSensor>>& sensors)
++{
++    for(auto const& it:eventsensors)
++    {
++        std::cerr << it.first << ":" << it.second << '\n';
++        sensors[it.first] = std::make_unique<eventSensor>(
++            objectServer, dbusConnection, io, it.first, it.second );
++
++        sensors[it.first]->init();
++    }        
++}
++
++int main()
++{
++    // setup connection to dbus
++    boost::asio::io_service io;
++    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
++    auto objServer = sdbusplus::asio::object_server(systemBus);
++    boost::container::flat_map<std::string, std::unique_ptr<eventSensor>> sensors;
++
++    // setup object server, define interface
++    systemBus->request_name("xyz.openbmc_project.eventSensor");
++
++    if (DEBUG)
++    {
++        for(auto const& pair:eventsensors)
++            std::cerr << pair.first << ":" << pair.second << '\n';
++    }
++
++    io.post([&]() {
++        createSensors(io, objServer, systemBus,sensors);
++    });
++
++    //auto work = std::make_shared<boost::asio::io_service::work>(io);
++    io.run();
++    return 0;
++}
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0006-Add-OCP-NIC-temperature-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0006-Add-OCP-NIC-temperature-sensor.patch
new file mode 100755
index 0000000..893c0bf
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0006-Add-OCP-NIC-temperature-sensor.patch
@@ -0,0 +1,191 @@
+From a947d9511006dbcd7773c9ae8faef1517ecbd41b Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 13:57:46 +0800
+Subject: [PATCH] Add OCP NIC temperature sensor
+
+---
+ include/HwmonTempSensor.hpp |  1 +
+ src/HwmonTempMain.cpp       | 27 +++++++++++++++-------
+ src/HwmonTempSensor.cpp     | 55 ++++++++++++++++++++++++++++++++++++++++-----
+ 3 files changed, 70 insertions(+), 13 deletions(-)
+ mode change 100644 => 100755 include/HwmonTempSensor.hpp
+ mode change 100644 => 100755 src/HwmonTempMain.cpp
+ mode change 100644 => 100755 src/HwmonTempSensor.cpp
+
+diff --git a/include/HwmonTempSensor.hpp b/include/HwmonTempSensor.hpp
+old mode 100644
+new mode 100755
+index e041085..a91a82d
+--- a/include/HwmonTempSensor.hpp
++++ b/include/HwmonTempSensor.hpp
+@@ -26,6 +26,7 @@ class HwmonTempSensor : public Sensor
+     boost::asio::streambuf readBuf;
+     std::string path;
+     PowerState readState;
++    thresholds::ThresholdTimer thresholdTimer;
+     size_t errCount;
+     void setupRead(void);
+     void handleResponse(const boost::system::error_code& err);
+diff --git a/src/HwmonTempMain.cpp b/src/HwmonTempMain.cpp
+old mode 100644
+new mode 100755
+index 55d4508..1472b4e
+--- a/src/HwmonTempMain.cpp
++++ b/src/HwmonTempMain.cpp
+@@ -196,7 +196,8 @@ void createSensors(
+                     }
+                 }
+                 std::vector<thresholds::Threshold> sensorThresholds;
+-                if (!parseThresholdsFromConfig(*sensorData, sensorThresholds))
++                std::string label = "temp1";
++                if (!parseThresholdsFromConfig(*sensorData, sensorThresholds, &label))
+                 {
+                     std::cerr << "error populating thresholds for "
+                               << sensorName << "\n";
+@@ -209,12 +210,15 @@ void createSensors(
+                         VariantToStringVisitor(), findPowerOn->second);
+                     setReadState(powerState, readState);
+                 }
+-                auto& sensor = sensors[sensorName];
+-                sensor = nullptr;
+-                sensor = std::make_unique<HwmonTempSensor>(
+-                    directory.string() + "/temp1_input", sensorType,
+-                    objectServer, dbusConnection, io, sensorName,
+-                    std::move(sensorThresholds), *interfacePath, readState);
++
++                if (deviceName != "14-001f"){
++                    auto& sensor = sensors[sensorName];
++                    sensor = nullptr;
++                    sensor = std::make_unique<HwmonTempSensor>(
++                            directory.string() + "/temp1_input", sensorType,
++                            objectServer, dbusConnection, io, sensorName,
++                            std::move(sensorThresholds), *interfacePath, readState);
++                }
+ 
+                 // Looking for keys like "Name1" for temp2_input,
+                 // "Name2" for temp3_input, etc.
+@@ -231,13 +235,20 @@ void createSensors(
+ 
+                     std::string sensorName =
+                         std::get<std::string>(findKey->second);
++                    std::vector<thresholds::Threshold> sensorThresholds;
++                    label = "temp" + std::string(1, '1' + i);
++                    if (!parseThresholdsFromConfig(*sensorData, sensorThresholds, &label))
++                    {
++                        std::cerr << "error populating thresholds for " << sensorName << "\n";
++                    }
++
+                     auto& sensor = sensors[sensorName];
+                     sensor = nullptr;
+                     sensor = std::make_unique<HwmonTempSensor>(
+                         directory.string() + "/temp" + std::string(1, '1' + i) +
+                             "_input",
+                         sensorType, objectServer, dbusConnection, io,
+-                        sensorName, std::vector<thresholds::Threshold>(),
++                        sensorName, std::move(sensorThresholds),
+                         *interfacePath, readState);
+                 }
+             }
+diff --git a/src/HwmonTempSensor.cpp b/src/HwmonTempSensor.cpp
+old mode 100644
+new mode 100755
+index cf8ee10..2af0ba4
+--- a/src/HwmonTempSensor.cpp
++++ b/src/HwmonTempSensor.cpp
+@@ -43,12 +43,13 @@ HwmonTempSensor::HwmonTempSensor(
+     std::shared_ptr<sdbusplus::asio::connection>& conn,
+     boost::asio::io_service& io, const std::string& sensorName,
+     std::vector<thresholds::Threshold>&& _thresholds,
+-    const std::string& sensorConfiguration, const PowerState powerState) :
++    const std::string& sensorConfiguration, PowerState readState) :
+     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
+            std::move(_thresholds), sensorConfiguration, objectType, maxReading,
+            minReading),
+     objServer(objectServer), inputDev(io, open(path.c_str(), O_RDONLY)),
+-    waitTimer(io), path(path), errCount(0), readState(powerState)
++    waitTimer(io), path(path), errCount(0), readState(std::move(readState)),
++    thresholdTimer(io, this)
+ {
+     sensorInterface = objectServer.add_interface(
+         "/xyz/openbmc_project/sensors/temperature/" + name,
+@@ -97,8 +98,41 @@ void HwmonTempSensor::handleResponse(const boost::system::error_code& err)
+ {
+     if (err == boost::system::errc::bad_file_descriptor)
+     {
++        updateValueInvalid(true);
+         return; // we're being destroyed
+     }
++
++    // Set as sensor reading invalid for power-on type sensor
++    if (readState != PowerState::always && !isPowerOn())
++    {
++        updateValueInvalid(true);
++        updateValue(0);
++        errCount = 0;
++
++        // clear response buffer reading
++        std::istream invalidResponseStream(&readBuf);
++        std::string invalidResponse;
++        std::getline(invalidResponseStream, invalidResponse);
++        invalidResponseStream.clear();
++
++        inputDev.close();
++        int fd = open(path.c_str(), O_RDONLY);
++        if (fd <= 0)
++        {
++            return;
++        }
++        inputDev.assign(fd);
++        waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++        waitTimer.async_wait([&](const boost::system::error_code& ec) {
++            if (ec == boost::asio::error::operation_aborted)
++            {
++                return;
++            }
++            setupRead();
++        });
++        return;
++    }
++
+     std::istream responseStream(&readBuf);
+     if (!err)
+     {
+@@ -113,6 +147,7 @@ void HwmonTempSensor::handleResponse(const boost::system::error_code& err)
+                 updateValue(nvalue);
+             }
+             errCount = 0;
++            updateValueInvalid(false);
+         }
+         catch (const std::invalid_argument&)
+         {
+@@ -138,7 +173,8 @@ void HwmonTempSensor::handleResponse(const boost::system::error_code& err)
+ 
+     if (errCount >= warnAfterErrorCount)
+     {
+-        updateValue(0);
++        updateValueInvalid(true);
++        //updateValue(0);
+     }
+     responseStream.clear();
+     inputDev.close();
+@@ -160,9 +196,18 @@ void HwmonTempSensor::handleResponse(const boost::system::error_code& err)
+ 
+ void HwmonTempSensor::checkThresholds(void)
+ {
+-    if (readState == PowerState::on && !isPowerOn())
++    if (readState != PowerState::always && !isPowerOn())
+     {
+         return;
+     }
+-    thresholds::checkThresholds(this);
++    //thresholds::checkThresholds(this);
++
++    if(readState == PowerState::always)
++    {
++        thresholds::checkThresholds(this);
++    }
++    else
++    {
++        thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
++    }
+ }
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0007-add-necessary-event-sensors-in-dbus.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0007-add-necessary-event-sensors-in-dbus.patch
new file mode 100755
index 0000000..cd38f3e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0007-add-necessary-event-sensors-in-dbus.patch
@@ -0,0 +1,31 @@
+From b1f73828af34268be1c5e55befa4a8ad7eb241ff Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 14:38:07 +0800
+Subject: [PATCH 1/1] add necessary event sensors in dbus
+
+---
+ src/eventSensor.cpp | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
+
+diff --git a/src/eventSensor.cpp b/src/eventSensor.cpp
+index 6674c30..b99396d 100755
+--- a/src/eventSensor.cpp
++++ b/src/eventSensor.cpp
+@@ -35,7 +35,13 @@ static constexpr bool DEBUG = false;
+ //{sensor name, sensor type}
+ const static boost::container::flat_map<std::string, std::string>eventsensors
+     {
+-        {"IPMI_Power_Diag","fru_state"}
++        {"IPMI_Power_Diag","fru_state"},
++        {"SYSTEM_RESTART", "restart"}, //system restart sensor
++        {"BUTTON","pwr_button"},  
++        {"BMC_FW_UPDATE","versionchange"}, 
++        {"BMC_Reboot","mgtsubsyshealth"},    
++        {"PSU_STATUS","power_supply"}, 
++        {"IPMI_POWER_CYCLE","fru_state"}    
+     };
+ 
+ struct eventSensor 
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0011-Add-OCP-NIC-temperature-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0011-Add-OCP-NIC-temperature-sensor.patch
new file mode 100755
index 0000000..300c0e6
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0011-Add-OCP-NIC-temperature-sensor.patch
@@ -0,0 +1,38 @@
+From e0899eec41a52d3ec048d2b3c9e9e5b5d982428d Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 10 Dec 2019 21:05:13 +0800
+Subject: [PATCH 1/1] Add OCP NIC temperature sensor
+
+---
+ src/HwmonTempMain.cpp | 15 +++++++++------
+ 1 file changed, 9 insertions(+), 6 deletions(-)
+
+diff --git a/src/HwmonTempMain.cpp b/src/HwmonTempMain.cpp
+index 5d6befc..10c29f2 100755
+--- a/src/HwmonTempMain.cpp
++++ b/src/HwmonTempMain.cpp
+@@ -204,12 +204,15 @@ void createSensors(
+                               << sensorName << "\n";
+                 }
+                 std::vector<thresholds::Threshold> t = sensorThresholds;
+-                auto& sensor1 = sensors[sensorName];
+-                sensor1 = nullptr;
+-                sensor1 = std::make_unique<HwmonTempSensor>(
+-                    directory.string() + "/temp1_input", sensorType,
+-                    objectServer, dbusConnection, io, sensorName,
+-                    std::move(sensorThresholds), *interfacePath);
++                if (deviceName != "14-001f")
++                {
++                    auto& sensor1 = sensors[sensorName];
++                    sensor1 = nullptr;
++                    sensor1 = std::make_unique<HwmonTempSensor>(
++                        directory.string() + "/temp1_input", sensorType,
++                        objectServer, dbusConnection, io, sensorName,
++                        std::move(sensorThresholds), *interfacePath);
++                }
+                 auto findSecondName = baseConfiguration->second.find("Name1");
+                 if (findSecondName == baseConfiguration->second.end())
+                 {
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0013-add-ipmi-power-status-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0013-add-ipmi-power-status-sensor.patch
new file mode 100755
index 0000000..0e79327
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0013-add-ipmi-power-status-sensor.patch
@@ -0,0 +1,211 @@
+From a9e450803ff3962887d43c1d0334f75148d2b311 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 14:07:00 +0800
+Subject: [PATCH 1/1] add ipmi power status sensor
+
+---
+ CMakeLists.txt                                |  13 ++
+ .../xyz.openbmc_project.aclostsensor.service  |  15 ++
+ src/AcLostSensor.cpp                          | 133 ++++++++++++++++++
+ 3 files changed, 161 insertions(+)
+ create mode 100644 service_files/xyz.openbmc_project.aclostsensor.service
+ create mode 100644 src/AcLostSensor.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 7cef855..e81611b 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -49,6 +49,7 @@ option (DISABLE_NVME "Disable installing NVME sensor" ON)
+ 
+ option (DISABLE_PROCESSOR "Disable installing processor sensor" OFF)
+ option (DISABLE_ACPI "Disable installing acpi sensor" OFF)
++option (DISABLE_POWER_STATUS "Disable installing power status sensor" OFF)
+ 
+ include ("cmake/HunterGate.cmake")
+ 
+@@ -211,6 +212,10 @@ add_executable (eventsensor src/eventSensor.cpp)
+ add_dependencies (eventsensor sdbusplus-project)
+ target_link_libraries (eventsensor ${SENSOR_LINK_LIBS})
+ 
++add_executable (aclostsensor src/AcLostSensor.cpp)
++add_dependencies (aclostsensor sdbusplus-project)
++target_link_libraries (aclostsensor ${SENSOR_LINK_LIBS})
++
+ if (NOT DISABLE_NVME)
+     add_executable (nvmesensor ${NVME_SRC_FILES})
+     add_dependencies (nvmesensor sdbusplus-project)
+@@ -328,3 +333,11 @@ install (TARGETS eventsensor DESTINATION bin)
+ install (FILES ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.eventsensor.service
+             DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+ 
++if (NOT DISABLE_POWER_STATUS)
++    install (TARGETS aclostsensor DESTINATION bin)
++    install (FILES
++                 ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.aclostsensor.service
++                 DESTINATION ${SERVICE_FILE_INSTALL_DIR})
++endif ()
++
++
+diff --git a/service_files/xyz.openbmc_project.aclostsensor.service b/service_files/xyz.openbmc_project.aclostsensor.service
+new file mode 100644
+index 0000000..ceff86f
+--- /dev/null
++++ b/service_files/xyz.openbmc_project.aclostsensor.service
+@@ -0,0 +1,15 @@
++[Unit]
++Description=IPMI defined ac lost Sensor
++StopWhenUnneeded=false
++After=xyz.openbmc_project.Logging.IPMI.service
++After=obmc-sync-pch-rtc.service
++
++[Service]
++Restart=always
++RestartSec=5
++ExecStartPre=/bin/bash -c 'while [ ! -e /run/time_sync_done ]; do sleep 1; done'
++ExecStart=/usr/bin/env aclostsensor
++SyslogIdentifier=aclost-sensor
++
++[Install]
++WantedBy=multi-user.target
+diff --git a/src/AcLostSensor.cpp b/src/AcLostSensor.cpp
+new file mode 100644
+index 0000000..b459f7b
+--- /dev/null
++++ b/src/AcLostSensor.cpp
+@@ -0,0 +1,133 @@
++/*
++// Copyright (c) 2018 Intel Corporation
++//
++// Licensed under the Apache License, Version 2.0 (the "License");
++// you may not use this file except in compliance with the License.
++// You may obtain a copy of the License at
++//
++//      http://www.apache.org/licenses/LICENSE-2.0
++//
++// Unless required by applicable law or agreed to in writing, software
++// distributed under the License is distributed on an "AS IS" BASIS,
++// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++// See the License for the specific language governing permissions and
++// limitations under the License.
++*/
++
++#include <Utils.hpp>
++#include <boost/algorithm/string/predicate.hpp>
++#include <boost/asio.hpp>
++#include <chrono>
++#include <ctime>
++#include <iostream>
++#include <sdbusplus/asio/connection.hpp>
++#include <sdbusplus/asio/object_server.hpp>
++#include <sdbusplus/asio/sd_event.hpp>
++#include <sdbusplus/bus.hpp>
++#include <sdbusplus/exception.hpp>
++#include <sdbusplus/server.hpp>
++#include <sdbusplus/timer.hpp>
++#include <sensor.hpp>
++#include <systemd/sd-journal.h>
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <unistd.h>
++
++static constexpr bool DEBUG = true;
++
++static constexpr char const* ipmiSELService = "xyz.openbmc_project.Logging.IPMI";
++static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
++static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
++
++static const std::string ipmiSELAddMessage = "SEL Entry";
++static const std::string sensorPath = "/xyz/openbmc_project/sensors/power_unit/POWER_STATUS";
++
++static constexpr size_t selEvtDataMaxSize = 3;
++
++int execmd(char* cmd,char* result) {
++    char buffer[128];
++    FILE* pipe = popen(cmd, "r");
++    if (!pipe)
++        return -1;
++
++    while(!feof(pipe)) {
++        if(fgets(buffer, 128, pipe)){
++            strcat(result,buffer);
++        }
++    }
++    pclose(pipe);
++    return 0;
++}
++
++
++int main()
++{
++
++    int rc = 0;
++    char command[100];
++    char temp[50];
++    uint8_t ResetFlag=0;
++    uint8_t data=0;
++
++    // setup connection to dbus
++    boost::asio::io_service io;
++    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
++    auto objServer = sdbusplus::asio::object_server(systemBus);
++
++    // setup object server, define interface
++    systemBus->request_name("xyz.openbmc_project.AcLostSensor");
++
++    // add interface into sensor tree
++    std::shared_ptr<sdbusplus::asio::dbus_interface> iface =
++        objServer.add_interface(sensorPath,sensorValueInterface);
++
++    double value = 0;
++    //dummy value, just identifier for sdr command   
++    iface->register_property("Value", value);
++    iface->initialize();
++
++    sprintf(command, "devmem 0x1e6e203c");
++    memset(temp, 0, sizeof(temp));
++    rc = execmd((char *)command, temp);
++    if (rc != 0)
++    {
++        std::cerr << "get SCU3C register failed\n";
++    }
++
++    ResetFlag=(strtoull(temp,NULL,0)&0x1);
++
++    if (ResetFlag==1)
++    {
++        uint16_t genid = 0x20;
++        bool assert = 1;
++        std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
++        eventData[0] = 4;
++
++        sdbusplus::message::message writeSEL = systemBus->new_method_call(
++            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++        writeSEL.append(ipmiSELAddMessage, std::string(sensorPath), eventData, assert,
++                    genid);
++        try
++        {
++            systemBus->call(writeSEL);
++        }
++        catch (sdbusplus::exception_t& e)
++        {
++            std::cerr << "call IpmiSelAdd failed\n";
++        }
++
++        data=strtoull(temp,NULL,0);
++        memset(command, 0, sizeof(command));
++        snprintf(command,sizeof(command),"devmem 0x1e6e203c 32 0x%x",data-1);
++        rc = system(command);
++        if (rc != 0)
++        {
++            std::cerr << "set SCU3C register failed\n";
++        }
++    }
++
++    io.run();
++
++    return 0;
++}
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0015-hidden-peci-core-temperature-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0015-hidden-peci-core-temperature-sensor.patch
new file mode 100755
index 0000000..5a079bd
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0015-hidden-peci-core-temperature-sensor.patch
@@ -0,0 +1,29 @@
+From f3ee8dac3107a1ac00a8e06e4c3e44c276c3f735 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Thu, 14 Nov 2019 13:20:06 +0800
+Subject: [PATCH] hidden peci core temperature sensor
+
+---
+ src/CPUSensorMain.cpp | 6 ++++++
+ 1 file changed, 6 insertions(+)
+ mode change 100644 => 100755 src/CPUSensorMain.cpp
+
+diff --git a/src/CPUSensorMain.cpp b/src/CPUSensorMain.cpp
+old mode 100644
+new mode 100755
+index 2a3ff16..fcca8e9
+--- a/src/CPUSensorMain.cpp
++++ b/src/CPUSensorMain.cpp
+@@ -278,6 +278,12 @@ bool createSensors(boost::asio::io_service& io,
+ 
+             // check hidden properties
+             bool show = true;
++            auto findCore = label.find("Core");
++            if (findCore != std::string::npos)
++            {
++                show = false;
++            }
++
+             for (const char* prop : hiddenProps)
+             {
+                 if (label == prop)
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0017-Enabling-NVMe-sensor-support.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0017-Enabling-NVMe-sensor-support.patch
new file mode 100755
index 0000000..2e09735
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0017-Enabling-NVMe-sensor-support.patch
@@ -0,0 +1,545 @@
+From becf67540e738bc4bd3d86b4ee54c520ee88e2a0 Mon Sep 17 00:00:00 2001
+From: Mirage Su <mirage.su@mic.com.tw>
+Date: Tue, 19 Nov 2019 13:40:18 +0800
+Subject: [PATCH] Enabling NVMe sensor support
+
+---
+ CMakeLists.txt                                     |  17 +
+ include/NVMeSensor.hpp                             |  34 ++
+ .../xyz.openbmc_project.nvmesensor.service         |  12 +
+ src/NVMeSensor.cpp                                 | 419 +++++++++++++++++++++
+ 4 files changed, 482 insertions(+)
+ create mode 100755 include/NVMeSensor.hpp
+ create mode 100755 service_files/xyz.openbmc_project.nvmesensor.service
+ create mode 100755 src/NVMeSensor.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 714948d..89fb340 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -54,6 +54,7 @@ option (DISABLE_VERSION_CHANGE "Disable installing version change sensor" OFF)
+ option (DISABLE_POWER_STATUS "Disable installing power status sensor" OFF)
+ option (DISABLE_MGT_SUBSYS_HEALTH "Disable installing mgt subsys health sensor" OFF)
+ option (DISABLE_POWER_SUPPLY "Disable installing power supply sensor" OFF)
++option (DISABLE_NVME "Disable installing NVME sensor" OFF)
+ 
+ include ("cmake/HunterGate.cmake")
+ 
+@@ -85,6 +86,8 @@ set (MCUTEMP_SRC_FILES src/Utils.cpp src/Thresholds.cpp)
+ set (PSU_SRC_FILES src/Utils.cpp src/PSUSensor.cpp src/Thresholds.cpp
+      src/PwmSensor.cpp src/PSUEvent.cpp)
+ 
++set (NVME_SRC_FILES src/Utils.cpp src/Utils.cpp src/Thresholds.cpp)
++
+ set (EXTERNAL_PACKAGES Boost sdbusplus-project nlohmann-json)
+ set (SENSOR_LINK_LIBS -lsystemd stdc++fs sdbusplus)
+ 
+@@ -237,6 +240,13 @@ add_executable (psufaultsensor src/PsuFaultSensor.cpp)
+ add_dependencies (aclostsensor sdbusplus-project)
+ target_link_libraries (psufaultsensor ${SENSOR_LINK_LIBS})
+ 
++if (NOT DISABLE_NVME)
++    add_executable (nvmesensor src/NVMeSensor.cpp ${NVME_SRC_FILES})
++    add_dependencies (nvmesensor sdbusplus-project)
++    target_link_libraries (nvmesensor ${SENSOR_LINK_LIBS})
++    target_link_libraries (nvmesensor i2c)
++endif()
++
+ if (NOT YOCTO)
+     add_dependencies (adcsensor ${EXTERNAL_PACKAGES})
+     add_dependencies (cpusensor ${EXTERNAL_PACKAGES})
+@@ -395,3 +405,10 @@ if (NOT DISABLE_POWER_SUPPLY)
+                  ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.psufaultsensor.service
+                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+ endif ()
++
++if (NOT DISABLE_NVME)
++    install (TARGETS nvmesensor DESTINATION bin)
++    install (FILES
++                 ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.nvmesensor.service
++                 DESTINATION ${SERVICE_FILE_INSTALL_DIR})
++endif ()
+diff --git a/include/NVMeSensor.hpp b/include/NVMeSensor.hpp
+new file mode 100755
+index 0000000..fecb766
+--- /dev/null
++++ b/include/NVMeSensor.hpp
+@@ -0,0 +1,34 @@
++#pragma once
++#include "sensor.hpp"
++
++#include <boost/asio/deadline_timer.hpp>
++#include <boost/container/flat_map.hpp>
++#include <chrono>
++#include <limits>
++#include <memory>
++#include <string>
++#include <vector>
++
++struct NVMeSensor : public Sensor
++{
++    NVMeSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
++                  boost::asio::io_service& io, const std::string& name,
++                  const std::string& sensorConfiguration,
++                  sdbusplus::asio::object_server& objectServer,
++                  std::vector<thresholds::Threshold>&& thresholds,
++                  uint8_t busId, uint8_t address);
++    ~NVMeSensor();
++
++    void checkThresholds(void) override;
++    void read(void);
++    void init(void);
++
++    uint8_t busId;
++    uint8_t address;
++
++  private:
++    int getNVMeTemp(uint8_t* pu8data);
++    sdbusplus::asio::object_server& objectServer;
++    std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
++    boost::asio::deadline_timer waitTimer;
++};
+diff --git a/service_files/xyz.openbmc_project.nvmesensor.service b/service_files/xyz.openbmc_project.nvmesensor.service
+new file mode 100755
+index 0000000..a5c8725
+--- /dev/null
++++ b/service_files/xyz.openbmc_project.nvmesensor.service
+@@ -0,0 +1,12 @@
++[Unit]
++Description=NVMe Sensor
++StopWhenUnneeded=false
++After=xyz.openbmc_project.FruDevice.service
++
++[Service]
++Restart=always
++RestartSec=5
++ExecStart=/usr/bin/nvmesensor
++
++[Install]
++WantedBy=multi-user.target
+\ No newline at end of file
+diff --git a/src/NVMeSensor.cpp b/src/NVMeSensor.cpp
+new file mode 100755
+index 0000000..772698b
+--- /dev/null
++++ b/src/NVMeSensor.cpp
+@@ -0,0 +1,419 @@
++#include "NVMeSensor.hpp"
++
++#include "Utils.hpp"
++#include "VariantVisitors.hpp"
++
++#include <math.h>
++
++#include <boost/algorithm/string.hpp>
++#include <boost/algorithm/string/predicate.hpp>
++#include <boost/algorithm/string/replace.hpp>
++#include <boost/container/flat_map.hpp>
++#include <chrono>
++#include <functional>
++#include <iostream>
++#include <limits>
++#include <memory>
++#include <numeric>
++#include <sdbusplus/asio/connection.hpp>
++#include <sdbusplus/asio/object_server.hpp>
++#include <sdbusplus/bus/match.hpp>
++#include <string>
++#include <vector>
++
++extern "C" {
++#include <i2c/smbus.h>
++#include <linux/i2c-dev.h>
++}
++
++constexpr const bool debug = true;
++
++constexpr const char* configInterface =
++    "xyz.openbmc_project.Configuration.NVME1000";
++static constexpr double maxReading = 127;
++static constexpr double minReading = -128;
++
++
++boost::container::flat_map<std::string, std::unique_ptr<NVMeSensor>> sensors;
++
++NVMeSensor::NVMeSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
++                             boost::asio::io_service& io,
++                             const std::string& sensorName,
++                             const std::string& sensorConfiguration,
++                             sdbusplus::asio::object_server& objectServer,
++                             std::vector<thresholds::Threshold>&& thresholdData,
++                             uint8_t busId, uint8_t address) :
++    Sensor(boost::replace_all_copy(sensorName, " ", "_"),
++           std::move(thresholdData), sensorConfiguration,
++           "xyz.openbmc_project.Configuration.NVME1000", maxReading,
++           minReading),
++    busId(busId), address(address),
++    objectServer(objectServer), dbusConnection(conn), waitTimer(io)
++{
++    sensorInterface = objectServer.add_interface(
++        "/xyz/openbmc_project/sensors/temperature/" + name,
++        "xyz.openbmc_project.Sensor.Value");
++
++    if (thresholds::hasWarningInterface(thresholds))
++    {
++        thresholdInterfaceWarning = objectServer.add_interface(
++            "/xyz/openbmc_project/sensors/temperature/" + name,
++            "xyz.openbmc_project.Sensor.Threshold.Warning");
++    }
++    if (thresholds::hasCriticalInterface(thresholds))
++    {
++        thresholdInterfaceCritical = objectServer.add_interface(
++            "/xyz/openbmc_project/sensors/temperature/" + name,
++            "xyz.openbmc_project.Sensor.Threshold.Critical");
++    }
++    association = objectServer.add_interface(
++        "/xyz/openbmc_project/sensors/temperature/" + name,
++        "org.openbmc.Associations");  //association::interface);  //mirage: temporarily use old code
++}
++
++NVMeSensor::~NVMeSensor()
++{
++    waitTimer.cancel();
++    objectServer.remove_interface(thresholdInterfaceWarning);
++    objectServer.remove_interface(thresholdInterfaceCritical);
++    objectServer.remove_interface(sensorInterface);
++    objectServer.remove_interface(association);
++}
++
++void NVMeSensor::init(void)
++{
++    setInitialProperties(dbusConnection);
++    read();
++}
++
++void NVMeSensor::checkThresholds(void)
++{
++    thresholds::checkThresholds(this);
++}
++
++#define I2C_DATA_MAX 256
++
++static inline __u8 i2c_8bit_addr_from_msg(const struct i2c_msg* msg)
++{
++    return (msg->addr << 1) | (msg->flags & I2C_M_RD ? 1 : 0);
++}
++
++/* Since I2C_M_RD not implement PEC in the linux driver layer,
++   so copy some driver PEC check functions here */
++#define POLY (0x1070U << 3)
++static inline __u8 crc8(__u16 data)
++{
++    int i;
++
++    for (i = 0; i < 8; i++)
++    {
++        if (data & 0x8000)
++            data = data ^ POLY;
++        data = data << 1;
++    }
++    return (__u8)(data >> 8);
++}
++
++/* Incremental CRC8 over count bytes in the array pointed to by p */
++static inline __u8 i2c_smbus_pec(__u8 crc, __u8* p, size_t count)
++{
++    int i;
++
++    for (i = 0; i < (int)count; i++)
++        crc = crc8((crc ^ p[i]) << 8);
++    return crc;
++}
++
++/* Assume a 7-bit address, which is reasonable for SMBus */
++static inline __u8 i2c_smbus_msg_pec(__u8 pec, struct i2c_msg* msg)
++{
++    /* The address will be sent first */
++    __u8 addr = i2c_8bit_addr_from_msg(msg);
++    pec = i2c_smbus_pec(pec, &addr, 1);
++
++    /* The data buffer follows */
++    return i2c_smbus_pec(pec, (__u8*)msg->buf, msg->len);
++}
++
++/* Return <0 on CRC error
++   If there was a write before this read (most cases) we need to take the
++   partial CRC from the write part into account.
++   Note that this function does modify the message (we need to decrease the
++   message length to hide the CRC byte from the caller). */
++static inline int i2c_smbus_check_pec(__u8 cpec, struct i2c_msg* msg)
++{
++    __u8 rpec = msg->buf[--msg->len];
++    cpec = i2c_smbus_msg_pec(cpec, msg);
++    if (rpec != cpec)
++    {
++        printf("Error: Bad PEC 0x%02x vs. 0x%02x\n", rpec, cpec);
++        return -1;
++    }
++    return 0;
++}
++
++static inline __s32 i2c_read_after_write(int file, __u8 command,
++                                         __u8 slave_addr, __u8 tx_len,
++                                         const __u8* tx_buf, int rx_len,
++                                         const __u8* rx_buf)
++{
++    struct i2c_rdwr_ioctl_data msgst;
++    struct i2c_msg msg[2];
++    int ret;
++    int status;
++    __u8 partial_pec = 0;
++
++    msg[0].addr = slave_addr & 0xFF;
++    msg[0].flags = 0;
++    msg[0].buf = (unsigned char*)tx_buf;
++    msg[0].len = tx_len;
++
++    msg[1].addr = slave_addr & 0xFF;
++    msg[1].flags = I2C_M_RD | I2C_M_RECV_LEN;
++    msg[1].buf = (unsigned char*)rx_buf;
++    msg[1].len = rx_len;
++
++    msgst.msgs = msg;
++    msgst.nmsgs = 2;
++
++    ret = ioctl(file, I2C_RDWR, &msgst);
++    if (ret < 0)
++        return ret;
++    else if (command)
++    {
++        partial_pec = i2c_smbus_msg_pec(0, &msg[0]);
++        msg[1].len = rx_buf[0] + 1;
++        status = i2c_smbus_check_pec(partial_pec, &msg[1]);
++        return status;
++    }
++    return ret;
++}
++
++int NVMeSensor::getNVMeTemp(uint8_t* pu8data)
++{
++    int res, res_len;
++	unsigned char Rx_buf[I2C_DATA_MAX] = {0};
++	unsigned char tx_data = 0;	//command code
++    std::string i2cBus = "/dev/i2c-" + std::to_string(busId);
++    int fd = open(i2cBus.c_str(), O_RDWR);
++
++    if (fd < 0)
++    {
++        std::cerr << " unable to open i2c device" << i2cBus << "  err=" << fd
++                  << "\n";
++        return -1;
++    }
++
++    Rx_buf[0] = 1;
++    res = i2c_read_after_write(fd, 0, address, 1,
++                               &tx_data, I2C_DATA_MAX,
++                               (const unsigned char*)Rx_buf);
++
++    if (res < 0)
++    {
++        std::cerr << "Error: block write read failed\n";
++    }
++
++    res_len = Rx_buf[0] + 1;
++
++	if constexpr (debug)
++	{
++		std::cerr << "Block data read \n\t";
++		for (int i=0; i<32; i++)
++		{
++		    std::cerr << std::to_string(Rx_buf[i]) << "  ";
++		}
++	    std::cerr << "\n";
++	}
++
++    *pu8data = Rx_buf[3];
++    
++    close(fd);
++
++    if (*pu8data <= 0x7E)
++    {
++        return 0;
++    }
++	else if (*pu8data == 0x7F)
++	{
++        std::cerr << "Temperature is 127 or higher\n";
++        return -1;
++	}
++	else if (*pu8data == 0x80)
++	{
++        std::cerr << "No temperature data or temperature data is more than 5 seconds old\n";
++        return -1;
++	}
++	else if (*pu8data == 0x81)
++	{
++        std::cerr << "Temperature sensor failure\n";
++        return -1;
++	}
++	else if (*pu8data == 0xC4)
++	{
++        std::cerr << "Temperature is -60 or lower\n";
++        return -1;
++	}
++	else if (*pu8data >= 0xC5 && *pu8data <= 0xFF)
++	{
++        std::cerr << "Temperature measured in degrees Celsius is represented\n in twos complement(-1 to -59)\n";
++        return -1;
++	}
++	else
++	{
++		return -1;
++	}
++}
++
++void NVMeSensor::read(void)
++{
++    static constexpr size_t pollTime = 1; // in seconds
++
++    waitTimer.expires_from_now(boost::posix_time::seconds(pollTime));
++    waitTimer.async_wait([this](const boost::system::error_code& ec) {
++        if (ec == boost::asio::error::operation_aborted)
++        {
++            return; // we're being cancelled
++        }
++        // read timer error
++        else if (ec)
++        {
++            std::cerr << "timer error\n";
++            return;
++        }
++        uint8_t temp;
++        int ret = getNVMeTemp(&temp);
++        if (ret >= 0)
++        {
++            double v = static_cast<double>(temp);
++            if constexpr (debug)
++            {
++                std::cerr << "Value update to " << v << "\n";
++            }
++            updateValue(v);
++        }
++        else
++        {
++            std::cerr << "Invalid read getNVMeTemp\n";
++            updateValue(-1);
++        }
++        read();
++    });
++}
++
++void createSensors(
++    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
++    boost::container::flat_map<std::string, std::unique_ptr<NVMeSensor>>&
++        sensors,
++    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection)
++{
++    if (!dbusConnection)
++    {
++        std::cerr << "Connection not created\n";
++        return;
++    }
++
++    dbusConnection->async_method_call(
++        [&io, &objectServer, &dbusConnection, &sensors](
++            boost::system::error_code ec, const ManagedObjectType& resp) {
++            if (ec)
++            {
++                std::cerr << "Error contacting entity manager\n";
++                return;
++            }
++            for (const auto& pathPair : resp)
++            {
++                for (const auto& entry : pathPair.second)
++                {
++                    if (entry.first != configInterface)
++                    {
++                        continue;
++                    }
++                    std::string name =
++                        loadVariant<std::string>(entry.second, "Name");
++
++                    std::vector<thresholds::Threshold> sensorThresholds;
++                    if (!parseThresholdsFromConfig(pathPair.second,
++                                                   sensorThresholds))
++                    {
++                        std::cerr << "error populating thresholds for " << name
++                                  << "\n";
++                    }
++
++                    uint8_t busId = loadVariant<uint8_t>(entry.second, "Bus");
++
++                    uint8_t address =
++                        loadVariant<uint8_t>(entry.second, "Address");
++
++                    if constexpr (debug)
++                    {
++                        std::cerr
++                            << "Configuration parsed for \n\t" << entry.first
++                            << "\n"
++                            << "with\n"
++                            << "\tName: " << name << "\n"
++                            << "\tBus: " << static_cast<int>(busId) << "\n"
++                            << "\tAddress: " << static_cast<int>(address)
++                            << "\n";
++                    }
++
++                    auto& sensor = sensors[name];
++
++                    sensor = std::make_unique<NVMeSensor>(
++                        dbusConnection, io, name, pathPair.first, objectServer,
++                        std::move(sensorThresholds), busId, address);
++
++                    sensor->init();
++                }
++            }
++        },
++        entityManagerName, "/", "org.freedesktop.DBus.ObjectManager",
++        "GetManagedObjects");
++}
++
++int main()
++{
++    boost::asio::io_service io;
++    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
++    systemBus->request_name("xyz.openbmc_project.NVMeSensor");
++    sdbusplus::asio::object_server objectServer(systemBus);
++
++    io.post([&]() { createSensors(io, objectServer, sensors, systemBus); });
++
++    boost::asio::deadline_timer configTimer(io);
++
++    std::function<void(sdbusplus::message::message&)> eventHandler =
++        [&](sdbusplus::message::message&) {
++            configTimer.expires_from_now(boost::posix_time::seconds(1));
++            // create a timer because normally multiple properties change
++            configTimer.async_wait([&](const boost::system::error_code& ec) {
++                if (ec == boost::asio::error::operation_aborted)
++                {
++                    return; // we're being canceled
++                }
++                // config timer error
++                else if (ec)
++                {
++                    std::cerr << "timer error\n";
++                    return;
++                }
++                createSensors(io, objectServer, sensors, systemBus);
++                if (sensors.empty())
++                {
++                    std::cout << "Configuration not detected\n";
++                }
++            });
++        };
++
++    sdbusplus::bus::match::match configMatch(
++        static_cast<sdbusplus::bus::bus&>(*systemBus),
++        "type='signal',member='PropertiesChanged',"
++        "path_namespace='" +
++            std::string(inventoryPath) +
++            "',"
++            "arg0namespace='" +
++            configInterface + "'",
++        eventHandler);
++
++    io.run();
++}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0018-change-power-match-to-pgood-event.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0018-change-power-match-to-pgood-event.patch
new file mode 100755
index 0000000..023765e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0018-change-power-match-to-pgood-event.patch
@@ -0,0 +1,76 @@
+From 17b9cb6568a3ff62951304959c74e1b3ada406f5 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 11 Dec 2019 17:36:32 +0800
+Subject: [PATCH] change power match to pgood event
+
+---
+ include/Utils.hpp |  8 ++++----
+ src/Utils.cpp     | 12 +++++-------
+ 2 files changed, 9 insertions(+), 11 deletions(-)
+ mode change 100644 => 100755 include/Utils.hpp
+ mode change 100644 => 100755 src/Utils.cpp
+
+diff --git a/include/Utils.hpp b/include/Utils.hpp
+old mode 100644
+new mode 100755
+index 44e7e2e..1d436d6
+--- a/include/Utils.hpp
++++ b/include/Utils.hpp
+@@ -90,10 +90,10 @@ constexpr const char* get = "Get";
+ 
+ namespace power
+ {
+-const static constexpr char* busname = "xyz.openbmc_project.State.Host";
+-const static constexpr char* interface = "xyz.openbmc_project.State.Host";
+-const static constexpr char* path = "/xyz/openbmc_project/state/host0";
+-const static constexpr char* property = "CurrentHostState";
++const static constexpr char* busname = "org.openbmc.control.Power";
++const static constexpr char* interface = "org.openbmc.control.Power";
++const static constexpr char* path = "/org/openbmc/control/power0";
++const static constexpr char* property = "pgood";
+ } // namespace power
+ namespace post
+ {
+diff --git a/src/Utils.cpp b/src/Utils.cpp
+old mode 100644
+new mode 100755
+index 44a6bae..b172b69
+--- a/src/Utils.cpp
++++ b/src/Utils.cpp
+@@ -153,15 +153,14 @@ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
+             std::string(power::interface) + "'",
+         [](sdbusplus::message::message& message) {
+             std::string objectName;
+-            boost::container::flat_map<std::string, std::variant<std::string>>
++            boost::container::flat_map<std::string, std::variant<int>>
+                 values;
+             message.read(objectName, values);
+             auto findState = values.find(power::property);
+             if (findState != values.end())
+             {
+-                bool on = boost::ends_with(
+-                    std::get<std::string>(findState->second), "Running");
+-                if (!on)
++                int on = std::get<int>(findState->second);
++                if ( 1 != on)
+                 {
+                     timer.cancel();
+                     powerStatusOn = false;
+@@ -204,15 +203,14 @@ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
+ 
+     conn->async_method_call(
+         [](boost::system::error_code ec,
+-           const std::variant<std::string>& state) {
++           const std::variant<int>& state) {
+             if (ec)
+             {
+                 // we commonly come up before power control, we'll capture the
+                 // property change later
+                 return;
+             }
+-            powerStatusOn =
+-                boost::ends_with(std::get<std::string>(state), "Running");
++            powerStatusOn = (1 == (std::get<int>(state))) ? true : false;
+         },
+         power::busname, power::path, properties::interface, properties::get,
+         power::interface, power::property);
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0019-Modify-temp-and-Die-sensor-threshold-setting.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0019-Modify-temp-and-Die-sensor-threshold-setting.patch
new file mode 100755
index 0000000..ba4bc06
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0019-Modify-temp-and-Die-sensor-threshold-setting.patch
@@ -0,0 +1,119 @@
+From 6f40f2210ef2116fb3c28538cc4644896dbd73d0 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Wed, 18 Dec 2019 15:29:38 +0800
+Subject: [PATCH] Modify temp and Die sensor threshold setting
+
+---
+ src/CPUSensor.cpp     | 25 +++++--------------------
+ src/HwmonTempMain.cpp | 29 ++++++++++++++++++++++-------
+ 2 files changed, 27 insertions(+), 27 deletions(-)
+ mode change 100644 => 100755 src/CPUSensor.cpp
+
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+old mode 100644
+new mode 100755
+index 27c9c38..9c5c37e
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -137,26 +137,11 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+ 
+                 if (!thresholds.empty())
+                 {
+-                    std::vector<thresholds::Threshold> newThresholds;
+-                    if (parseThresholdsFromAttr(newThresholds, path,
+-                                                CPUSensor::sensorScaleFactor,
+-                                                dtsOffset))
+-                    {
+-                        if (!std::equal(thresholds.begin(), thresholds.end(),
+-                                        newThresholds.begin(),
+-                                        newThresholds.end()))
+-                        {
+-                            thresholds = newThresholds;
+-                            if (show)
+-                            {
+-                                thresholds::updateThresholds(this);
+-                            }
+-                        }
+-                    }
+-                    else
+-                    {
+-                        std::cerr << "Failure to update thresholds for " << name
+-                                  << "\n";
++
++                	if (show)
++                	{
++                		thresholds::updateThresholds(this);
++
+                     }
+                 }
+             }
+diff --git a/src/HwmonTempMain.cpp b/src/HwmonTempMain.cpp
+index 10c29f2..99fe199 100755
+--- a/src/HwmonTempMain.cpp
++++ b/src/HwmonTempMain.cpp
+@@ -197,13 +197,22 @@ void createSensors(
+                         continue;
+                     }
+                 }
+-                std::vector<thresholds::Threshold> sensorThresholds;
+-                if (!parseThresholdsFromConfig(*sensorData, sensorThresholds))
++                std::vector<thresholds::Threshold> sensorThresholds_temp1;
++				std::string label = "temp1";
++				if (!parseThresholdsFromConfig(*sensorData, sensorThresholds_temp1, &label))
+                 {
+                     std::cerr << "error populating thresholds for "
+                               << sensorName << "\n";
+                 }
+-                std::vector<thresholds::Threshold> t = sensorThresholds;
++				
++                std::vector<thresholds::Threshold> sensorThresholds_temp2;
++				label = "temp2";
++				if (!parseThresholdsFromConfig(*sensorData, sensorThresholds_temp2, &label))
++				{
++					std::cerr << "error populating thresholds for "
++                	              << sensorName << "\n";
++				}
++
+                 if (deviceName != "14-001f")
+                 {
+                     auto& sensor1 = sensors[sensorName];
+@@ -211,7 +220,7 @@ void createSensors(
+                     sensor1 = std::make_unique<HwmonTempSensor>(
+                         directory.string() + "/temp1_input", sensorType,
+                         objectServer, dbusConnection, io, sensorName,
+-                        std::move(sensorThresholds), *interfacePath);
++                        std::move(sensorThresholds_temp1), *interfacePath);
+                 }
+                 auto findSecondName = baseConfiguration->second.find("Name1");
+                 if (findSecondName == baseConfiguration->second.end())
+@@ -220,13 +229,19 @@ void createSensors(
+                 }
+                 sensorName = std::get<std::string>(findSecondName->second);
+                 
+-                std::vector<thresholds::Threshold> t1 = t;
++                std::vector<thresholds::Threshold> sensorThresholds_temp3;
++				label = "temp3";
++				if (!parseThresholdsFromConfig(*sensorData, sensorThresholds_temp3, &label))
++				{
++					std::cerr << "error populating thresholds for "
++                	              << sensorName << "\n";
++				}
+                 auto& sensor2 = sensors[sensorName];
+                 sensor2 = nullptr;
+                 sensor2 = std::make_unique<HwmonTempSensor>(
+                     directory.string() + "/temp2_input", sensorType,
+                     objectServer, dbusConnection, io, sensorName,
+-                    std::move(t), *interfacePath); 
++                    std::move(sensorThresholds_temp2), *interfacePath); 
+ 
+                 auto findThirddName = baseConfiguration->second.find("Name2"); 
+                 if (findThirddName == baseConfiguration->second.end())
+@@ -239,7 +254,7 @@ void createSensors(
+                 sensor3 = std::make_unique<HwmonTempSensor>(
+                     directory.string() + "/temp3_input", sensorType, 
+                     objectServer, dbusConnection, io, sensorName, 
+-                    std::move(t1), *interfacePath);
++                    std::move(sensorThresholds_temp3), *interfacePath);
+             }
+         }));
+     getter->getConfiguration(
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0020-Add-prochot-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0020-Add-prochot-sensor.patch
new file mode 100755
index 0000000..5fbded9
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0020-Add-prochot-sensor.patch
@@ -0,0 +1,37 @@
+From 22380e47cc86e08b0fe5d06b57a6b128d8f85dd8 Mon Sep 17 00:00:00 2001
+From: Varun Sampat <vsampat@twitter.com>
+Date: Wed, 18 Dec 2019 19:49:10 -0500
+Subject: [PATCH] Add prochot sensor
+
+---
+ src/ProcessorSensorMain.cpp | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+diff --git a/src/ProcessorSensorMain.cpp b/src/ProcessorSensorMain.cpp
+index 8e9986a..1e2ea28 100755
+--- a/src/ProcessorSensorMain.cpp
++++ b/src/ProcessorSensorMain.cpp
+@@ -73,11 +73,23 @@ int main()
+     std::shared_ptr<sdbusplus::asio::dbus_interface> iface =
+         objServer.add_interface("/xyz/openbmc_project/sensors/processor/CATERR",sensorValueInterface);
+ 
++    std::shared_ptr<sdbusplus::asio::dbus_interface> iface2 =
++        objServer.add_interface("/xyz/openbmc_project/sensors/processor/CPU0_State",sensorValueInterface);
++
++    std::shared_ptr<sdbusplus::asio::dbus_interface> iface3 =
++        objServer.add_interface("/xyz/openbmc_project/sensors/processor/CPU1_State",sensorValueInterface);
++
+     double value = 0;
+     //ray__ test value
+     iface->register_property("Value", value);
+     iface->initialize();
+     
++    iface2->register_property("Value", value);
++    iface2->initialize();
++
++    iface3->register_property("Value", value);
++    iface3->initialize();
++
+     auto caterrEventMatcherCallback =
+         [systemBus](sdbusplus::message::message& message) {
+             boost::container::flat_map<std::string, sdbusplus::message::variant<std::string>> propertiesChanged;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0021-Add-Invalid-Value-property-for-power-on-sensors.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0021-Add-Invalid-Value-property-for-power-on-sensors.patch
new file mode 100755
index 0000000..f4a24fe
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0021-Add-Invalid-Value-property-for-power-on-sensors.patch
@@ -0,0 +1,91 @@
+From c311a8bb311dee7b403a4e3e1cabb50c1692d913 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 15:42:26 +0800
+Subject: [PATCH 1/1] Add-Invalid-Value-property-for-power-on-sensors
+
+---
+ include/sensor.hpp | 25 +++++++++++++++++++++++--
+ src/PwmSensor.cpp  |  1 +
+ 2 files changed, 24 insertions(+), 2 deletions(-)
+ mode change 100644 => 100755 include/sensor.hpp
+ mode change 100644 => 100755 src/PwmSensor.cpp
+
+diff --git a/include/sensor.hpp b/include/sensor.hpp
+old mode 100644
+new mode 100755
+index e298677..2a2be54
+--- a/include/sensor.hpp
++++ b/include/sensor.hpp
+@@ -37,6 +37,7 @@ struct Sensor
+     std::shared_ptr<sdbusplus::asio::dbus_interface> thresholdInterfaceCritical;
+     std::shared_ptr<sdbusplus::asio::dbus_interface> association;
+     double value = std::numeric_limits<double>::quiet_NaN();
++    bool invalidValue = false;
+     bool overriddenState = false;
+     bool internalSet = false;
+     double hysteresisTrigger;
+@@ -59,6 +60,13 @@ struct Sensor
+         return 1;
+     }
+ 
++    int setSensorValueInvalid(const bool& newState, bool& oldState)
++    {
++        oldState = newState;
++        invalidValue = newState;
++        return 1;
++    }
++
+     void
+         setInitialProperties(std::shared_ptr<sdbusplus::asio::connection>& conn)
+     {
+@@ -70,6 +78,12 @@ struct Sensor
+             "Value", value, [&](const double& newValue, double& oldValue) {
+                 return setSensorValue(newValue, oldValue);
+             });
++
++        sensorInterface->register_property(
++            "InvalidValue", invalidValue, [&](const bool& newState, bool& oldState) {
++                return setSensorValueInvalid(newState, oldState);
++            });
++
+         for (auto& threshold : thresholds)
+         {
+             std::shared_ptr<sdbusplus::asio::dbus_interface> iface;
+@@ -199,7 +213,7 @@ struct Sensor
+             std::cerr << "error setting property to " << newValue << "\n";
+         }
+         internalSet = false;
+-
++        value = newValue;
+         // Always check thresholds after changing the value,
+         // as the test against hysteresisTrigger now takes place in
+         // the thresholds::checkThresholds() method,
+@@ -207,4 +221,11 @@ struct Sensor
+         // in all current implementations of sensors that have thresholds.
+         checkThresholds();
+     }
++    void updateValueInvalid(const bool& newState)
++    {
++        if(newState != invalidValue)
++        {
++            sensorInterface->set_property("InvalidValue", newState);
++        }
++    }
+ };
+diff --git a/src/PwmSensor.cpp b/src/PwmSensor.cpp
+old mode 100644
+new mode 100755
+index eee29ef..7710f51
+--- a/src/PwmSensor.cpp
++++ b/src/PwmSensor.cpp
+@@ -81,6 +81,7 @@ PwmSensor::PwmSensor(const std::string& name, const std::string& sysPath,
+     // pwm sensor interface is in percent
+     sensorInterface->register_property("MaxValue", static_cast<int64_t>(100));
+     sensorInterface->register_property("MinValue", static_cast<int64_t>(0));
++    sensorInterface->register_property("InvalidValue", static_cast<bool>(false));
+ 
+     controlInterface = objectServer.add_interface(
+         "/xyz/openbmc_project/control/fanpwm/" + name,
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0022-Add-type-sensors-to-support-the-invalid-value-proper.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0022-Add-type-sensors-to-support-the-invalid-value-proper.patch
new file mode 100755
index 0000000..c139aac
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0022-Add-type-sensors-to-support-the-invalid-value-proper.patch
@@ -0,0 +1,663 @@
+From 347a207972586b9b1540d815ac6cdded7a645b90 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 15:30:29 +0800
+Subject: [PATCH 1/1] Add-type-sensors-to-support-the-invalid-value-property
+
+---
+ CMakeLists.txt        |  5 ++++
+ include/CPUSensor.hpp |  6 ++--
+ include/PSUSensor.hpp |  5 +++-
+ src/ADCSensor.cpp     | 50 ++++++++++++++++++++++++++++++---
+ src/CPUSensor.cpp     | 45 +++++++++++++++++++++++++++++-
+ src/CPUSensorMain.cpp | 36 +++++++++++++++++++++++-
+ src/IpmbSensor.cpp    |  4 +++
+ src/PSUSensor.cpp     | 65 +++++++++++++++++++++++++++++++++++++++++--
+ src/PSUSensorMain.cpp | 58 +++++++++++++++++++++++++++++++++++++-
+ src/TachSensor.cpp    | 40 ++++++++++++++++++++++++--
+ 10 files changed, 298 insertions(+), 16 deletions(-)
+ mode change 100644 => 100755 include/CPUSensor.hpp
+ mode change 100644 => 100755 include/PSUSensor.hpp
+ mode change 100644 => 100755 src/ADCSensor.cpp
+ mode change 100644 => 100755 src/PSUSensor.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index e81611b..094822c 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -50,6 +50,7 @@ option (DISABLE_NVME "Disable installing NVME sensor" ON)
+ option (DISABLE_PROCESSOR "Disable installing processor sensor" OFF)
+ option (DISABLE_ACPI "Disable installing acpi sensor" OFF)
+ option (DISABLE_POWER_STATUS "Disable installing power status sensor" OFF)
++option (BMC_CPU_SENSOR_TCONTROL "Enable Tcontrol Threshold setting" ON)
+ 
+ include ("cmake/HunterGate.cmake")
+ 
+@@ -165,6 +166,10 @@ add_executable (cpusensor src/CPUSensorMain.cpp ${CPU_SRC_FILES})
+ add_dependencies (cpusensor sdbusplus-project)
+ target_link_libraries (cpusensor ${SENSOR_LINK_LIBS})
+ target_link_libraries (cpusensor gpiodcxx)
++target_compile_definitions (
++    cpusensor PRIVATE
++    $<$<BOOL:${BMC_CPU_SENSOR_TCONTROL}>: -DBMC_CPU_SENSOR_TCONTROL>
++)
+ 
+ add_executable (exitairtempsensor src/ExitAirTempSensor.cpp
+                 ${EXIT_AIR_SRC_FILES})
+diff --git a/include/CPUSensor.hpp b/include/CPUSensor.hpp
+old mode 100644
+new mode 100755
+index 8f9cb6e..1f05d2d
+--- a/include/CPUSensor.hpp
++++ b/include/CPUSensor.hpp
+@@ -24,13 +24,13 @@ class CPUSensor : public Sensor
+               boost::asio::io_service& io, const std::string& sensorName,
+               std::vector<thresholds::Threshold>&& thresholds,
+               const std::string& configuration, int cpuId, bool show,
+-              double dtsOffset);
++              double dtsOffset, double maxReading, double minReading);
+     ~CPUSensor();
+     static constexpr unsigned int sensorScaleFactor = 1000;
+     static constexpr unsigned int sensorPollMs = 1000;
+     static constexpr size_t warnAfterErrorCount = 10;
+-    static constexpr double maxReading = 127;
+-    static constexpr double minReading = -128;
++    //static constexpr double maxReading = 127;
++    //static constexpr double minReading = -128;
+     static constexpr const char* labelTcontrol = "Tcontrol";
+ 
+   private:
+diff --git a/include/PSUSensor.hpp b/include/PSUSensor.hpp
+old mode 100644
+new mode 100755
+index 14b6d96..ec59acd
+--- a/include/PSUSensor.hpp
++++ b/include/PSUSensor.hpp
+@@ -18,7 +18,7 @@ class PSUSensor : public Sensor
+               std::vector<thresholds::Threshold>&& thresholds,
+               const std::string& sensorConfiguration,
+               std::string& sensorTypeName, unsigned int factor, double max,
+-              double min);
++              double min, PowerState readState);
+     ~PSUSensor();
+ 
+   private:
+@@ -36,6 +36,9 @@ class PSUSensor : public Sensor
+     int fd;
+     static constexpr unsigned int sensorPollMs = 1000;
+     static constexpr size_t warnAfterErrorCount = 10;
++    // Power-on sensor
++    PowerState readState;
++    thresholds::ThresholdTimer thresholdTimer;
+ };
+ 
+ class PSUProperty
+diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
+old mode 100644
+new mode 100755
+index 5e01503..df7ca52
+--- a/src/ADCSensor.cpp
++++ b/src/ADCSensor.cpp
+@@ -77,10 +77,10 @@ ADCSensor::ADCSensor(const std::string& path,
+     association = objectServer.add_interface(
+         "/xyz/openbmc_project/sensors/voltage/" + name, association::interface);
+     setInitialProperties(conn);
+-    setupRead();
+ 
+     // setup match
+     setupPowerMatch(conn);
++    setupRead();
+ }
+ 
+ ADCSensor::~ADCSensor()
+@@ -129,8 +129,41 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
+ {
+     if (err == boost::system::errc::bad_file_descriptor)
+     {
++        updateValueInvalid(true);
+         return; // we're being destroyed
+     }
++
++    // Set as sensor reading invalid for power-on type sensor
++    if (readState != PowerState::always && !isPowerOn())
++    {
++        updateValueInvalid(true);
++        // updateValue(0);
++        errCount = 0;
++
++        // clear response buffer reading
++        std::istream invalidResponseStream(&readBuf);
++        std::string invalidResponse;
++        std::getline(invalidResponseStream, invalidResponse);
++        invalidResponseStream.clear();
++
++        inputDev.close();
++        int fd = open(path.c_str(), O_RDONLY);
++        if (fd <= 0)
++        {
++            return;
++        }
++        inputDev.assign(fd);
++        waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++        waitTimer.async_wait([&](const boost::system::error_code& ec) {
++            if (ec == boost::asio::error::operation_aborted)
++            {
++                return;
++            }
++            setupRead();
++        });
++        return;
++    }
++
+     std::istream responseStream(&readBuf);
+ 
+     if (!err)
+@@ -151,6 +184,7 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
+                 updateValue(nvalue);
+             }
+             errCount = 0;
++            updateValueInvalid(false);
+         }
+         catch (std::invalid_argument&)
+         {
+@@ -175,7 +209,8 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
+ 
+     if (errCount >= warnAfterErrorCount)
+     {
+-        updateValue(0);
++        updateValueInvalid(true);
++        //updateValue(0);
+     }
+ 
+     responseStream.clear();
+@@ -202,10 +237,17 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
+ 
+ void ADCSensor::checkThresholds(void)
+ {
+-    if (readState == PowerState::on && !isPowerOn())
++    if (readState != PowerState::always && !isPowerOn())
+     {
+         return;
+     }
+ 
+-    thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
++    if(readState == PowerState::always)
++    {
++        thresholds::checkThresholds(this);
++    }
++    else
++    {
++        thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
++    }
+ }
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+index 27c9c38..8a9942f 100644
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -39,7 +39,8 @@ CPUSensor::CPUSensor(const std::string& path, const std::string& objectType,
+                      boost::asio::io_service& io, const std::string& sensorName,
+                      std::vector<thresholds::Threshold>&& _thresholds,
+                      const std::string& sensorConfiguration, int cpuId,
+-                     bool show, double dtsOffset) :
++                     bool show, double dtsOffset, double maxReading,
++                     double minReading) :
+     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
+            std::move(_thresholds), sensorConfiguration, objectType, maxReading,
+            minReading),
+@@ -104,9 +105,42 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+ {
+     if (err == boost::system::errc::bad_file_descriptor)
+     {
++        updateValueInvalid(true);
+         return; // we're being destroyed
+     }
+     size_t pollTime = CPUSensor::sensorPollMs;
++
++    // Set as sensor reading invalid for cup peci sensors
++    if (!isPowerOn())
++    {
++        updateValueInvalid(true);
++        errCount = 0;
++
++        // clear response buffer reading
++        std::istream invalidResponseStream(&readBuf);
++        std::string invalidResponse;
++        std::getline(invalidResponseStream, invalidResponse);
++        invalidResponseStream.clear();
++
++        inputDev.close();
++        int fd = open(path.c_str(), O_RDONLY);
++        if (fd <= 0)
++        {
++            return; // we're no longer valid
++        }
++        inputDev.assign(fd);
++        waitTimer.expires_from_now(boost::posix_time::milliseconds(pollTime));
++        waitTimer.async_wait([&](const boost::system::error_code& ec) {
++        if (ec == boost::asio::error::operation_aborted)
++        {
++            return; // we're being canceled
++        }
++            setupRead();
++        });
++
++        return;
++    }
++
+     std::istream responseStream(&readBuf);
+     if (!err)
+     {
+@@ -128,6 +162,10 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+                     value = nvalue;
+                 }
+             }
++
++            updateValueInvalid(false);
++
++#ifdef BMC_CPU_SENSOR_TCONTROL
+             double gTcontrol = gCpuSensors[nameTcontrol]
+                                    ? gCpuSensors[nameTcontrol]->value
+                                    : std::numeric_limits<double>::quiet_NaN();
+@@ -160,6 +198,8 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+                     }
+                 }
+             }
++#endif
++
+             errCount = 0;
+         }
+         catch (const std::invalid_argument&)
+@@ -175,6 +215,9 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+ 
+     if (errCount >= warnAfterErrorCount)
+     {
++        // Set the sensor reading invalid
++        updateValueInvalid(true);
++
+         // only an error if power is on
+         if (isPowerOn())
+         {
+diff --git a/src/CPUSensorMain.cpp b/src/CPUSensorMain.cpp
+index 6ed1627..7e198a1 100755
+--- a/src/CPUSensorMain.cpp
++++ b/src/CPUSensorMain.cpp
+@@ -52,6 +52,9 @@
+ 
+ static constexpr bool DEBUG = false;
+ 
++static constexpr double maxReading = 127;
++static constexpr double minReading = -128;
++
+ boost::container::flat_map<std::string, std::unique_ptr<CPUSensor>> gCpuSensors;
+ boost::container::flat_map<std::string,
+                            std::shared_ptr<sdbusplus::asio::dbus_interface>>
+@@ -289,8 +292,39 @@ bool createSensors(boost::asio::io_service& io,
+             std::getline(labelFile, label);
+             labelFile.close();
+ 
++            double maxValue = maxReading; // Initial value if we don't set value in json.
++            double minValue = minReading; // Initial value if we don't set value in json.
++            auto limits = std::make_pair(maxReading, minReading);
++
++            findLimits(limits, baseConfiguration);
++
+             std::string sensorName = label + " CPU" + std::to_string(cpuId);
+ 
++            label = boost::replace_all_copy(label, " ", "_");
++
++            bool isLabelsError = false; // Check the label format is correct or not.
++            for (const auto& item : *sensorData)
++            {
++                if (item.first.find("Labels") == std::string::npos)
++                {
++                    continue;
++                }
++                auto nameFind = item.second.find(label);
++                if (nameFind != item.second.end())
++                {
++                    sensorName = std::visit(VariantToStringVisitor(), nameFind->second);
++                }
++                else
++                {
++                    isLabelsError = true;
++                }
++            }
++
++            if (isLabelsError)
++            {
++                continue;
++            }
++
+             auto findSensor = gCpuSensors.find(sensorName);
+             if (findSensor != gCpuSensors.end())
+             {
+@@ -355,7 +389,7 @@ bool createSensors(boost::asio::io_service& io,
+             sensorPtr = std::make_unique<CPUSensor>(
+                 inputPathStr, sensorType, objectServer, dbusConnection, io,
+                 sensorName, std::move(sensorThresholds), *interfacePath, cpuId,
+-                show, dtsOffset);
++                show, dtsOffset, limits.first, limits.second);
+             createdSensors.insert(sensorName);
+             if (DEBUG)
+             {
+diff --git a/src/IpmbSensor.cpp b/src/IpmbSensor.cpp
+index 9f591ac..11aac0c 100644
+--- a/src/IpmbSensor.cpp
++++ b/src/IpmbSensor.cpp
+@@ -248,6 +248,7 @@ void IpmbSensor::read(void)
+         }
+         if (!isPowerOn() && readState != PowerState::always)
+         {
++            updateValueInvalid(true);
+             updateValue(0);
+             read();
+             return;
+@@ -259,12 +260,14 @@ void IpmbSensor::read(void)
+                 if (ec || status)
+                 {
+                     processError();
++                    updateValueInvalid(true);
+                     updateValue(0);
+                     read();
+                     return;
+                 }
+                 if (!isPowerOn() && readState != PowerState::always)
+                 {
++                    updateValueInvalid(true);
+                     updateValue(0);
+                     read();
+                     return;
+@@ -341,6 +344,7 @@ void IpmbSensor::read(void)
+                 /* Adjust value as per scale and offset */
+                 value = (value * scaleVal) + offsetVal;
+                 updateValue(value);
++                updateValueInvalid(false);
+                 read();
+                 errorCount = 0; // success
+             },
+diff --git a/src/PSUSensor.cpp b/src/PSUSensor.cpp
+old mode 100644
+new mode 100755
+index e94d1c4..18ce06a
+--- a/src/PSUSensor.cpp
++++ b/src/PSUSensor.cpp
+@@ -41,13 +41,13 @@ PSUSensor::PSUSensor(const std::string& path, const std::string& objectType,
+                      std::vector<thresholds::Threshold>&& _thresholds,
+                      const std::string& sensorConfiguration,
+                      std::string& sensorTypeName, unsigned int factor,
+-                     double max, double min) :
++                     double max, double min, PowerState readState) :
+     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
+            std::move(_thresholds), sensorConfiguration, objectType, max, min),
+     objServer(objectServer), inputDev(io), waitTimer(io), path(path),
+     errCount(0),
+ 
+-    sensorFactor(factor)
++    sensorFactor(factor), readState(std::move(readState)), thresholdTimer(io, this)
+ {
+     if constexpr (DEBUG)
+     {
+@@ -90,6 +90,7 @@ PSUSensor::PSUSensor(const std::string& path, const std::string& objectType,
+     association = objectServer.add_interface(dbusPath, association::interface);
+ 
+     createInventoryAssoc(conn, association, configurationPath);
++    setupPowerMatch(conn);
+     setupRead();
+ }
+ 
+@@ -105,10 +106,17 @@ PSUSensor::~PSUSensor()
+ 
+ void PSUSensor::setupRead(void)
+ {
++    #if 0
+     boost::asio::async_read_until(
+         inputDev, readBuf, '\n',
+         [&](const boost::system::error_code& ec,
+             std::size_t /*bytes_transfered*/) { handleResponse(ec); });
++    #endif
++
++    // Sync read to PSU sensor
++    boost::system::error_code ec;
++    boost::asio::read_until(inputDev, readBuf, '\n', ec);
++    handleResponse(ec);
+ }
+ 
+ void PSUSensor::handleResponse(const boost::system::error_code& err)
+@@ -116,6 +124,40 @@ void PSUSensor::handleResponse(const boost::system::error_code& err)
+     if (err == boost::system::errc::bad_file_descriptor)
+     {
+         std::cerr << "Bad file descriptor from " << path << "\n";
++        updateValueInvalid(true);
++        // updateValue(0);
++        return;
++    }
++
++    // Set as sensor reading invalid for power-on type sensor
++    if (readState != PowerState::always && !isPowerOn())
++    {
++        updateValueInvalid(true);
++        // updateValue(0);
++        errCount = 0;
++
++        // clear response buffer reading
++        std::istream invalidResponseStream(&readBuf);
++        std::string invalidResponse;
++        std::getline(invalidResponseStream, invalidResponse);
++        invalidResponseStream.clear();
++
++        inputDev.close();
++        int fd = open(path.c_str(), O_RDONLY);
++        if (fd <= 0)
++        {
++            return;
++        }
++        inputDev.assign(fd);
++        waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++        waitTimer.async_wait([&](const boost::system::error_code& ec) {
++            if (ec == boost::asio::error::operation_aborted)
++            {
++                return;
++            }
++            setupRead();
++        });
++
+         return;
+     }
+     std::istream responseStream(&readBuf);
+@@ -141,14 +183,19 @@ void PSUSensor::handleResponse(const boost::system::error_code& err)
+                     std::cerr << "Update " << path << " from " << value
+                               << " to " << nvalue << "\n";
+                 }
++
+                 updateValue(nvalue);
+             }
++
++            updateValueInvalid(false);
+             errCount = 0;
+         }
+         catch (const std::invalid_argument&)
+         {
+             std::cerr << "Could not parse " << response << " from path " << path
+                       << "\n";
++            updateValueInvalid(true);
++            // updateValue(0);
+             errCount++;
+         }
+     }
+@@ -183,5 +230,17 @@ void PSUSensor::handleResponse(const boost::system::error_code& err)
+ 
+ void PSUSensor::checkThresholds(void)
+ {
+-    thresholds::checkThresholds(this);
++    if (readState != PowerState::always && !isPowerOn())
++    {
++        return;
++    }
++
++    if(readState == PowerState::always)
++    {
++        thresholds::checkThresholds(this);
++    }
++    else
++    {
++        thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
++    }
+ }
+diff --git a/src/PSUSensorMain.cpp b/src/PSUSensorMain.cpp
+index d5d5937..6b1ae3a 100755
+--- a/src/PSUSensorMain.cpp
++++ b/src/PSUSensorMain.cpp
+@@ -207,6 +207,52 @@ static void
+     }
+ }
+ 
++static bool checkPowerState(const SensorData& sensorData,
++                            PowerState& sensorReadState,
++                            const std::string* matchLabel)
++{
++    sensorReadState = PowerState::always;
++
++    if (matchLabel == nullptr)
++    {
++        return false;
++    }
++
++    for (const auto& item : sensorData)
++    {
++        if (item.first.find("PowerStates") == std::string::npos)
++        {
++            continue;
++        }
++
++        auto labelFind = item.second.find("Label");
++        if (labelFind == item.second.end())
++        {
++            continue;
++        }
++        if (std::visit(VariantToStringVisitor(), labelFind->second) !=
++            *matchLabel)
++        {
++            continue;
++        }
++
++        auto findPowerState = item.second.find("PowerState");
++        if (findPowerState == item.second.end())
++        {
++            std::cerr << "failed to find PowerState in configuration\n";
++            return false;
++        }
++
++        std::string powerState = std::visit(
++                            VariantToStringVisitor(), findPowerState->second);
++        setReadState(powerState, sensorReadState);
++
++        break;
++    }
++
++    return true;
++}
++
+ void createSensors(boost::asio::io_service& io,
+                    sdbusplus::asio::object_server& objectServer,
+                    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection)
+@@ -720,11 +766,21 @@ void createSensors(boost::asio::io_service& io,
+                           << "\"\n";
+             }
+ 
++            /* Parse the sensor reading power state from the config file.
++                States: Always / On / BiosPost
++            */
++            PowerState sensorReadState;
++            if (!checkPowerState(*sensorData, sensorReadState, &labelHead))
++            {
++                std::cerr << "failed to find the sensor read power state for "
++                        << sensorNameSubStr << "\n";
++            }
++
+             sensors[sensorName] = std::make_unique<PSUSensor>(
+                 sensorPathStr, sensorType, objectServer, dbusConnection, io,
+                 sensorName, std::move(sensorThresholds), *interfacePath,
+                 findSensorType->second, factor, psuProperty->maxReading,
+-                psuProperty->minReading);
++                psuProperty->minReading, sensorReadState);
+ 
+             ++numCreated;
+             if constexpr (DEBUG)
+diff --git a/src/TachSensor.cpp b/src/TachSensor.cpp
+index 3e08160..2cdbff3 100755
+--- a/src/TachSensor.cpp
++++ b/src/TachSensor.cpp
+@@ -124,10 +124,43 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
+ {
+     if (err == boost::system::errc::bad_file_descriptor)
+     {
++        updateValueInvalid(true);
+         return; // we're being destroyed
+     }
+     bool missing = false;
+     size_t pollTime = pwmPollMs;
++
++    // Host power is off
++    if (!isPowerOn())
++    {
++        updateValueInvalid(true);
++        // updateValue(0);
++        errCount = 0;
++
++        // clear response buffer reading
++        std::istream invalidResponseStream(&readBuf);
++        std::string invalidResponse;
++        std::getline(invalidResponseStream, invalidResponse);
++        invalidResponseStream.clear();
++
++        inputDev.close();
++        int fd = open(path.c_str(), O_RDONLY);
++        if (fd <= 0)
++        {
++            return;
++        }
++        inputDev.assign(fd);
++        waitTimer.expires_from_now(boost::posix_time::milliseconds(pollTime));
++        waitTimer.async_wait([&](const boost::system::error_code& ec) {
++            if (ec == boost::asio::error::operation_aborted)
++            {
++                return;
++            }
++            setupRead();
++        });
++        return;
++    }
++
+     if (presence)
+     {
+         if (!presence->getValue())
+@@ -154,6 +187,7 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
+                     updateValue(nvalue);
+                 }
+                 errCount = 0;
++                updateValueInvalid(false);
+             }
+             catch (const std::invalid_argument&)
+             {
+@@ -165,7 +199,8 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
+             if (!isPowerOn())
+             {
+                 errCount = 0;
+-                updateValue(std::numeric_limits<double>::quiet_NaN());
++                // updateValue(std::numeric_limits<double>::quiet_NaN());
++                updateValueInvalid(true);
+             }
+             else
+             {
+@@ -181,7 +216,8 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
+                 std::cerr << "Failure to read sensor " << name << " at " << path
+                           << " ec:" << err << "\n";
+             }
+-            updateValue(0);
++            // updateValue(0);
++            updateValueInvalid(true);
+         }
+     }
+     responseStream.clear();
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0023-Add-thermtrip-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0023-Add-thermtrip-sensor.patch
new file mode 100755
index 0000000..5568230
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0023-Add-thermtrip-sensor.patch
@@ -0,0 +1,33 @@
+From 4908881c373dded750c8a1d681efa4e7e53aa819 Mon Sep 17 00:00:00 2001
+From: Varun Sampat <vsampat@twitter.com>
+Date: Thu, 2 Jan 2020 16:42:59 -0500
+Subject: [PATCH] Add thermtrip sensor
+
+---
+ src/ProcessorSensorMain.cpp | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/src/ProcessorSensorMain.cpp b/src/ProcessorSensorMain.cpp
+index 1e2ea28..da9d50b 100755
+--- a/src/ProcessorSensorMain.cpp
++++ b/src/ProcessorSensorMain.cpp
+@@ -79,6 +79,9 @@ int main()
+     std::shared_ptr<sdbusplus::asio::dbus_interface> iface3 =
+         objServer.add_interface("/xyz/openbmc_project/sensors/processor/CPU1_State",sensorValueInterface);
+ 
++    std::shared_ptr<sdbusplus::asio::dbus_interface> iface4 =
++        objServer.add_interface("/xyz/openbmc_project/sensors/processor/CPU_State",sensorValueInterface);
++
+     double value = 0;
+     //ray__ test value
+     iface->register_property("Value", value);
+@@ -90,6 +93,9 @@ int main()
+     iface3->register_property("Value", value);
+     iface3->initialize();
+ 
++    iface4->register_property("Value", value);
++    iface4->initialize();
++
+     auto caterrEventMatcherCallback =
+         [systemBus](sdbusplus::message::message& message) {
+             boost::container::flat_map<std::string, sdbusplus::message::variant<std::string>> propertiesChanged;
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0024-disable-PSU-PWM-detecting.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0024-disable-PSU-PWM-detecting.patch
new file mode 100755
index 0000000..b4f82db
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0024-disable-PSU-PWM-detecting.patch
@@ -0,0 +1,29 @@
+From 235616efc94e2b3fb6990413b432f10797960694 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 16:01:55 +0800
+Subject: [PATCH 1/1] disable PSU PWM detecting
+
+---
+ src/PSUSensorMain.cpp | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/src/PSUSensorMain.cpp b/src/PSUSensorMain.cpp
+index 6b1ae3a..abb4df3 100755
+--- a/src/PSUSensorMain.cpp
++++ b/src/PSUSensorMain.cpp
+@@ -515,10 +515,10 @@ void createSensors(boost::asio::io_service& io,
+                 std::cerr << "Sensor type=\"" << sensorNameSubStr
+                           << "\" label=\"" << labelHead << "\"\n";
+             }
+-
++#if 0
+             checkPWMSensor(sensorPath, labelHead, *interfacePath,
+                            dbusConnection, objectServer, psuNames[0]);
+-
++#endif
+             if (!findLabels.empty())
+             {
+                 /* Check if this labelHead is enabled in config file */
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0025-Add-VR-MOS-Margin-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0025-Add-VR-MOS-Margin-sensor.patch
new file mode 100755
index 0000000..b6684a4
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0025-Add-VR-MOS-Margin-sensor.patch
@@ -0,0 +1,485 @@
+From 153bae78ec47f0523df563766a29be58fdab3a8d Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 16:18:38 +0800
+Subject: [PATCH 1/1] Add-VR-MOS-Margin-sensor
+
+---
+ CMakeLists.txt                                |  15 +
+ include/CPUSensor.hpp                         |   1 +
+ include/MOSTempSensor.hpp                     |  33 ++
+ .../xyz.openbmc_project.mostempsensor.service |  11 +
+ src/CPUSensor.cpp                             |  15 +
+ src/CPUSensorMain.cpp                         |   4 +-
+ src/MOSTempSensor.cpp                         | 297 ++++++++++++++++++
+ 7 files changed, 374 insertions(+), 2 deletions(-)
+ create mode 100755 include/MOSTempSensor.hpp
+ create mode 100755 service_files/xyz.openbmc_project.mostempsensor.service
+ create mode 100755 src/MOSTempSensor.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 094822c..4f48e56 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -51,6 +51,7 @@ option (DISABLE_PROCESSOR "Disable installing processor sensor" OFF)
+ option (DISABLE_ACPI "Disable installing acpi sensor" OFF)
+ option (DISABLE_POWER_STATUS "Disable installing power status sensor" OFF)
+ option (BMC_CPU_SENSOR_TCONTROL "Enable Tcontrol Threshold setting" ON)
++option (DISABLE_MOSTEMP "Disable installing MOS temperature sensor" OFF)
+ 
+ include ("cmake/HunterGate.cmake")
+ 
+@@ -82,6 +83,8 @@ set (PSU_SRC_FILES src/Utils.cpp src/PSUSensor.cpp src/Thresholds.cpp
+ 
+ set (NVME_SRC_FILES src/Utils.cpp src/NVMeSensorMain.cpp src/NVMeSensor.cpp src/Thresholds.cpp)
+ 
++set (MOSTEMP_SRC_FILES src/Utils.cpp src/Thresholds.cpp)
++
+ set (EXTERNAL_PACKAGES Boost sdbusplus-project nlohmann-json)
+ set (SENSOR_LINK_LIBS -lsystemd stdc++fs sdbusplus)
+ 
+@@ -221,6 +224,11 @@ add_executable (aclostsensor src/AcLostSensor.cpp)
+ add_dependencies (aclostsensor sdbusplus-project)
+ target_link_libraries (aclostsensor ${SENSOR_LINK_LIBS})
+ 
++add_executable (mostempsensor src/MOSTempSensor.cpp ${MCUTEMP_SRC_FILES})
++add_dependencies (mostempsensor sdbusplus-project)
++target_link_libraries (mostempsensor ${SENSOR_LINK_LIBS})
++target_link_libraries (mostempsensor i2c)
++
+ if (NOT DISABLE_NVME)
+     add_executable (nvmesensor ${NVME_SRC_FILES})
+     add_dependencies (nvmesensor sdbusplus-project)
+@@ -345,4 +353,11 @@ if (NOT DISABLE_POWER_STATUS)
+                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+ endif ()
+ 
++if (NOT DISABLE_MOSTEMP)
++    install (TARGETS mostempsensor DESTINATION bin)
++    install (
++        FILES ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.mostempsensor.service
++              DESTINATION ${SERVICE_FILE_INSTALL_DIR}
++    )
++endif ()
+ 
+diff --git a/include/CPUSensor.hpp b/include/CPUSensor.hpp
+index 1f05d2d..18312ee 100755
+--- a/include/CPUSensor.hpp
++++ b/include/CPUSensor.hpp
+@@ -31,6 +31,7 @@ class CPUSensor : public Sensor
+     static constexpr size_t warnAfterErrorCount = 10;
+     //static constexpr double maxReading = 127;
+     //static constexpr double minReading = -128;
++    static double DieTemp;
+     static constexpr const char* labelTcontrol = "Tcontrol";
+ 
+   private:
+diff --git a/include/MOSTempSensor.hpp b/include/MOSTempSensor.hpp
+new file mode 100755
+index 0000000..be022ab
+--- /dev/null
++++ b/include/MOSTempSensor.hpp
+@@ -0,0 +1,33 @@
++#pragma once
++#include "sensor.hpp"
++
++#include <boost/asio/deadline_timer.hpp>
++#include <boost/container/flat_map.hpp>
++#include <chrono>
++#include <limits>
++#include <vector>
++
++struct MOSTempSensor : public Sensor
++{
++    MOSTempSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
++                  boost::asio::io_service& io, const std::string& name,
++                  const std::string& sensorConfiguration,
++                  sdbusplus::asio::object_server& objectServer,
++                  std::vector<thresholds::Threshold>&& thresholds,
++                  uint8_t busId, uint8_t mcuAddress, uint8_t tempReg);
++    ~MOSTempSensor();
++
++    void checkThresholds(void) override;
++    void read(void);
++    void init(void);
++
++    uint8_t busId;
++    uint8_t address;
++    uint8_t tempReg;
++
++  private:
++    int getMOSRegsInfoWord(uint8_t regs, int16_t* pu16data);
++    sdbusplus::asio::object_server& objectServer;
++    std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
++    boost::asio::deadline_timer waitTimer;
++};
+diff --git a/service_files/xyz.openbmc_project.mostempsensor.service b/service_files/xyz.openbmc_project.mostempsensor.service
+new file mode 100755
+index 0000000..c839a71
+--- /dev/null
++++ b/service_files/xyz.openbmc_project.mostempsensor.service
+@@ -0,0 +1,11 @@
++[Unit]
++Description=MOS Temp Sensor
++StopWhenUnneeded=false
++
++[Service]
++Restart=always
++RestartSec=5
++ExecStart=/usr/bin/mostempsensor
++
++[Install]
++WantedBy=multi-user.target
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+index 8a9942f..1d21585 100644
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -33,6 +33,8 @@
+ #include <string>
+ #include <vector>
+ 
++double CPUSensor::DieTemp=0;
++
+ CPUSensor::CPUSensor(const std::string& path, const std::string& objectType,
+                      sdbusplus::asio::object_server& objectServer,
+                      std::shared_ptr<sdbusplus::asio::connection>& conn,
+@@ -165,6 +167,19 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+ 
+             updateValueInvalid(false);
+ 
++            auto findCpu = path.find("peci-cputemp");
++            auto findDie = path.find("temp1");
++            auto findMargin = path.find("temp4");
++            if ((findCpu != std::string::npos) && (findDie != std::string::npos))
++            {
++                CPUSensor::DieTemp = nvalue;
++            }
++            else if ((findCpu != std::string::npos) && (findMargin != std::string::npos))
++            {
++                nvalue = CPUSensor::DieTemp - nvalue;
++                updateValue(nvalue);
++            }
++
+ #ifdef BMC_CPU_SENSOR_TCONTROL
+             double gTcontrol = gCpuSensors[nameTcontrol]
+                                    ? gCpuSensors[nameTcontrol]->value
+diff --git a/src/CPUSensorMain.cpp b/src/CPUSensorMain.cpp
+index 7e198a1..3902163 100755
+--- a/src/CPUSensorMain.cpp
++++ b/src/CPUSensorMain.cpp
+@@ -94,8 +94,8 @@ namespace fs = std::filesystem;
+ static constexpr const char* configPrefix =
+     "xyz.openbmc_project.Configuration.";
+ static constexpr std::array<const char*, 1> sensorTypes = {"XeonCPU"};
+-static constexpr std::array<const char*, 3> hiddenProps = {
+-    CPUSensor::labelTcontrol, "Tthrottle", "Tjmax"};
++static constexpr std::array<const char*, 2> hiddenProps = {
++    CPUSensor::labelTcontrol, "Tthrottle"};
+ 
+ void detectCpuAsync(
+     boost::asio::deadline_timer& pingTimer,
+diff --git a/src/MOSTempSensor.cpp b/src/MOSTempSensor.cpp
+new file mode 100755
+index 0000000..dcfccaf
+--- /dev/null
++++ b/src/MOSTempSensor.cpp
+@@ -0,0 +1,297 @@
++#include "MOSTempSensor.hpp"
++
++#include "Utils.hpp"
++#include "VariantVisitors.hpp"
++
++#include <math.h>
++
++#include <boost/algorithm/string.hpp>
++#include <boost/algorithm/string/predicate.hpp>
++#include <boost/algorithm/string/replace.hpp>
++#include <chrono>
++#include <iostream>
++#include <limits>
++#include <numeric>
++#include <sdbusplus/asio/connection.hpp>
++#include <sdbusplus/asio/object_server.hpp>
++#include <vector>
++
++extern "C" {
++#include <i2c/smbus.h>
++#include <linux/i2c-dev.h>
++}
++
++constexpr const bool debug = false;
++
++constexpr const char* configInterface =
++    "xyz.openbmc_project.Configuration.MOSTempSensor";
++static constexpr double TempMaxReading = 0xFF;
++static constexpr double TempMinReading = 0;
++
++boost::container::flat_map<std::string, std::unique_ptr<MOSTempSensor>> sensors;
++
++MOSTempSensor::MOSTempSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
++                             boost::asio::io_service& io,
++                             const std::string& sensorName,
++                             const std::string& sensorConfiguration,
++                             sdbusplus::asio::object_server& objectServer,
++                             std::vector<thresholds::Threshold>&& thresholdData,
++                             uint8_t busId, uint8_t address,
++                             uint8_t tempReg) :
++    Sensor(boost::replace_all_copy(sensorName, " ", "_"),
++           std::move(thresholdData), sensorConfiguration,
++           "xyz.openbmc_project.Configuration.MosTemp", TempMaxReading,
++           TempMinReading),
++    objectServer(objectServer), dbusConnection(conn), waitTimer(io),
++    busId(busId), address(address), tempReg(tempReg)
++{
++    sensorInterface = objectServer.add_interface(
++        "/xyz/openbmc_project/sensors/temperature/" + name,
++        "xyz.openbmc_project.Sensor.Value");
++
++    if (thresholds::hasWarningInterface(thresholds))
++    {
++        thresholdInterfaceWarning = objectServer.add_interface(
++            "/xyz/openbmc_project/sensors/temperature/" + name,
++            "xyz.openbmc_project.Sensor.Threshold.Warning");
++    }
++    if (thresholds::hasCriticalInterface(thresholds))
++    {
++        thresholdInterfaceCritical = objectServer.add_interface(
++            "/xyz/openbmc_project/sensors/temperature/" + name,
++            "xyz.openbmc_project.Sensor.Threshold.Critical");
++    }
++    association = objectServer.add_interface(
++        "/xyz/openbmc_project/sensors/temperature/" + name,
++        "org.openbmc.Associations");
++}
++
++MOSTempSensor::~MOSTempSensor()
++{
++    waitTimer.cancel();
++    objectServer.remove_interface(thresholdInterfaceWarning);
++    objectServer.remove_interface(thresholdInterfaceCritical);
++    objectServer.remove_interface(sensorInterface);
++    objectServer.remove_interface(association);
++}
++
++void MOSTempSensor::init(void)
++{
++    setInitialProperties(dbusConnection);
++    read();
++}
++
++void MOSTempSensor::checkThresholds(void)
++{
++    thresholds::checkThresholds(this);
++}
++
++int MOSTempSensor::getMOSRegsInfoWord(uint8_t regs, int16_t* pu16data)
++{
++    std::string i2cBus = "/dev/i2c-" + std::to_string(busId);
++    int fd = open(i2cBus.c_str(), O_RDWR);
++    size_t i = 0;
++
++    if (fd < 0)
++    {
++        std::cerr << " unable to open i2c device" << i2cBus << "  err=" << fd
++                  << "\n";
++        return -1;
++    }
++
++    if (ioctl(fd, I2C_SLAVE_FORCE, address) < 0)
++    {
++        std::cerr << " unable to set device address\n";
++        close(fd);
++        return -1;
++    }
++
++    unsigned long funcs = 0;
++    if (ioctl(fd, I2C_FUNCS, &funcs) < 0)
++    {
++        std::cerr << " not support I2C_FUNCS\n";
++        close(fd);
++        return -1;
++    }
++
++    if (!(funcs & I2C_FUNC_SMBUS_READ_WORD_DATA))
++    {
++        std::cerr << " not support I2C_FUNC_SMBUS_READ_WORD_DATA\n";
++        close(fd);
++        return -1;
++    }
++
++    *pu16data = i2c_smbus_read_word_data(fd, regs);
++    close(fd);
++
++    if (*pu16data < 0)
++    {
++        std::cerr << " read word data failed at " << static_cast<int>(regs)
++                  << "\n";
++        return -1;
++    }
++
++    return 0;
++}
++
++void MOSTempSensor::read(void)
++{
++    static constexpr size_t pollTime = 1; // in seconds
++
++    waitTimer.expires_from_now(boost::posix_time::seconds(pollTime));
++    waitTimer.async_wait([this](const boost::system::error_code& ec) {
++        if (ec == boost::asio::error::operation_aborted)
++        {
++            return; // we're being cancelled
++        }
++        // read timer error
++        else if (ec)
++        {
++            std::cerr << "timer error\n";
++            return;
++        }
++        int16_t temp;
++        int ret = getMOSRegsInfoWord(tempReg, &temp);
++        if (ret >= 0)
++        {
++            double v = static_cast<double>(temp);
++            if constexpr (debug)
++            {
++                std::cerr << "Value update to " << (double)v << "raw reading "
++                          << static_cast<int>(temp) << "\n";
++            }
++            updateValue(v);
++        }
++        else
++        {
++            std::cerr << "Invalid read getMOSRegsInfoWord\n";
++            updateValue(-1);
++        }
++        read();
++    });
++}
++
++void createSensors(
++    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
++    boost::container::flat_map<std::string, std::unique_ptr<MOSTempSensor>>&
++        sensors,
++    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection)
++{
++    if (!dbusConnection)
++    {
++        std::cerr << "Connection not created\n";
++        return;
++    }
++
++    dbusConnection->async_method_call(
++        [&io, &objectServer, &dbusConnection, &sensors](
++            boost::system::error_code ec, const ManagedObjectType& resp) {
++            if (ec)
++            {
++                std::cerr << "Error contacting entity manager\n";
++                return;
++            }
++            for (const auto& pathPair : resp)
++            {
++                for (const auto& entry : pathPair.second)
++                {
++                    if (entry.first != configInterface)
++                    {
++                        continue;
++                    }
++                    std::string name =
++                        loadVariant<std::string>(entry.second, "Name");
++
++                    std::vector<thresholds::Threshold> sensorThresholds;
++                    if (!parseThresholdsFromConfig(pathPair.second,
++                                                   sensorThresholds))
++                    {
++                        std::cerr << "error populating thresholds for " << name
++                                  << "\n";
++                    }
++
++                    uint8_t busId = loadVariant<uint8_t>(entry.second, "Bus");
++
++                    uint8_t address =
++                        loadVariant<uint8_t>(entry.second, "Address");
++
++                    uint8_t tempReg = loadVariant<uint8_t>(entry.second, "Reg");
++
++                    std::string sensorClass =
++                        loadVariant<std::string>(entry.second, "Class");
++
++                    if constexpr (debug)
++                    {
++                        std::cerr
++                            << "Configuration parsed for \n\t" << entry.first
++                            << "\n"
++                            << "with\n"
++                            << "\tName: " << name << "\n"
++                            << "\tBus: " << static_cast<int>(busId) << "\n"
++                            << "\tAddress: " << static_cast<int>(address)
++                            << "\n"
++                            << "\tReg: " << static_cast<int>(tempReg) << "\n"
++                            << "\tClass: " << sensorClass << "\n";
++                    }
++
++                    auto& sensor = sensors[name];
++
++                    sensor = std::make_unique<MOSTempSensor>(
++                        dbusConnection, io, name, pathPair.first, objectServer,
++                        std::move(sensorThresholds), busId, address,
++                        tempReg);
++
++                    sensor->init();
++                }
++            }
++        },
++        entityManagerName, "/", "org.freedesktop.DBus.ObjectManager",
++        "GetManagedObjects");
++}
++
++int main(int argc, char** argv)
++{
++    boost::asio::io_service io;
++    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
++    systemBus->request_name("xyz.openbmc_project.MOSTempSensor");
++    sdbusplus::asio::object_server objectServer(systemBus);
++
++    io.post([&]() { createSensors(io, objectServer, sensors, systemBus); });
++
++    boost::asio::deadline_timer configTimer(io);
++
++    std::function<void(sdbusplus::message::message&)> eventHandler =
++        [&](sdbusplus::message::message& message) {
++            configTimer.expires_from_now(boost::posix_time::seconds(1));
++            // create a timer because normally multiple properties change
++            configTimer.async_wait([&](const boost::system::error_code& ec) {
++                if (ec == boost::asio::error::operation_aborted)
++                {
++                    return; // we're being canceled
++                }
++                // config timer error
++                else if (ec)
++                {
++                    std::cerr << "timer error\n";
++                    return;
++                }
++                createSensors(io, objectServer, sensors, systemBus);
++                if (sensors.empty())
++                {
++                    std::cout << "Configuration not detected\n";
++                }
++            });
++        };
++
++    sdbusplus::bus::match::match configMatch(
++        static_cast<sdbusplus::bus::bus&>(*systemBus),
++        "type='signal',member='PropertiesChanged',"
++        "path_namespace='" +
++            std::string(inventoryPath) +
++            "',"
++            "arg0namespace='" +
++            configInterface + "'",
++        eventHandler);
++
++    io.run();
++}
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0026-support-leaky-bucket-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0026-support-leaky-bucket-sensor.patch
new file mode 100755
index 0000000..e69557a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0026-support-leaky-bucket-sensor.patch
@@ -0,0 +1,341 @@
+From b1ebb8c99c0196c24cd95bcf5e7813a7003f6f26 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 16:28:35 +0800
+Subject: [PATCH 1/1] support leaky bucket sensor
+
+---
+ CMakeLists.txt                                |  13 +
+ ...penbmc_project.hostmemoryeccsensor.service |  12 +
+ src/HostMemoryEccSenosr.cpp                   | 266 ++++++++++++++++++
+ 3 files changed, 291 insertions(+)
+ create mode 100644 service_files/xyz.openbmc_project.hostmemoryeccsensor.service
+ create mode 100755 src/HostMemoryEccSenosr.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 4f48e56..b55dcb0 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -52,6 +52,7 @@ option (DISABLE_ACPI "Disable installing acpi sensor" OFF)
+ option (DISABLE_POWER_STATUS "Disable installing power status sensor" OFF)
+ option (BMC_CPU_SENSOR_TCONTROL "Enable Tcontrol Threshold setting" ON)
+ option (DISABLE_MOSTEMP "Disable installing MOS temperature sensor" OFF)
++option (DISABLE_HOST_MEM_ECC "Disable host memory ECC sensor" OFF)
+ 
+ include ("cmake/HunterGate.cmake")
+ 
+@@ -229,6 +230,10 @@ add_dependencies (mostempsensor sdbusplus-project)
+ target_link_libraries (mostempsensor ${SENSOR_LINK_LIBS})
+ target_link_libraries (mostempsensor i2c)
+ 
++add_executable (hostmemoryeccsensor src/HostMemoryEccSenosr.cpp)
++add_dependencies (hostmemoryeccsensor sdbusplus-project)
++target_link_libraries (hostmemoryeccsensor ${SENSOR_LINK_LIBS})
++
+ if (NOT DISABLE_NVME)
+     add_executable (nvmesensor ${NVME_SRC_FILES})
+     add_dependencies (nvmesensor sdbusplus-project)
+@@ -361,3 +366,11 @@ if (NOT DISABLE_MOSTEMP)
+     )
+ endif ()
+ 
++if (NOT DISABLE_HOST_MEM_ECC)
++    install (TARGETS hostmemoryeccsensor DESTINATION bin)
++    install (FILES
++                ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.hostmemoryeccsensor.service
++                DESTINATION ${SERVICE_FILE_INSTALL_DIR}
++    )
++endif ()
++
+diff --git a/service_files/xyz.openbmc_project.hostmemoryeccsensor.service b/service_files/xyz.openbmc_project.hostmemoryeccsensor.service
+new file mode 100644
+index 0000000..74585a9
+--- /dev/null
++++ b/service_files/xyz.openbmc_project.hostmemoryeccsensor.service
+@@ -0,0 +1,12 @@
++[Unit]
++Description=Host Memory ECC leaky bucket sensor
++StopWhenUnneeded=false
++After=xyz.openbmc_project.EntityManager.service
++[Service]
++Restart=always
++RestartSec=5
++ExecStart=/usr/bin/env hostmemoryeccsensor
++SyslogIdentifier=hostMemEcc
++
++[Install]
++WantedBy=multi-user.target
+diff --git a/src/HostMemoryEccSenosr.cpp b/src/HostMemoryEccSenosr.cpp
+new file mode 100755
+index 0000000..6453c1b
+--- /dev/null
++++ b/src/HostMemoryEccSenosr.cpp
+@@ -0,0 +1,266 @@
++#include <Utils.hpp>
++#include <boost/algorithm/string/predicate.hpp>
++#include <boost/asio.hpp>
++#include <boost/bind.hpp>
++#include <boost/format.hpp>
++#include <chrono>
++#include <ctime>
++#include <iostream>
++#include <algorithm>
++#include <sdbusplus/asio/connection.hpp>
++#include <sdbusplus/asio/object_server.hpp>
++#include <sdbusplus/asio/sd_event.hpp>
++#include <sdbusplus/bus.hpp>
++#include <sdbusplus/exception.hpp>
++#include <sdbusplus/server.hpp>
++#include <sdbusplus/timer.hpp>
++#include <sensor.hpp>
++#include <systemd/sd-journal.h>
++#include <fstream>
++
++
++static constexpr bool DEBUG = false;
++
++static const std::string hostEccSensorPath = "/xyz/openbmc_project/leakyBucket/HOST_DIMM_ECC";
++static const std::string lbConfigFile = "/var/lib/ipmi/lbConfig";
++
++uint8_t t1 = 49;
++uint8_t t2 = 7;
++static size_t pollTime = 24; // in seconds
++
++struct leakyBucketSensor 
++{
++    leakyBucketSensor(const std::string& name, std::shared_ptr<sdbusplus::asio::connection>& conn,
++                             boost::asio::io_service& io,
++                             sdbusplus::asio::object_server& objectServer):
++                             name(name), objectServer(objectServer), dbusConnection(conn), waitTimer(io)
++    {
++        std::string bucketPath = hostEccSensorPath + "/" + name;
++        intf = objectServer.add_interface(bucketPath,sensorValueInterface);
++        intf->register_property("count", count);
++        intf->initialize();
++    }
++    ~leakyBucketSensor()
++    {
++        waitTimer.cancel();
++        objectServer.remove_interface(intf);
++    }
++    void read(void);
++    void init(void);
++    bool addEcc(void);
++
++    std::string name;
++    uint8_t count = 0;
++
++  private:
++    sdbusplus::asio::object_server& objectServer;
++    std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
++    boost::asio::deadline_timer waitTimer;
++    std::shared_ptr<sdbusplus::asio::dbus_interface> intf;
++};
++
++boost::container::flat_map<std::string, std::unique_ptr<leakyBucketSensor>> lbSensors;
++
++void createBucket(
++    const std::string &bucketName,
++    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
++    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection)
++{
++    if (!dbusConnection)
++    {
++        std::cerr << "Connection not created\n";
++        return;
++    }
++    
++    auto& bucket = lbSensors[bucketName];
++
++    bucket = std::make_unique<leakyBucketSensor>(
++            bucketName, dbusConnection, io, objectServer);
++
++    bucket->init();
++}
++
++void leakyBucketSensor::init(void)
++{
++    read();
++}
++
++void leakyBucketSensor::read(void)
++{
++
++    waitTimer.expires_from_now(boost::posix_time::hours(pollTime));
++    waitTimer.async_wait([this](const boost::system::error_code& ec) {
++        if (ec == boost::asio::error::operation_aborted)
++        {
++            return; // we're being cancelled
++        }
++        // read timer error
++        else if (ec)
++        {
++            std::cerr << "timer error\n";
++            return;
++        }
++        count = (count > t2) ? (count-t2):0;
++        intf->set_property("count", count);
++        read();
++    });
++}
++
++bool leakyBucketSensor::addEcc(void)
++{
++    bool overflow = false;
++    count++;
++    
++    //restart timer 
++#if 0    
++    if(count == 1)
++    {
++        waitTimer.cancel();
++        waitTimer.expires_from_now(boost::posix_time::hours(pollTime));
++    }
++#endif     
++    //NOTE!!: according to F4 implementation, the count should be cleared when overflow
++    if(count >= t1){
++        count = 0; 
++        overflow = true;
++    }    
++
++    intf->set_property("count", count);
++    if constexpr (1){
++        boost::posix_time::time_duration td = waitTimer.expires_from_now();
++        //std::cerr << "expires_from_now :" << td.seconds() << "\n";
++        std::cerr << boost::format("%d:%d:%d") % td.hours() % td.minutes() % td.seconds() << "\n";
++    }
++    
++    return overflow;
++}
++
++//increase ECC to bucket, return true if overflow
++static bool 
++    increaseEccToBucket(const std::string &bucketName, boost::asio::io_service& io, 
++    sdbusplus::asio::object_server& objectServer,std::shared_ptr<sdbusplus::asio::connection>& dbusConnection)
++{
++    
++    auto bucket = lbSensors.find(bucketName);
++    if (bucket != lbSensors.end())
++    {
++        std::cerr << "bucket existing:" << bucketName << std::endl;
++    }else{
++       createBucket(bucketName, io, objectServer, dbusConnection);
++    }
++
++    auto& sensor = lbSensors[bucketName];
++    return sensor->addEcc();
++    
++}
++
++void updateConfig()
++{
++    static bool init=false;
++
++    if(!init)
++    {
++        init = true;
++        std::ifstream lbConfig(lbConfigFile,std::ios::binary);
++        if(!lbConfig.good())
++        {
++            std::cerr << "file not exist, take default\n";
++            return;
++        }
++        //load from file
++ 
++        t1 = lbConfig.get();       
++        t2 = lbConfig.get();
++        pollTime = (size_t)lbConfig.get();
++  
++        return;
++    }
++
++    std::ofstream output(lbConfigFile,std::ios::binary);
++    if (!output.good())
++    {
++        std::cerr << "can't create config\n";
++    }
++    else
++    {
++        output << t1;
++        output << t2;
++        output << (uint8_t)pollTime;
++        output.close();
++    }
++    return;
++}
++int main()
++{
++    // setup connection to dbus
++    boost::asio::io_service io;
++    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
++    auto objServer = sdbusplus::asio::object_server(systemBus);
++    // setup object server, define interface
++    systemBus->request_name("xyz.openbmc_project.leaklyBucketSensor");
++
++    // add interface into sensor tree
++    std::shared_ptr<sdbusplus::asio::dbus_interface> iface =
++        objServer.add_interface(hostEccSensorPath,sensorValueInterface);
++
++    updateConfig();
++    //int64_t count = 0;
++    iface->register_property("T1", t1, sdbusplus::asio::PropertyPermission::readWrite);
++    iface->register_property("T2", t2, sdbusplus::asio::PropertyPermission::readWrite);
++    iface->register_property("polltime", (uint8_t)pollTime, sdbusplus::asio::PropertyPermission::readWrite);
++
++    // add a ecc, check 
++    iface->register_method(
++        "increaseEccToBucket", [&](const std::string &bucketName) {
++            return increaseEccToBucket(bucketName, io, objServer, systemBus);
++        });    
++
++    iface->initialize();
++
++    auto eventHandler =
++        [&](sdbusplus::message::message& message) {
++            boost::container::flat_map<std::string, std::variant<uint8_t>> values;
++            std::string objectName;
++            if (DEBUG)
++            {
++                std::cerr << message.get_path() << " is changed\n";
++            }
++ 
++            message.read(objectName, values);
++          
++            auto tValue = values.find("T1");
++            if (tValue != values.end())
++            {
++                 std::cerr << "T1 change to :" << unsigned(std::get<std::uint8_t>(tValue->second)) << "\n";
++                 t1 = std::get<std::uint8_t>(tValue->second);
++            }
++            tValue = values.find("T2");
++            if (tValue != values.end())
++            {
++                 std::cerr << "T2 change to :" << unsigned(std::get<std::uint8_t>(tValue->second)) << "\n";
++                 t2 = std::get<std::uint8_t>(tValue->second);
++            }
++            tValue = values.find("polltime");
++            if (tValue != values.end())
++            {
++                 std::cerr << "polltime change to :" << unsigned(std::get<std::uint8_t>(tValue->second)) << "\n";
++                 pollTime = (size_t)(std::get<std::uint8_t>(tValue->second));
++            }
++
++            updateConfig();
++        };
++
++    sdbusplus::bus::match::match configMatch(
++        static_cast<sdbusplus::bus::bus&>(*systemBus),
++        "type='signal',member='PropertiesChanged',"
++        "path_namespace='" +
++            std::string(hostEccSensorPath) +
++            "',"
++            "arg0namespace='" +
++            sensorValueInterface + "'",
++        eventHandler);
++    
++    io.run();
++
++    return 0;
++}
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0029-set-sensor-reading-unavailable-bit-if-nvme-is-not-pr.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0029-set-sensor-reading-unavailable-bit-if-nvme-is-not-pr.patch
new file mode 100755
index 0000000..85bb9ef
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0029-set-sensor-reading-unavailable-bit-if-nvme-is-not-pr.patch
@@ -0,0 +1,141 @@
+From 65115255c11d0d082a6344f13149cbe05427788b Mon Sep 17 00:00:00 2001
+From: Mirage Su <mirage.su@mic.com.tw>
+Date: Wed, 5 Feb 2020 11:56:45 +0800
+Subject: [PATCH] set sensor reading unavailable bit if nvme is not present
+
+---
+ .../xyz.openbmc_project.nvmesensor.service         |  5 +-
+ src/NVMeSensor.cpp                                 | 64 +++++++++++-----------
+ 2 files changed, 36 insertions(+), 33 deletions(-)
+
+diff --git a/service_files/xyz.openbmc_project.nvmesensor.service b/service_files/xyz.openbmc_project.nvmesensor.service
+index a5c8725..e94bf9b 100755
+--- a/service_files/xyz.openbmc_project.nvmesensor.service
++++ b/service_files/xyz.openbmc_project.nvmesensor.service
+@@ -1,7 +1,8 @@
+ [Unit]
+ Description=NVMe Sensor
+ StopWhenUnneeded=false
+-After=xyz.openbmc_project.FruDevice.service
++Requires=xyz.openbmc_project.EntityManager.service
++After=xyz.openbmc_project.EntityManager.service
+ 
+ [Service]
+ Restart=always
+@@ -9,4 +10,4 @@ RestartSec=5
+ ExecStart=/usr/bin/nvmesensor
+ 
+ [Install]
+-WantedBy=multi-user.target
+\ No newline at end of file
++WantedBy=multi-user.target
+diff --git a/src/NVMeSensor.cpp b/src/NVMeSensor.cpp
+index 4da1e1b..918b308 100755
+--- a/src/NVMeSensor.cpp
++++ b/src/NVMeSensor.cpp
+@@ -68,7 +68,7 @@ NVMeSensor::NVMeSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
+     }
+     association = objectServer.add_interface(
+         "/xyz/openbmc_project/sensors/temperature/" + name,
+-        "org.openbmc.Associations");  //association::interface);  //mirage: temporarily use old code
++        association::interface);
+ }
+ 
+ NVMeSensor::~NVMeSensor()
+@@ -192,8 +192,8 @@ static inline __s32 i2c_read_after_write(int file, __u8 command,
+ int NVMeSensor::getNVMeTemp(uint8_t* pu8data)
+ {
+     int res, res_len;
+-	unsigned char Rx_buf[I2C_DATA_MAX] = {0};
+-	unsigned char tx_data = 0;	//command code
++    unsigned char Rx_buf[I2C_DATA_MAX] = {0};
++    unsigned char tx_data = 0;  //command code
+     std::string i2cBus = "/dev/i2c-" + std::to_string(busId);
+     int fd = open(i2cBus.c_str(), O_RDWR);
+ 
+@@ -212,19 +212,21 @@ int NVMeSensor::getNVMeTemp(uint8_t* pu8data)
+     if (res < 0)
+     {
+         std::cerr << "Error: block write read failed\n";
++		close(fd);
++		return -1;
+     }
+ 
+     res_len = Rx_buf[0] + 1;
+ 
+-	if constexpr (debug)
+-	{
+-		std::cerr << "Block data read \n\t";
+-		for (int i=0; i<32; i++)
+-		{
+-		    std::cerr << std::to_string(Rx_buf[i]) << "  ";
+-		}
+-	    std::cerr << "\n";
+-	}
++    if constexpr (debug)
++    {
++        std::cerr << "Block data read \n\t";
++        for (int i=0; i<32; i++)
++        {
++            std::cerr << std::to_string(Rx_buf[i]) << "  ";
++        }
++        std::cerr << "\n";
++    }
+ 
+     *pu8data = Rx_buf[3];
+     
+@@ -234,35 +236,35 @@ int NVMeSensor::getNVMeTemp(uint8_t* pu8data)
+     {
+         return 0;
+     }
+-	else if (*pu8data == 0x7F)
+-	{
++    else if (*pu8data == 0x7F)
++    {
+         std::cerr << "Temperature is 127 or higher\n";
+         return -1;
+-	}
+-	else if (*pu8data == 0x80)
+-	{
++    }
++    else if (*pu8data == 0x80)
++    {
+         std::cerr << "No temperature data or temperature data is more than 5 seconds old\n";
+         return -1;
+-	}
+-	else if (*pu8data == 0x81)
+-	{
++    }
++    else if (*pu8data == 0x81)
++    {
+         std::cerr << "Temperature sensor failure\n";
+         return -1;
+-	}
+-	else if (*pu8data == 0xC4)
+-	{
++    }
++    else if (*pu8data == 0xC4)
++    {
+         std::cerr << "Temperature is -60 or lower\n";
+         return -1;
+-	}
+-	else if (*pu8data >= 0xC5 && *pu8data <= 0xFF)
+-	{
++    }
++    else if (*pu8data >= 0xC5 && *pu8data <= 0xFF)
++    {
+         std::cerr << "Temperature measured in degrees Celsius is represented\n in twos complement(-1 to -59)\n";
+         return -1;
+-	}
+-	else
+-	{
+-		return -1;
+-	}
++    }
++    else
++    {
++        return -1;
++    }
+ }
+ 
+ void NVMeSensor::read(void)
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0030-add-sensor-reading-unavailable-bit-for-VR-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0030-add-sensor-reading-unavailable-bit-for-VR-sensor.patch
new file mode 100755
index 0000000..56e81be
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0030-add-sensor-reading-unavailable-bit-for-VR-sensor.patch
@@ -0,0 +1,75 @@
+From 015396e63a1c097e977e8682ac5988e6451b2ae9 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 16:42:26 +0800
+Subject: [PATCH 1/1] add-sensor-reading-unavailable-bit-for-VR-sensor
+
+---
+ .../xyz.openbmc_project.mostempsensor.service       |  2 ++
+ src/CPUSensor.cpp                                   |  2 +-
+ src/MOSTempSensor.cpp                               | 13 ++++++++++---
+ 3 files changed, 13 insertions(+), 4 deletions(-)
+
+diff --git a/service_files/xyz.openbmc_project.mostempsensor.service b/service_files/xyz.openbmc_project.mostempsensor.service
+index c839a71..f65f165 100644
+--- a/service_files/xyz.openbmc_project.mostempsensor.service
++++ b/service_files/xyz.openbmc_project.mostempsensor.service
+@@ -1,6 +1,8 @@
+ [Unit]
+ Description=MOS Temp Sensor
+ StopWhenUnneeded=false
++Requires=xyz.openbmc_project.EntityManager.service
++After=xyz.openbmc_project.EntityManager.service
+ 
+ [Service]
+ Restart=always
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+index 1d21585..c41177a 100644
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -169,7 +169,7 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+ 
+             auto findCpu = path.find("peci-cputemp");
+             auto findDie = path.find("temp1");
+-            auto findMargin = path.find("temp4");
++            auto findMargin = path.find("temp5");
+             if ((findCpu != std::string::npos) && (findDie != std::string::npos))
+             {
+                 CPUSensor::DieTemp = nvalue;
+diff --git a/src/MOSTempSensor.cpp b/src/MOSTempSensor.cpp
+index dcfccaf..87939bc 100644
+--- a/src/MOSTempSensor.cpp
++++ b/src/MOSTempSensor.cpp
+@@ -126,8 +126,10 @@ int MOSTempSensor::getMOSRegsInfoWord(uint8_t regs, int16_t* pu16data)
+ 
+     if (*pu16data < 0)
+     {
+-        std::cerr << " read word data failed at " << static_cast<int>(regs)
+-                  << "\n";
++        if constexpr (debug)
++        {
++            std::cerr << " read word data failed at " << static_cast<int>(regs) << "\n";
++        }
+         return -1;
+     }
+ 
+@@ -160,11 +162,16 @@ void MOSTempSensor::read(void)
+                 std::cerr << "Value update to " << (double)v << "raw reading "
+                           << static_cast<int>(temp) << "\n";
+             }
++            updateValueInvalid(false);
+             updateValue(v);
+         }
+         else
+         {
+-            std::cerr << "Invalid read getMOSRegsInfoWord\n";
++            if constexpr (debug)
++            {
++                std::cerr << "Invalid read getMOSRegsInfoWord\n";
++            }
++            updateValueInvalid(true);
+             updateValue(-1);
+         }
+         read();
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0031-Fix-the-cpu-sensor-display.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0031-Fix-the-cpu-sensor-display.patch
new file mode 100755
index 0000000..ad2a69e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0031-Fix-the-cpu-sensor-display.patch
@@ -0,0 +1,58 @@
+From 45e936cee742373440669dc857ca012a0d264858 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 5 Mar 2020 18:17:32 +0800
+Subject: [PATCH] Fix the cpu sensor display
+
+Remove cpu.state detect in create sensor function
+Remove created sensor detect function
+Add retry when new state with state-off
+---
+ src/CPUSensorMain.cpp | 18 +++---------------
+ 1 file changed, 3 insertions(+), 15 deletions(-)
+
+diff --git a/src/CPUSensorMain.cpp b/src/CPUSensorMain.cpp
+index 069323a..5f9fb2d 100755
+--- a/src/CPUSensorMain.cpp
++++ b/src/CPUSensorMain.cpp
+@@ -131,10 +131,6 @@ bool createSensors(boost::asio::io_service& io,
+             iface->initialize();
+         }
+     }
+-    if (!available)
+-    {
+-        return false;
+-    }
+ 
+     if (sensorConfigs.empty())
+     {
+@@ -325,17 +321,6 @@ bool createSensors(boost::asio::io_service& io,
+                 continue;
+             }
+ 
+-            auto findSensor = gCpuSensors.find(sensorName);
+-            if (findSensor != gCpuSensors.end())
+-            {
+-                if (DEBUG)
+-                {
+-                    std::cout << "Skipped: " << inputPath << ": " << sensorName
+-                              << " is already created\n";
+-                }
+-                continue;
+-            }
+-
+             // check hidden properties
+             bool show = true;
+             auto findCore = label.find("Core");
+@@ -538,6 +523,9 @@ void detectCpu(boost::asio::deadline_timer& pingTimer,
+                               << " is/are detected\n";
+                 }
+             }
++            else{
++                rescanDelaySeconds = 5;
++            }
+ 
+             config.state = newState;
+         }
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0032-mct-NVMe-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0032-mct-NVMe-sensor.patch
new file mode 100755
index 0000000..fc08d54
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0032-mct-NVMe-sensor.patch
@@ -0,0 +1,558 @@
+From c28941ea56d6c0f45f0bf6e677023e33c36581b1 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 12 Mar 2020 17:13:06 +0800
+Subject: [PATCH 1/1] mct NVMe sensor
+
+---
+ CMakeLists.txt                                |  17 +
+ include/MNVMeSensor.hpp                       |  34 ++
+ .../xyz.openbmc_project.mnvmesensor.service   |  13 +
+ src/MNVMeSensor.cpp                           | 429 ++++++++++++++++++
+ 4 files changed, 493 insertions(+)
+ create mode 100755 include/MNVMeSensor.hpp
+ create mode 100644 service_files/xyz.openbmc_project.mnvmesensor.service
+ create mode 100755 src/MNVMeSensor.cpp
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index b55dcb0..093a393 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -53,6 +53,7 @@ option (DISABLE_POWER_STATUS "Disable installing power status sensor" OFF)
+ option (BMC_CPU_SENSOR_TCONTROL "Enable Tcontrol Threshold setting" ON)
+ option (DISABLE_MOSTEMP "Disable installing MOS temperature sensor" OFF)
+ option (DISABLE_HOST_MEM_ECC "Disable host memory ECC sensor" OFF)
++option (DISABLE_MNVME "Disable installing MCT NVME sensor" OFF)
+ 
+ include ("cmake/HunterGate.cmake")
+ 
+@@ -89,6 +90,8 @@ set (MOSTEMP_SRC_FILES src/Utils.cpp src/Thresholds.cpp)
+ set (EXTERNAL_PACKAGES Boost sdbusplus-project nlohmann-json)
+ set (SENSOR_LINK_LIBS -lsystemd stdc++fs sdbusplus)
+ 
++set (MNVME_SRC_FILES src/Utils.cpp src/Utils.cpp src/Thresholds.cpp)
++
+ if (NOT YOCTO)
+     set (DISABLE_NVME ON) # todo allow this to build out of tree
+     option (ENABLE_TEST "Enable Google Test" OFF)
+@@ -234,6 +237,13 @@ add_executable (hostmemoryeccsensor src/HostMemoryEccSenosr.cpp)
+ add_dependencies (hostmemoryeccsensor sdbusplus-project)
+ target_link_libraries (hostmemoryeccsensor ${SENSOR_LINK_LIBS})
+ 
++if (NOT DISABLE_MNVME)
++    add_executable (mnvmesensor src/MNVMeSensor.cpp ${MNVME_SRC_FILES})
++    add_dependencies (mnvmesensor sdbusplus-project)
++    target_link_libraries (mnvmesensor ${SENSOR_LINK_LIBS})
++    target_link_libraries (mnvmesensor i2c)
++endif()
++
+ if (NOT DISABLE_NVME)
+     add_executable (nvmesensor ${NVME_SRC_FILES})
+     add_dependencies (nvmesensor sdbusplus-project)
+@@ -374,3 +384,10 @@ if (NOT DISABLE_HOST_MEM_ECC)
+     )
+ endif ()
+ 
++if (NOT DISABLE_MNVME)
++    install (TARGETS mnvmesensor DESTINATION bin)
++    install (FILES
++                 ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.mnvmesensor.service
++                 DESTINATION ${SERVICE_FILE_INSTALL_DIR})
++endif ()
++
+diff --git a/include/MNVMeSensor.hpp b/include/MNVMeSensor.hpp
+new file mode 100755
+index 0000000..fecb766
+--- /dev/null
++++ b/include/MNVMeSensor.hpp
+@@ -0,0 +1,34 @@
++#pragma once
++#include "sensor.hpp"
++
++#include <boost/asio/deadline_timer.hpp>
++#include <boost/container/flat_map.hpp>
++#include <chrono>
++#include <limits>
++#include <memory>
++#include <string>
++#include <vector>
++
++struct NVMeSensor : public Sensor
++{
++    NVMeSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
++                  boost::asio::io_service& io, const std::string& name,
++                  const std::string& sensorConfiguration,
++                  sdbusplus::asio::object_server& objectServer,
++                  std::vector<thresholds::Threshold>&& thresholds,
++                  uint8_t busId, uint8_t address);
++    ~NVMeSensor();
++
++    void checkThresholds(void) override;
++    void read(void);
++    void init(void);
++
++    uint8_t busId;
++    uint8_t address;
++
++  private:
++    int getNVMeTemp(uint8_t* pu8data);
++    sdbusplus::asio::object_server& objectServer;
++    std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
++    boost::asio::deadline_timer waitTimer;
++};
+diff --git a/service_files/xyz.openbmc_project.mnvmesensor.service b/service_files/xyz.openbmc_project.mnvmesensor.service
+new file mode 100644
+index 0000000..7c36e33
+--- /dev/null
++++ b/service_files/xyz.openbmc_project.mnvmesensor.service
+@@ -0,0 +1,13 @@
++[Unit]
++Description=MCT NVMe Sensor
++StopWhenUnneeded=false
++Requires=xyz.openbmc_project.EntityManager.service
++After=xyz.openbmc_project.EntityManager.service
++
++[Service]
++Restart=always
++RestartSec=5
++ExecStart=/usr/bin/mnvmesensor
++
++[Install]
++WantedBy=multi-user.target
+diff --git a/src/MNVMeSensor.cpp b/src/MNVMeSensor.cpp
+new file mode 100755
+index 0000000..2cccd93
+--- /dev/null
++++ b/src/MNVMeSensor.cpp
+@@ -0,0 +1,429 @@
++#include "MNVMeSensor.hpp"
++
++#include "Utils.hpp"
++#include "VariantVisitors.hpp"
++
++#include <math.h>
++
++#include <boost/algorithm/string.hpp>
++#include <boost/algorithm/string/predicate.hpp>
++#include <boost/algorithm/string/replace.hpp>
++#include <boost/container/flat_map.hpp>
++#include <chrono>
++#include <functional>
++#include <iostream>
++#include <limits>
++#include <memory>
++#include <numeric>
++#include <sdbusplus/asio/connection.hpp>
++#include <sdbusplus/asio/object_server.hpp>
++#include <sdbusplus/bus/match.hpp>
++#include <string>
++#include <vector>
++
++extern "C" {
++#include <i2c/smbus.h>
++#include <linux/i2c-dev.h>
++}
++
++constexpr const bool debug = false;
++
++constexpr const char* configInterface =
++    "xyz.openbmc_project.Configuration.NVME1000";
++static constexpr double maxReading = 127;
++static constexpr double minReading = -128;
++
++
++boost::container::flat_map<std::string, std::unique_ptr<NVMeSensor>> sensors;
++
++NVMeSensor::NVMeSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
++                             boost::asio::io_service& io,
++                             const std::string& sensorName,
++                             const std::string& sensorConfiguration,
++                             sdbusplus::asio::object_server& objectServer,
++                             std::vector<thresholds::Threshold>&& thresholdData,
++                             uint8_t busId, uint8_t address) :
++    Sensor(boost::replace_all_copy(sensorName, " ", "_"),
++           std::move(thresholdData), sensorConfiguration,
++           "xyz.openbmc_project.Configuration.NVME1000", maxReading,
++           minReading),
++    busId(busId), address(address),
++    objectServer(objectServer), dbusConnection(conn), waitTimer(io)
++{
++    sensorInterface = objectServer.add_interface(
++        "/xyz/openbmc_project/sensors/temperature/" + name,
++        "xyz.openbmc_project.Sensor.Value");
++
++    if (thresholds::hasWarningInterface(thresholds))
++    {
++        thresholdInterfaceWarning = objectServer.add_interface(
++            "/xyz/openbmc_project/sensors/temperature/" + name,
++            "xyz.openbmc_project.Sensor.Threshold.Warning");
++    }
++    if (thresholds::hasCriticalInterface(thresholds))
++    {
++        thresholdInterfaceCritical = objectServer.add_interface(
++            "/xyz/openbmc_project/sensors/temperature/" + name,
++            "xyz.openbmc_project.Sensor.Threshold.Critical");
++    }
++    association = objectServer.add_interface(
++        "/xyz/openbmc_project/sensors/temperature/" + name,
++        association::interface);
++}
++
++NVMeSensor::~NVMeSensor()
++{
++    waitTimer.cancel();
++    objectServer.remove_interface(thresholdInterfaceWarning);
++    objectServer.remove_interface(thresholdInterfaceCritical);
++    objectServer.remove_interface(sensorInterface);
++    objectServer.remove_interface(association);
++}
++
++void NVMeSensor::init(void)
++{
++    setInitialProperties(dbusConnection);
++    read();
++}
++
++void NVMeSensor::checkThresholds(void)
++{
++    thresholds::checkThresholds(this);
++}
++
++#define I2C_DATA_MAX 256
++
++static inline __u8 i2c_8bit_addr_from_msg(const struct i2c_msg* msg)
++{
++    return (msg->addr << 1) | (msg->flags & I2C_M_RD ? 1 : 0);
++}
++
++/* Since I2C_M_RD not implement PEC in the linux driver layer,
++   so copy some driver PEC check functions here */
++#define POLY (0x1070U << 3)
++static inline __u8 crc8(__u16 data)
++{
++    int i;
++
++    for (i = 0; i < 8; i++)
++    {
++        if (data & 0x8000)
++            data = data ^ POLY;
++        data = data << 1;
++    }
++    return (__u8)(data >> 8);
++}
++
++/* Incremental CRC8 over count bytes in the array pointed to by p */
++static inline __u8 i2c_smbus_pec(__u8 crc, __u8* p, size_t count)
++{
++    int i;
++
++    for (i = 0; i < (int)count; i++)
++        crc = crc8((crc ^ p[i]) << 8);
++    return crc;
++}
++
++/* Assume a 7-bit address, which is reasonable for SMBus */
++static inline __u8 i2c_smbus_msg_pec(__u8 pec, struct i2c_msg* msg)
++{
++    /* The address will be sent first */
++    __u8 addr = i2c_8bit_addr_from_msg(msg);
++    pec = i2c_smbus_pec(pec, &addr, 1);
++
++    /* The data buffer follows */
++    return i2c_smbus_pec(pec, (__u8*)msg->buf, msg->len);
++}
++
++/* Return <0 on CRC error
++   If there was a write before this read (most cases) we need to take the
++   partial CRC from the write part into account.
++   Note that this function does modify the message (we need to decrease the
++   message length to hide the CRC byte from the caller). */
++static inline int i2c_smbus_check_pec(__u8 cpec, struct i2c_msg* msg)
++{
++    __u8 rpec = msg->buf[--msg->len];
++    cpec = i2c_smbus_msg_pec(cpec, msg);
++    if (rpec != cpec)
++    {
++        printf("Error: Bad PEC 0x%02x vs. 0x%02x\n", rpec, cpec);
++        return -1;
++    }
++    return 0;
++}
++
++static inline __s32 i2c_read_after_write(int file, __u8 command,
++                                         __u8 slave_addr, __u8 tx_len,
++                                         const __u8* tx_buf, int rx_len,
++                                         const __u8* rx_buf)
++{
++    struct i2c_rdwr_ioctl_data msgst;
++    struct i2c_msg msg[2];
++    int ret;
++    int status;
++    __u8 partial_pec = 0;
++
++    msg[0].addr = slave_addr & 0xFF;
++    msg[0].flags = 0;
++    msg[0].buf = (unsigned char*)tx_buf;
++    msg[0].len = tx_len;
++
++    msg[1].addr = slave_addr & 0xFF;
++    msg[1].flags = I2C_M_RD | I2C_M_RECV_LEN;
++    msg[1].buf = (unsigned char*)rx_buf;
++    msg[1].len = rx_len;
++
++    msgst.msgs = msg;
++    msgst.nmsgs = 2;
++
++    ret = ioctl(file, I2C_RDWR, &msgst);
++    if (ret < 0)
++        return ret;
++    else if (command)
++    {
++        partial_pec = i2c_smbus_msg_pec(0, &msg[0]);
++        msg[1].len = rx_buf[0] + 1;
++        status = i2c_smbus_check_pec(partial_pec, &msg[1]);
++        return status;
++    }
++    return ret;
++}
++
++int NVMeSensor::getNVMeTemp(uint8_t* pu8data)
++{
++    int res, res_len;
++    unsigned char Rx_buf[I2C_DATA_MAX] = {0};
++    unsigned char tx_data = 0;  //command code
++    std::string i2cBus = "/dev/i2c-" + std::to_string(busId);
++    int fd = open(i2cBus.c_str(), O_RDWR);
++
++    if (fd < 0)
++    {
++        std::cerr << " unable to open i2c device" << i2cBus << "  err=" << fd
++                  << "\n";
++        return -1;
++    }
++
++    Rx_buf[0] = 1;
++    res = i2c_read_after_write(fd, 0, address, 1,
++                               &tx_data, I2C_DATA_MAX,
++                               (const unsigned char*)Rx_buf);
++
++    if (res < 0)
++    {
++        std::cerr << "Error: block write read failed\n";
++		close(fd);
++		return -1;
++    }
++
++    res_len = Rx_buf[0] + 1;
++
++    if constexpr (debug)
++    {
++        std::cerr << "Block data read \n\t";
++        for (int i=0; i<32; i++)
++        {
++            std::cerr << std::to_string(Rx_buf[i]) << "  ";
++        }
++        std::cerr << "\n";
++    }
++
++    *pu8data = Rx_buf[3];
++    
++    close(fd);
++
++    if (*pu8data <= 0x7E)
++    {
++        return 0;
++    }
++    else if (*pu8data == 0x7F)
++    {
++        std::cerr << "Temperature is 127 or higher\n";
++        return -1;
++    }
++    else if (*pu8data == 0x80)
++    {
++        if constexpr (debug)
++        {
++            std::cerr << "No temperature data or temperature data is more than 5 seconds old\n";
++        }
++        return -1;
++    }
++    else if (*pu8data == 0x81)
++    {
++        std::cerr << "Temperature sensor failure\n";
++        return -1;
++    }
++    else if (*pu8data == 0xC4)
++    {
++        std::cerr << "Temperature is -60 or lower\n";
++        return -1;
++    }
++    else if (*pu8data >= 0xC5 && *pu8data <= 0xFF)
++    {
++        std::cerr << "Temperature measured in degrees Celsius is represented\n in twos complement(-1 to -59)\n";
++        return -1;
++    }
++    else
++    {
++        return -1;
++    }
++}
++
++void NVMeSensor::read(void)
++{
++    static constexpr size_t pollTime = 1; // in seconds
++
++    waitTimer.expires_from_now(boost::posix_time::seconds(pollTime));
++    waitTimer.async_wait([this](const boost::system::error_code& ec) {
++        if (ec == boost::asio::error::operation_aborted)
++        {
++            return; // we're being cancelled
++        }
++        // read timer error
++        else if (ec)
++        {
++            std::cerr << "timer error\n";
++            return;
++        }
++        uint8_t temp;
++        int ret = getNVMeTemp(&temp);
++        if (ret >= 0)
++        {
++            double v = static_cast<double>(temp);
++            if constexpr (debug)
++            {
++                std::cerr << "Value update to " << v << "\n";
++            }
++            updateValueInvalid(false);
++            updateValue(v);
++        }
++        else
++        {
++            if constexpr (debug)
++            {
++                std::cerr << "Invalid read getNVMeTemp\n";
++            }
++            updateValueInvalid(true);
++            updateValue(-1);
++        }
++        read();
++    });
++}
++
++void createSensors(
++    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
++    boost::container::flat_map<std::string, std::unique_ptr<NVMeSensor>>&
++        sensors,
++    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection)
++{
++    if (!dbusConnection)
++    {
++        std::cerr << "Connection not created\n";
++        return;
++    }
++
++    dbusConnection->async_method_call(
++        [&io, &objectServer, &dbusConnection, &sensors](
++            boost::system::error_code ec, const ManagedObjectType& resp) {
++            if (ec)
++            {
++                std::cerr << "Error contacting entity manager\n";
++                return;
++            }
++            for (const auto& pathPair : resp)
++            {
++                for (const auto& entry : pathPair.second)
++                {
++                    if (entry.first != configInterface)
++                    {
++                        continue;
++                    }
++                    std::string name =
++                        loadVariant<std::string>(entry.second, "Name");
++
++                    std::vector<thresholds::Threshold> sensorThresholds;
++                    if (!parseThresholdsFromConfig(pathPair.second,
++                                                   sensorThresholds))
++                    {
++                        std::cerr << "error populating thresholds for " << name
++                                  << "\n";
++                    }
++
++                    uint8_t busId = loadVariant<uint8_t>(entry.second, "Bus");
++
++                    uint8_t address =
++                        loadVariant<uint8_t>(entry.second, "Address");
++
++                    if constexpr (debug)
++                    {
++                        std::cerr
++                            << "Configuration parsed for \n\t" << entry.first
++                            << "\n"
++                            << "with\n"
++                            << "\tName: " << name << "\n"
++                            << "\tBus: " << static_cast<int>(busId) << "\n"
++                            << "\tAddress: " << static_cast<int>(address)
++                            << "\n";
++                    }
++
++                    auto& sensor = sensors[name];
++
++                    sensor = std::make_unique<NVMeSensor>(
++                        dbusConnection, io, name, pathPair.first, objectServer,
++                        std::move(sensorThresholds), busId, address);
++
++                    sensor->init();
++                }
++            }
++        },
++        entityManagerName, "/", "org.freedesktop.DBus.ObjectManager",
++        "GetManagedObjects");
++}
++
++int main()
++{
++    boost::asio::io_service io;
++    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
++    systemBus->request_name("xyz.openbmc_project.NVMeSensor");
++    sdbusplus::asio::object_server objectServer(systemBus);
++
++    io.post([&]() { createSensors(io, objectServer, sensors, systemBus); });
++
++    boost::asio::deadline_timer configTimer(io);
++
++    std::function<void(sdbusplus::message::message&)> eventHandler =
++        [&](sdbusplus::message::message&) {
++            configTimer.expires_from_now(boost::posix_time::seconds(1));
++            // create a timer because normally multiple properties change
++            configTimer.async_wait([&](const boost::system::error_code& ec) {
++                if (ec == boost::asio::error::operation_aborted)
++                {
++                    return; // we're being canceled
++                }
++                // config timer error
++                else if (ec)
++                {
++                    std::cerr << "timer error\n";
++                    return;
++                }
++                createSensors(io, objectServer, sensors, systemBus);
++                if (sensors.empty())
++                {
++                    std::cout << "Configuration not detected\n";
++                }
++            });
++        };
++
++    sdbusplus::bus::match::match configMatch(
++        static_cast<sdbusplus::bus::bus&>(*systemBus),
++        "type='signal',member='PropertiesChanged',"
++        "path_namespace='" +
++            std::string(inventoryPath) +
++            "',"
++            "arg0namespace='" +
++            configInterface + "'",
++        eventHandler);
++
++    io.run();
++}
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0033-Modify-MNVMe-sensor-debug-message-with-using-debug-f.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0033-Modify-MNVMe-sensor-debug-message-with-using-debug-f.patch
new file mode 100755
index 0000000..79594b8
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0033-Modify-MNVMe-sensor-debug-message-with-using-debug-f.patch
@@ -0,0 +1,28 @@
+From 86b3c8e66f6f3d65aac3058d8400e0a7f44a0fa8 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Fri, 10 Apr 2020 10:29:22 +0800
+Subject: [PATCH] Modify MNVMe sensor debug message with using debug flag
+
+---
+ src/MNVMeSensor.cpp | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+diff --git a/src/MNVMeSensor.cpp b/src/MNVMeSensor.cpp
+index 2cccd93..b9e4196 100755
+--- a/src/MNVMeSensor.cpp
++++ b/src/MNVMeSensor.cpp
+@@ -211,7 +211,10 @@ int NVMeSensor::getNVMeTemp(uint8_t* pu8data)
+ 
+     if (res < 0)
+     {
+-        std::cerr << "Error: block write read failed\n";
++        if constexpr (debug)
++        {
++            std::cerr << "Error: block write read failed\n";
++        }
+ 		close(fd);
+ 		return -1;
+     }
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0034-Fix-cpu-senor-data-update-error-after-code-base-upda.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0034-Fix-cpu-senor-data-update-error-after-code-base-upda.patch
new file mode 100755
index 0000000..4cd216c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0034-Fix-cpu-senor-data-update-error-after-code-base-upda.patch
@@ -0,0 +1,48 @@
+From 9c1502f552f64391b2af7e9e2e6c17fe9dfeb12d Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 4 May 2020 14:56:17 +0800
+Subject: [PATCH] Fix cpu senor data update error after code base update
+
+---
+ src/CPUSensor.cpp | 21 ++-------------------
+ 1 file changed, 2 insertions(+), 19 deletions(-)
+ mode change 100644 => 100755 src/CPUSensor.cpp
+
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+old mode 100644
+new mode 100755
+index c41177a..095fac9
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -190,26 +190,9 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+ 
+                 if (!thresholds.empty())
+                 {
+-                    std::vector<thresholds::Threshold> newThresholds;
+-                    if (parseThresholdsFromAttr(newThresholds, path,
+-                                                CPUSensor::sensorScaleFactor,
+-                                                dtsOffset))
++                    if (show)
+                     {
+-                        if (!std::equal(thresholds.begin(), thresholds.end(),
+-                                        newThresholds.begin(),
+-                                        newThresholds.end()))
+-                        {
+-                            thresholds = newThresholds;
+-                            if (show)
+-                            {
+-                                thresholds::updateThresholds(this);
+-                            }
+-                        }
+-                    }
+-                    else
+-                    {
+-                        std::cerr << "Failure to update thresholds for " << name
+-                                  << "\n";
++                        thresholds::updateThresholds(this);
+                     }
+                 }
+             }
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0035-Fix-CPU-DTS-margin-reading-incorrect.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0035-Fix-CPU-DTS-margin-reading-incorrect.patch
new file mode 100755
index 0000000..ce45934
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0035-Fix-CPU-DTS-margin-reading-incorrect.patch
@@ -0,0 +1,70 @@
+From 839565035be24990746aba5f1ca8ea81b0cbc97a Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Wed, 6 May 2020 15:03:20 +0800
+Subject: [PATCH] Fix CPU DTS margin reading incorrect
+
+---
+ include/CPUSensor.hpp |  3 ++-
+ src/CPUSensor.cpp     | 23 +++++++++++++++++------
+ 2 files changed, 19 insertions(+), 7 deletions(-)
+
+diff --git a/include/CPUSensor.hpp b/include/CPUSensor.hpp
+index 18312ee..26bc80e 100755
+--- a/include/CPUSensor.hpp
++++ b/include/CPUSensor.hpp
+@@ -31,7 +31,8 @@ class CPUSensor : public Sensor
+     static constexpr size_t warnAfterErrorCount = 10;
+     //static constexpr double maxReading = 127;
+     //static constexpr double minReading = -128;
+-    static double DieTemp;
++    static double DieTemp0;
++    static double DieTemp1;
+     static constexpr const char* labelTcontrol = "Tcontrol";
+ 
+   private:
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+index 095fac9..b0719bd 100755
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -33,7 +33,8 @@
+ #include <string>
+ #include <vector>
+ 
+-double CPUSensor::DieTemp=0;
++double CPUSensor::DieTemp0=0;
++double CPUSensor::DieTemp1=0;
+ 
+ CPUSensor::CPUSensor(const std::string& path, const std::string& objectType,
+                      sdbusplus::asio::object_server& objectServer,
+@@ -167,16 +168,26 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+ 
+             updateValueInvalid(false);
+ 
+-            auto findCpu = path.find("peci-cputemp");
++            auto findCpu0 = path.find("peci-cputemp.0");
++            auto findCpu1 = path.find("peci-cputemp.1");
+             auto findDie = path.find("temp1");
+             auto findMargin = path.find("temp5");
+-            if ((findCpu != std::string::npos) && (findDie != std::string::npos))
++            if ((findCpu0 != std::string::npos) && (findDie != std::string::npos))
+             {
+-                CPUSensor::DieTemp = nvalue;
++                CPUSensor::DieTemp0 = nvalue;
+             }
+-            else if ((findCpu != std::string::npos) && (findMargin != std::string::npos))
++            else if ((findCpu1 != std::string::npos) && (findDie != std::string::npos))
+             {
+-                nvalue = CPUSensor::DieTemp - nvalue;
++                CPUSensor::DieTemp1 = nvalue;
++            }
++            else if ((findCpu0 != std::string::npos) && (findMargin != std::string::npos))
++            {
++                nvalue = CPUSensor::DieTemp0 - nvalue;
++                updateValue(nvalue);
++            }
++            else if ((findCpu1 != std::string::npos) && (findMargin != std::string::npos))
++            {
++                nvalue = CPUSensor::DieTemp1 - nvalue;
+                 updateValue(nvalue);
+             }
+ 
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0036-Fix-sensor-hysteresis-issue.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0036-Fix-sensor-hysteresis-issue.patch
new file mode 100755
index 0000000..072adb0
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0036-Fix-sensor-hysteresis-issue.patch
@@ -0,0 +1,124 @@
+From d51b4ccbb23b64610d913e54c9ca77fa4384401e Mon Sep 17 00:00:00 2001
+From: Varun Sampat <vsampat@twitter.com>
+Date: Tue, 12 May 2020 20:24:34 -0400
+Subject: [PATCH] Fix sensor hysteresis issue
+
+---
+ include/HwmonTempSensor.hpp |  4 +++-
+ include/sensor.hpp          |  8 +++++++-
+ src/HwmonTempMain.cpp       | 13 +++++++++++--
+ src/HwmonTempSensor.cpp     |  5 +++--
+ 4 files changed, 24 insertions(+), 6 deletions(-)
+
+diff --git a/include/HwmonTempSensor.hpp b/include/HwmonTempSensor.hpp
+index a91a82d..a34cd5c 100755
+--- a/include/HwmonTempSensor.hpp
++++ b/include/HwmonTempSensor.hpp
+@@ -16,7 +16,8 @@ class HwmonTempSensor : public Sensor
+                     boost::asio::io_service& io, const std::string& fanName,
+                     std::vector<thresholds::Threshold>&& thresholds,
+                     const std::string& sensorConfiguration,
+-                    const PowerState powerState);
++                    const PowerState powerState,
++                    const double hysteresisVal);
+     ~HwmonTempSensor();
+ 
+   private:
+@@ -26,6 +27,7 @@ class HwmonTempSensor : public Sensor
+     boost::asio::streambuf readBuf;
+     std::string path;
+     PowerState readState;
++    double hysteresisVal;
+     thresholds::ThresholdTimer thresholdTimer;
+     size_t errCount;
+     void setupRead(void);
+diff --git a/include/sensor.hpp b/include/sensor.hpp
+index 68ae108..1e41525 100755
+--- a/include/sensor.hpp
++++ b/include/sensor.hpp
+@@ -20,7 +20,7 @@ struct Sensor
+         name(name),
+         configurationPath(configurationPath), objectType(objectType),
+         maxValue(max), minValue(min), thresholds(std::move(thresholdData)),
+-        hysteresisTrigger((max - min) * 0.01),
++        hysteresisTrigger(0),
+         hysteresisPublish((max - min) * 0.0001)
+     {
+     }
+@@ -228,4 +228,10 @@ struct Sensor
+             sensorInterface->set_property("InvalidValue", newState);
+         }
+     }
++
++    void updateHysteresis(const double& HysteresisValue)
++    {
++       hysteresisTrigger = HysteresisValue;
++    }
++
+ };
+diff --git a/src/HwmonTempMain.cpp b/src/HwmonTempMain.cpp
+index 1472b4e..0e9b2cb 100755
+--- a/src/HwmonTempMain.cpp
++++ b/src/HwmonTempMain.cpp
+@@ -210,6 +210,15 @@ void createSensors(
+                         VariantToStringVisitor(), findPowerOn->second);
+                     setReadState(powerState, readState);
+                 }
++                
++                float hysteresisVal = 0;
++                auto findHysteresisVal =
++                    baseConfiguration->second.find("HysteresisVal");
++                if (findHysteresisVal != baseConfiguration->second.end())
++                {
++                    hysteresisVal = std::visit(VariantToFloatVisitor(),
++                                             findHysteresisVal->second);
++                }
+ 
+                 if (deviceName != "14-001f"){
+                     auto& sensor = sensors[sensorName];
+@@ -217,7 +226,7 @@ void createSensors(
+                     sensor = std::make_unique<HwmonTempSensor>(
+                             directory.string() + "/temp1_input", sensorType,
+                             objectServer, dbusConnection, io, sensorName,
+-                            std::move(sensorThresholds), *interfacePath, readState);
++                            std::move(sensorThresholds), *interfacePath, readState, hysteresisVal);
+                 }
+ 
+                 // Looking for keys like "Name1" for temp2_input,
+@@ -249,7 +258,7 @@ void createSensors(
+                             "_input",
+                         sensorType, objectServer, dbusConnection, io,
+                         sensorName, std::move(sensorThresholds),
+-                        *interfacePath, readState);
++                        *interfacePath, readState, hysteresisVal);
+                 }
+             }
+         }));
+diff --git a/src/HwmonTempSensor.cpp b/src/HwmonTempSensor.cpp
+index 2af0ba4..f322a6c 100755
+--- a/src/HwmonTempSensor.cpp
++++ b/src/HwmonTempSensor.cpp
+@@ -43,13 +43,13 @@ HwmonTempSensor::HwmonTempSensor(
+     std::shared_ptr<sdbusplus::asio::connection>& conn,
+     boost::asio::io_service& io, const std::string& sensorName,
+     std::vector<thresholds::Threshold>&& _thresholds,
+-    const std::string& sensorConfiguration, PowerState readState) :
++    const std::string& sensorConfiguration, PowerState readState, const double hysteresisVal) :
+     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
+            std::move(_thresholds), sensorConfiguration, objectType, maxReading,
+            minReading),
+     objServer(objectServer), inputDev(io, open(path.c_str(), O_RDONLY)),
+     waitTimer(io), path(path), errCount(0), readState(std::move(readState)),
+-    thresholdTimer(io, this)
++    thresholdTimer(io, this), hysteresisVal(hysteresisVal)
+ {
+     sensorInterface = objectServer.add_interface(
+         "/xyz/openbmc_project/sensors/temperature/" + name,
+@@ -73,6 +73,7 @@ HwmonTempSensor::HwmonTempSensor(
+     setInitialProperties(conn);
+     setupPowerMatch(conn);
+     setupRead();
++    updateHysteresis(hysteresisVal);
+ }
+ 
+ HwmonTempSensor::~HwmonTempSensor()
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0037-Fix-cpu-sensor-hang-and-get-power-status-error.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0037-Fix-cpu-sensor-hang-and-get-power-status-error.patch
new file mode 100755
index 0000000..de64759
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0037-Fix-cpu-sensor-hang-and-get-power-status-error.patch
@@ -0,0 +1,179 @@
+From db18c54ac588ba6053389b2eb7bcf0d1bfeca5bb Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 18 May 2020 10:04:00 +0800
+Subject: [PATCH] Fix cpu sensor hang and get power status error
+
+Change cpu sensor read function to non-blocking
+Create a function to direct access power status in dbus
+---
+ include/CPUSensor.hpp |  2 ++
+ include/Utils.hpp     |  1 +
+ src/CPUSensor.cpp     | 45 +++++++++++++++++++++++++++++----------------
+ src/Utils.cpp         | 21 +++++++++++++++++++++
+ 4 files changed, 53 insertions(+), 16 deletions(-)
+
+diff --git a/include/CPUSensor.hpp b/include/CPUSensor.hpp
+index 26bc80e..c27eccf 100755
+--- a/include/CPUSensor.hpp
++++ b/include/CPUSensor.hpp
+@@ -34,12 +34,14 @@ class CPUSensor : public Sensor
+     static double DieTemp0;
+     static double DieTemp1;
+     static constexpr const char* labelTcontrol = "Tcontrol";
++    static constexpr const double sensorDisable = 0;
+ 
+   private:
+     sdbusplus::asio::object_server& objServer;
+     boost::asio::posix::stream_descriptor inputDev;
+     boost::asio::deadline_timer waitTimer;
+     boost::asio::streambuf readBuf;
++    std::shared_ptr<sdbusplus::asio::connection> connCPURead;
+     std::string nameTcontrol;
+     std::string path;
+     double privTcontrol;
+diff --git a/include/Utils.hpp b/include/Utils.hpp
+index f5fd33d..92efbe3 100755
+--- a/include/Utils.hpp
++++ b/include/Utils.hpp
+@@ -46,6 +46,7 @@ bool findFiles(const std::filesystem::path dirPath,
+                unsigned int symlinkDepth = 1);
+ bool isPowerOn(void);
+ bool hasBiosPost(void);
++bool getPowerStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn);
+ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn);
+ bool getSensorConfiguration(
+     const std::string& type,
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+index b0719bd..9747ce5 100755
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -79,6 +79,7 @@ CPUSensor::CPUSensor(const std::string& path, const std::string& objectType,
+         setInitialProperties(conn);
+     }
+     setupPowerMatch(conn);
++    connCPURead = conn;
+     setupRead();
+ }
+ 
+@@ -98,10 +99,10 @@ CPUSensor::~CPUSensor()
+ 
+ void CPUSensor::setupRead(void)
+ {
+-    boost::asio::async_read_until(
+-        inputDev, readBuf, '\n',
+-        [&](const boost::system::error_code& ec,
+-            std::size_t /*bytes_transfered*/) { handleResponse(ec); });
++    boost::system::error_code ec;
++    inputDev.non_blocking(true);
++    boost::asio::read_until(inputDev, readBuf, '\n', ec);
++    handleResponse(ec);
+ }
+ 
+ void CPUSensor::handleResponse(const boost::system::error_code& err)
+@@ -113,17 +114,22 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+     }
+     size_t pollTime = CPUSensor::sensorPollMs;
+ 
++    getPowerStatus(connCPURead);
++
+     // Set as sensor reading invalid for cup peci sensors
+     if (!isPowerOn())
+     {
+         updateValueInvalid(true);
+         errCount = 0;
+ 
+-        // clear response buffer reading
+-        std::istream invalidResponseStream(&readBuf);
+-        std::string invalidResponse;
+-        std::getline(invalidResponseStream, invalidResponse);
+-        invalidResponseStream.clear();
++        if(err != boost::system::errc::resource_unavailable_try_again)
++        {
++            // clear response buffer reading
++            std::istream invalidResponseStream(&readBuf);
++            std::string invalidResponse;
++            std::getline(invalidResponseStream, invalidResponse);
++            invalidResponseStream.clear();
++        }
+ 
+         inputDev.close();
+         int fd = open(path.c_str(), O_RDONLY);
+@@ -154,15 +160,22 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+             double nvalue = std::stof(response);
+             responseStream.clear();
+             nvalue /= CPUSensor::sensorScaleFactor;
+-            if (nvalue != value)
++            if (nvalue == sensorDisable)
+             {
+-                if (show)
+-                {
+-                    updateValue(nvalue);
+-                }
+-                else
++                updateValueInvalid(true);
++            }
++            else
++            {
++                if (nvalue != value)
+                 {
+-                    value = nvalue;
++                    if (show)
++                    {
++                        updateValue(nvalue);
++                    }
++                    else
++                    {
++                        value = nvalue;
++                    }
+                 }
+             }
+ 
+diff --git a/src/Utils.cpp b/src/Utils.cpp
+index a46265c..9e54185 100755
+--- a/src/Utils.cpp
++++ b/src/Utils.cpp
+@@ -136,6 +136,25 @@ bool hasBiosPost(void)
+     return biosHasPost;
+ }
+ 
++bool getPowerStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn)
++{
++    conn->async_method_call(
++        [](boost::system::error_code ec,
++           const std::variant<int>& state) {
++            if (ec)
++            {
++                // we commonly come up before power control, we'll capture the
++                // property change later
++                return;
++            }
++            powerStatusOn = (1 == (std::get<int>(state))) ? true : false;
++        },
++        power::busname, power::path, properties::interface, properties::get,
++        power::interface, power::property);
++
++    return powerStatusOn;
++}
++
+ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
+ {
+     static boost::asio::steady_timer timer(conn->get_io_context());
+@@ -208,6 +227,7 @@ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
+             {
+                 // we commonly come up before power control, we'll capture the
+                 // property change later
++                std::cerr << "Get power method error" << ec.message() << std::endl;
+                 return;
+             }
+             powerStatusOn = (1 == (std::get<int>(state))) ? true : false;
+@@ -222,6 +242,7 @@ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
+             {
+                 // we commonly come up before power control, we'll capture the
+                 // property change later
++                std::cerr << "Get bios has post method error" << ec.message() << std::endl;
+                 return;
+             }
+             biosHasPost = std::get<std::string>(state) != "Inactive";
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0038-Add-watchdog2-and-power-control-event-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0038-Add-watchdog2-and-power-control-event-sensor.patch
new file mode 100755
index 0000000..5b6c276
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0038-Add-watchdog2-and-power-control-event-sensor.patch
@@ -0,0 +1,30 @@
+From f62fe8ed92fc69dfcfaf7e0ab366e6413eb7b2b4 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 20 May 2020 17:32:19 +0800
+Subject: [PATCH] Add watchdog2 and power control event sensor
+
+---
+ src/eventSensor.cpp | 3 ++-
+ 1 file changed, 6 insertions(+), 1 deletion(-)
+
+diff --git a/src/eventSensor.cpp b/src/eventSensor.cpp
+index b99396d..7946cd5 100755
+--- a/src/eventSensor.cpp
++++ b/src/eventSensor.cpp
+@@ -41,7 +41,12 @@ const static boost::container::flat_map<std::string, std::string>eventsensors
+         {"BMC_FW_UPDATE","versionchange"}, 
+         {"BMC_Reboot","mgtsubsyshealth"},    
+         {"PSU_STATUS","power_supply"}, 
+-        {"IPMI_POWER_CYCLE","fru_state"}    
++        {"IPMI_POWER_CYCLE","fru_state"},
++        {"IPMI_POWER_ON","fru_state"},
++        {"IPMI_POWER_OFF","fru_state"},
++        {"IPMI_POWER_SOFT","fru_state"},
++        {"IPMI_POWER_RESET","fru_state"},
++        {"WATCHDOG2","watchdog2"}
+     };
+ 
+ struct eventSensor 
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0039-Add-DCMI-power-event-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0039-Add-DCMI-power-event-sensor.patch
new file mode 100755
index 0000000..f60af2b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0039-Add-DCMI-power-event-sensor.patch
@@ -0,0 +1,26 @@
+From 83831689006eab6e6d566da51f9a3822f85ace03 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Fri, 29 May 2020 13:59:29 +0800
+Subject: [PATCH] Add DCMI power event sensor
+
+---
+ src/eventSensor.cpp | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/src/eventSensor.cpp b/src/eventSensor.cpp
+index 3afe87b..da34f2a 100755
+--- a/src/eventSensor.cpp
++++ b/src/eventSensor.cpp
+@@ -40,7 +40,8 @@ const static boost::container::flat_map<std::string, std::string>eventsensors
+         {"BUTTON","pwr_button"},  
+         {"BMC_FW_UPDATE","versionchange"}, 
+         {"BMC_Reboot","mgtsubsyshealth"},    
+-        {"PSU_STATUS","power_supply"}, 
++        {"PSU_STATUS","power_supply"},
++        {"DCMI_POWER_LIMIT","power_supply"},
+         {"IPMI_POWER_CYCLE","fru_state"},
+         {"IPMI_POWER_ON","fru_state"},
+         {"IPMI_POWER_OFF","fru_state"},
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0040-change-ADC-range-to-be-configurable.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0040-change-ADC-range-to-be-configurable.patch
new file mode 100755
index 0000000..25c7cea
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0040-change-ADC-range-to-be-configurable.patch
@@ -0,0 +1,80 @@
+From 3acbb09c71569900488826cc3a00c0c66d126878 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Mon, 15 Jun 2020 15:56:42 +0800
+Subject: [PATCH 1/1] change ADC range to be configurable
+
+---
+ include/ADCSensor.hpp |  3 ++-
+ src/ADCSensor.cpp     |  5 +++--
+ src/ADCSensorMain.cpp | 10 +++++++++-
+ 3 files changed, 14 insertions(+), 4 deletions(-)
+ mode change 100644 => 100755 include/ADCSensor.hpp
+ mode change 100644 => 100755 src/ADCSensorMain.cpp
+
+diff --git a/include/ADCSensor.hpp b/include/ADCSensor.hpp
+old mode 100644
+new mode 100755
+index dfd8713..acf4664
+--- a/include/ADCSensor.hpp
++++ b/include/ADCSensor.hpp
+@@ -60,7 +60,8 @@ class ADCSensor : public Sensor
+               std::vector<thresholds::Threshold>&& thresholds,
+               const double scaleFactor, PowerState readState,
+               const std::string& sensorConfiguration,
+-              std::optional<BridgeGpio>&& bridgeGpio);
++              std::optional<BridgeGpio>&& bridgeGpio,
++              const std::pair<size_t, size_t>& limits);
+     ~ADCSensor();
+ 
+   private:
+diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
+index df7ca52..f941a73 100755
+--- a/src/ADCSensor.cpp
++++ b/src/ADCSensor.cpp
+@@ -50,10 +50,11 @@ ADCSensor::ADCSensor(const std::string& path,
+                      std::vector<thresholds::Threshold>&& _thresholds,
+                      const double scaleFactor, PowerState readState,
+                      const std::string& sensorConfiguration,
+-                     std::optional<BridgeGpio>&& bridgeGpio) :
++                     std::optional<BridgeGpio>&& bridgeGpio,
++                     const std::pair<size_t, size_t>& limits) :
+     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
+            std::move(_thresholds), sensorConfiguration,
+-           "xyz.openbmc_project.Configuration.ADC", maxReading, minReading),
++           "xyz.openbmc_project.Configuration.ADC",limits.second, limits.first),
+     objServer(objectServer), inputDev(io, open(path.c_str(), O_RDONLY)),
+     waitTimer(io), path(path), errCount(0), scaleFactor(scaleFactor),
+     bridgeGpio(std::move(bridgeGpio)), readState(std::move(readState)),
+diff --git a/src/ADCSensorMain.cpp b/src/ADCSensorMain.cpp
+old mode 100644
+new mode 100755
+index 1b56d93..1679946
+--- a/src/ADCSensorMain.cpp
++++ b/src/ADCSensorMain.cpp
+@@ -235,6 +235,14 @@ void createSensors(
+                     }
+                 }
+ 
++                constexpr double defaultMaxReading = 20;
++                constexpr double defaultMinReading = 0;
++                auto limits =
++                std::make_pair(defaultMinReading, defaultMaxReading);
++
++                findLimits(limits, baseConfiguration);
++                
++
+                 auto& sensor = sensors[sensorName];
+                 sensor = nullptr;
+ 
+@@ -272,7 +280,7 @@ void createSensors(
+                 sensor = std::make_unique<ADCSensor>(
+                     path.string(), objectServer, dbusConnection, io, sensorName,
+                     std::move(sensorThresholds), scaleFactor, readState,
+-                    *interfacePath, std::move(bridgeGpio));
++                    *interfacePath, std::move(bridgeGpio), limits);
+             }
+         }));
+ 
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0041-add-assert-value-to-log-event-data.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0041-add-assert-value-to-log-event-data.patch
new file mode 100755
index 0000000..de4d884
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0041-add-assert-value-to-log-event-data.patch
@@ -0,0 +1,71 @@
+From 52c6229cebe77257bc12150630c475aa0c9a2e61 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 16 Jun 2020 10:31:28 +0800
+Subject: [PATCH 1/1] add assert value to log event data
+
+---
+ include/sensor.hpp |  3 +++
+ src/Thresholds.cpp | 13 ++++++++++++-
+ 2 files changed, 15 insertions(+), 1 deletion(-)
+ mode change 100644 => 100755 src/Thresholds.cpp
+
+diff --git a/include/sensor.hpp b/include/sensor.hpp
+index 1e41525..bd9c3ef 100755
+--- a/include/sensor.hpp
++++ b/include/sensor.hpp
+@@ -83,6 +83,9 @@ struct Sensor
+             "InvalidValue", invalidValue, [&](const bool& newState, bool& oldState) {
+                 return setSensorValueInvalid(newState, oldState);
+             });
++        
++        sensorInterface->register_property("ValueAssert", maxValue);
++        sensorInterface->register_property("ValueDeassert", minValue);
+ 
+         for (auto& threshold : thresholds)
+         {
+diff --git a/src/Thresholds.cpp b/src/Thresholds.cpp
+old mode 100644
+new mode 100755
+index 0b33829..c6bec8b
+--- a/src/Thresholds.cpp
++++ b/src/Thresholds.cpp
+@@ -303,10 +303,16 @@ static std::vector<std::pair<Threshold, bool>> checkThresholds(Sensor* sensor,
+ bool checkThresholds(Sensor* sensor)
+ {
+     bool status = true;
++    bool needToUpdate = true;
+     std::vector<std::pair<Threshold, bool>> changes =
+         checkThresholds(sensor, sensor->value);
+     for (const auto& [threshold, asserted] : changes)
+     {
++        if(asserted && needToUpdate)
++        {
++            needToUpdate = false;
++            (sensor->sensorInterface)->set_property("ValueAssert", sensor->value);
++        }
+         assertThresholds(sensor, threshold.level, threshold.direction,
+                          asserted);
+         if (threshold.level == thresholds::Level::CRITICAL && asserted)
+@@ -320,13 +326,18 @@ bool checkThresholds(Sensor* sensor)
+ 
+ void checkThresholdsPowerDelay(Sensor* sensor, ThresholdTimer& thresholdTimer)
+ {
+-
++    bool needToUpdate = true;
+     std::vector<std::pair<Threshold, bool>> changes =
+         checkThresholds(sensor, sensor->value);
+     for (const auto& [threshold, asserted] : changes)
+     {
+         if (asserted)
+         {
++            if(needToUpdate)
++            {
++                needToUpdate = false;
++                (sensor->sensorInterface)->set_property("ValueAssert", sensor->value);    
++            } 
+             thresholdTimer.startTimer(threshold);
+         }
+         else
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0042-Stop-the-timer-when-the-deasserted-events-occur.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0042-Stop-the-timer-when-the-deasserted-events-occur.patch
new file mode 100755
index 0000000..f40533b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0042-Stop-the-timer-when-the-deasserted-events-occur.patch
@@ -0,0 +1,106 @@
+From 92ed8f07f0b5a30034017ca75b1ef6da36942824 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 16 Jun 2020 11:07:16 +0800
+Subject: [PATCH 1/1] Stop the timer when the deasserted events occur
+
+---
+ include/Thresholds.hpp | 42 +++++++++++++++++++++++++++++++++++++-----
+ src/Thresholds.cpp     |  1 +
+ 2 files changed, 38 insertions(+), 5 deletions(-)
+ mode change 100644 => 100755 include/Thresholds.hpp
+
+diff --git a/include/Thresholds.hpp b/include/Thresholds.hpp
+old mode 100644
+new mode 100755
+index 00df68c..59aa58a
+--- a/include/Thresholds.hpp
++++ b/include/Thresholds.hpp
+@@ -45,7 +45,15 @@ struct Threshold
+ void assertThresholds(Sensor* sensor, thresholds::Level level,
+                       thresholds::Direction direction, bool assert);
+ 
+-using TimerPair = std::pair<bool, boost::asio::deadline_timer>;
++struct TimerUsed
++{
++    bool used;
++    Level level;
++    Direction direction;
++};
++
++using TimerPair = std::pair<struct TimerUsed, boost::asio::deadline_timer>;
++
+ 
+ struct ThresholdTimer
+ {
+@@ -55,14 +63,32 @@ struct ThresholdTimer
+     {
+     }
+ 
++    void stopTimer(const Threshold& threshold)
++        {
++            struct TimerUsed timerUsed = {};
++            for (TimerPair& timer : timers)
++            {
++                timerUsed = timer.first;
++                if (timerUsed.used)
++                {
++                    if ((timerUsed.level == threshold.level) &&
++                        (timerUsed.direction == threshold.direction))
++                    {
++                        timer.second.cancel();
++                    }
++                }
++            }
++        }
++
+     void startTimer(const Threshold& threshold)
+     {
++        struct TimerUsed timerUsed = {};
+         constexpr const size_t waitTime = 5;
+         TimerPair* pair = nullptr;
+ 
+         for (TimerPair& timer : timers)
+         {
+-            if (!timer.first)
++            if (!timer.first.used)
+             {
+                 pair = &timer;
+                 break;
+@@ -70,13 +96,19 @@ struct ThresholdTimer
+         }
+         if (pair == nullptr)
+         {
+-            pair = &timers.emplace_back(false, boost::asio::deadline_timer(io));
++            pair = &timers.emplace_back(timerUsed,
++                                        boost::asio::deadline_timer(io));
++
+         }
+-        pair->first = true;
++        pair->first.used = true;
++        pair->first.level = threshold.level;
++        pair->first.direction = threshold.direction;
++
+         pair->second.expires_from_now(boost::posix_time::seconds(waitTime));
+         pair->second.async_wait(
+             [this, pair, threshold](boost::system::error_code ec) {
+-                pair->first = false;
++                pair->first.used = false;
++
+ 
+                 if (ec == boost::asio::error::operation_aborted)
+                 {
+diff --git a/src/Thresholds.cpp b/src/Thresholds.cpp
+index c6bec8b..1fc1e8e 100755
+--- a/src/Thresholds.cpp
++++ b/src/Thresholds.cpp
+@@ -342,6 +342,7 @@ void checkThresholdsPowerDelay(Sensor* sensor, ThresholdTimer& thresholdTimer)
+         }
+         else
+         {
++            thresholdTimer.stopTimer(threshold);
+             assertThresholds(sensor, threshold.level, threshold.direction,
+                              false);
+         }
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0043-add-offset-value-for-E810-OCP-card.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0043-add-offset-value-for-E810-OCP-card.patch
new file mode 100755
index 0000000..87c186b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0043-add-offset-value-for-E810-OCP-card.patch
@@ -0,0 +1,118 @@
+From fe1e1cd8578250d547319809a486497c89b76226 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Wed, 17 Jun 2020 10:07:36 +0800
+Subject: [PATCH] add offset value for E810 OCP card
+
+---
+ include/HwmonTempSensor.hpp |  4 +++-
+ src/HwmonTempMain.cpp       | 12 ++++++++++--
+ src/HwmonTempSensor.cpp     | 26 ++++++++++++++++++++++++--
+ 3 files changed, 37 insertions(+), 5 deletions(-)
+
+diff --git a/include/HwmonTempSensor.hpp b/include/HwmonTempSensor.hpp
+index a34cd5c..0f159bc 100755
+--- a/include/HwmonTempSensor.hpp
++++ b/include/HwmonTempSensor.hpp
+@@ -17,7 +17,8 @@ class HwmonTempSensor : public Sensor
+                     std::vector<thresholds::Threshold>&& thresholds,
+                     const std::string& sensorConfiguration,
+                     const PowerState powerState,
+-                    const double hysteresisVal);
++                    const double hysteresisVal,
++                    const double offsetValue);
+     ~HwmonTempSensor();
+ 
+   private:
+@@ -28,6 +29,7 @@ class HwmonTempSensor : public Sensor
+     std::string path;
+     PowerState readState;
+     double hysteresisVal;
++    double offsetValue;
+     thresholds::ThresholdTimer thresholdTimer;
+     size_t errCount;
+     void setupRead(void);
+diff --git a/src/HwmonTempMain.cpp b/src/HwmonTempMain.cpp
+index 0e9b2cb..353803d 100755
+--- a/src/HwmonTempMain.cpp
++++ b/src/HwmonTempMain.cpp
+@@ -220,13 +220,21 @@ void createSensors(
+                                              findHysteresisVal->second);
+                 }
+ 
++                float offsetValue = 0;
++                auto findOffsetValue = baseConfiguration->second.find("OffsetValue");
++                if (findOffsetValue != baseConfiguration->second.end())
++                {
++                    offsetValue = std::visit(VariantToFloatVisitor(),
++                                             findOffsetValue->second);
++                }
++
+                 if (deviceName != "14-001f"){
+                     auto& sensor = sensors[sensorName];
+                     sensor = nullptr;
+                     sensor = std::make_unique<HwmonTempSensor>(
+                             directory.string() + "/temp1_input", sensorType,
+                             objectServer, dbusConnection, io, sensorName,
+-                            std::move(sensorThresholds), *interfacePath, readState, hysteresisVal);
++                            std::move(sensorThresholds), *interfacePath, readState, hysteresisVal, offsetValue);
+                 }
+ 
+                 // Looking for keys like "Name1" for temp2_input,
+@@ -258,7 +266,7 @@ void createSensors(
+                             "_input",
+                         sensorType, objectServer, dbusConnection, io,
+                         sensorName, std::move(sensorThresholds),
+-                        *interfacePath, readState, hysteresisVal);
++                        *interfacePath, readState, hysteresisVal, offsetValue);
+                 }
+             }
+         }));
+diff --git a/src/HwmonTempSensor.cpp b/src/HwmonTempSensor.cpp
+index f322a6c..3453fb2 100755
+--- a/src/HwmonTempSensor.cpp
++++ b/src/HwmonTempSensor.cpp
+@@ -43,13 +43,14 @@ HwmonTempSensor::HwmonTempSensor(
+     std::shared_ptr<sdbusplus::asio::connection>& conn,
+     boost::asio::io_service& io, const std::string& sensorName,
+     std::vector<thresholds::Threshold>&& _thresholds,
+-    const std::string& sensorConfiguration, PowerState readState, const double hysteresisVal) :
++    const std::string& sensorConfiguration, PowerState readState, const double hysteresisVal,
++    const double offsetValue) :
+     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
+            std::move(_thresholds), sensorConfiguration, objectType, maxReading,
+            minReading),
+     objServer(objectServer), inputDev(io, open(path.c_str(), O_RDONLY)),
+     waitTimer(io), path(path), errCount(0), readState(std::move(readState)),
+-    thresholdTimer(io, this), hysteresisVal(hysteresisVal)
++    thresholdTimer(io, this), hysteresisVal(hysteresisVal), offsetValue(offsetValue)
+ {
+     sensorInterface = objectServer.add_interface(
+         "/xyz/openbmc_project/sensors/temperature/" + name,
+@@ -143,6 +144,27 @@ void HwmonTempSensor::handleResponse(const boost::system::error_code& err)
+         {
+             float nvalue = std::stof(response);
+             nvalue /= sensorScaleFactor;
++
++            if (name == "NIC_Temp")
++            {
++                // Check OCP card status
++                char tmp[100];
++                uint8_t currentStatus;
++
++                int fdt, size;
++                char buffer[100];
++                fdt = open("/usr/sbin/ocpCard", O_RDONLY);
++                size = read(fdt, buffer, sizeof(buffer));
++                close(fdt);
++                currentStatus = strtol(buffer,NULL,16);
++
++                if ((int)currentStatus == 1)
++                {
++                    //count OCP temp reading + offset
++                    nvalue = nvalue + offsetValue;
++                }
++            }
++
+             if (static_cast<double>(nvalue) != value)
+             {
+                 updateValue(nvalue);
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0044-log-assert-event-when-timer-cancelled.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0044-log-assert-event-when-timer-cancelled.patch
new file mode 100755
index 0000000..87f8698
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0044-log-assert-event-when-timer-cancelled.patch
@@ -0,0 +1,28 @@
+From bdddc5d8c4d49d20c142a150face043fe1ebc3c2 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Fri, 3 Jul 2020 17:59:21 +0800
+Subject: [PATCH 1/1] log assert event when timer cancelled
+
+---
+ include/Thresholds.hpp | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/include/Thresholds.hpp b/include/Thresholds.hpp
+index 59aa58a..29c7a49 100755
+--- a/include/Thresholds.hpp
++++ b/include/Thresholds.hpp
+@@ -75,6 +75,11 @@ struct ThresholdTimer
+                         (timerUsed.direction == threshold.direction))
+                     {
+                         timer.second.cancel();
++                        if (isPowerOn())
++                        {
++                            assertThresholds(sensor, threshold.level,
++                                    threshold.direction, true);
++                        }
+                     }
+                 }
+             }
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0045-filter-out-invalidate-ADC-value.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0045-filter-out-invalidate-ADC-value.patch
new file mode 100755
index 0000000..3724dd7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0045-filter-out-invalidate-ADC-value.patch
@@ -0,0 +1,36 @@
+From 9618237f380410ea548710ef23fd5fd5856c4966 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Tue, 21 Jul 2020 18:29:19 +0800
+Subject: [PATCH 1/1] filter out invalidate ADC value
+
+---
+ src/ADCSensor.cpp | 11 +++++++++--
+ 1 file changed, 9 insertions(+), 2 deletions(-)
+
+diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
+index f941a73..0be500f 100755
+--- a/src/ADCSensor.cpp
++++ b/src/ADCSensor.cpp
+@@ -177,10 +177,17 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
+         {
+             double nvalue = std::stof(response);
+ 
++            //debug only: need to investigate driver if any data exceed 1.8V reported  
++            double rawValue  = nvalue;
++            if(rawValue >= 1790) 
++            {
++                std::cerr << "rawValue:" <<rawValue << "\n";
++            }
++
+             nvalue = (nvalue / sensorScaleFactor) / scaleFactor;
+             nvalue = std::round(nvalue * roundFactor) / roundFactor;
+-
+-            if (nvalue != value)
++                
++            if ((nvalue != value) && (rawValue <= 1790))
+             {
+                 updateValue(nvalue);
+             }
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0046-add-BMC-watchdog-timeout-SEL.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0046-add-BMC-watchdog-timeout-SEL.patch
new file mode 100755
index 0000000..0537673
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0046-add-BMC-watchdog-timeout-SEL.patch
@@ -0,0 +1,90 @@
+From 01928720a02da2b29e66cac918f3a9c91b6d2273 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Fri, 24 Jul 2020 18:09:23 +0800
+Subject: [PATCH 1/1] add BMC watchdog timeout SEL
+
+---
+ CMakeLists.txt      |  2 +-
+ src/eventSensor.cpp | 43 +++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 44 insertions(+), 1 deletion(-)
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 093a393..2cff7fa 100755
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -222,7 +222,7 @@ target_link_libraries (acpisensor ${SENSOR_LINK_LIBS})
+ 
+ add_executable (eventsensor src/eventSensor.cpp)
+ add_dependencies (eventsensor sdbusplus-project)
+-target_link_libraries (eventsensor ${SENSOR_LINK_LIBS})
++target_link_libraries (eventsensor -lobmcmisc ${SENSOR_LINK_LIBS})
+ 
+ add_executable (aclostsensor src/AcLostSensor.cpp)
+ add_dependencies (aclostsensor sdbusplus-project)
+diff --git a/src/eventSensor.cpp b/src/eventSensor.cpp
+index da34f2a..6f95c27 100755
+--- a/src/eventSensor.cpp
++++ b/src/eventSensor.cpp
+@@ -29,9 +29,12 @@
+ #include <sdbusplus/timer.hpp>
+ #include <sensor.hpp>
+ #include <systemd/sd-journal.h>
++#include <openbmc/libmisc.h>
++
+ 
+ static constexpr bool DEBUG = false;
+ 
++
+ //{sensor name, sensor type}
+ const static boost::container::flat_map<std::string, std::string>eventsensors
+     {
+@@ -130,6 +133,46 @@ int main()
+         createSensors(io, objServer, systemBus,sensors);
+     });
+ 
++    // BMC WDT timeout log, move to indivaual sensor object
++    uint32_t scu3c = 0;
++    uint32_t wdt2Flag = 0x08; //bit #3
++    static constexpr char const* ipmiSELService =    "xyz.openbmc_project.Logging.IPMI";
++    static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
++    static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
++    static const std::string ipmiSELAddMessage = "SEL Entry";
++    static constexpr size_t selEvtDataMaxSize = 3;
++    std::string sensorPath = "/xyz/openbmc_project/sensors/mgtsubsyshealth/BMC_Reboot";
++    
++    if (read_register(0x1e6e203c, &scu3c) < 0)
++    {
++        std::cerr<<"failed to read register WDT10 \n";
++    }
++
++    if(scu3c & wdt2Flag)
++    {
++        //log sel
++        uint16_t genId = 0x20;
++        std::vector<uint8_t> eventData(3, 0xFF);
++        bool assert = true;
++
++        eventData[0] = 0x1;
++        sdbusplus::message::message writeSEL = systemBus->new_method_call(
++            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
++        
++        writeSEL.append(ipmiSELAddMessage, sensorPath, eventData, assert, genId);
++        try
++        {
++            systemBus->call_noreply(writeSEL);
++        }
++        catch (sdbusplus::exception_t& e)
++        {
++            std::cerr<<"failed to log BMC Reboot SEL\n";
++        }
++
++        //clear register         
++        scu3c &= ~(1UL << 3);
++        write_register(0x1e6e203c, scu3c);
++    }
+     //auto work = std::make_shared<boost::asio::io_service::work>(io);
+     io.run();
+     return 0;
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0047-Filter-out-invalidate-MOS-temperature-value-and-add-.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0047-Filter-out-invalidate-MOS-temperature-value-and-add-.patch
new file mode 100755
index 0000000..e58ffd0
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0047-Filter-out-invalidate-MOS-temperature-value-and-add-.patch
@@ -0,0 +1,76 @@
+From cc0972e39c66f40848ee97308f6a9348f305ee7d Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 29 Jul 2020 10:44:52 +0800
+Subject: [PATCH] Filter out invalidate MOS temperature value and add delay for
+ CPU sensors
+
+---
+ include/CPUSensor.hpp |  1 +
+ src/CPUSensor.cpp     | 10 ++++++++--
+ src/MOSTempSensor.cpp |  9 ++++++++-
+ 3 files changed, 17 insertions(+), 3 deletions(-)
+
+diff --git a/include/CPUSensor.hpp b/include/CPUSensor.hpp
+index c27eccf..18a72e8 100755
+--- a/include/CPUSensor.hpp
++++ b/include/CPUSensor.hpp
+@@ -48,6 +48,7 @@ class CPUSensor : public Sensor
+     double dtsOffset;
+     bool show;
+     size_t errCount;
++    thresholds::ThresholdTimer thresholdTimer;
+     void setupRead(void);
+     void handleResponse(const boost::system::error_code& err);
+     void checkThresholds(void) override;
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+index 9747ce5..fda9028 100755
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -50,7 +50,8 @@ CPUSensor::CPUSensor(const std::string& path, const std::string& objectType,
+     objServer(objectServer), inputDev(io, open(path.c_str(), O_RDONLY)),
+     waitTimer(io), path(path),
+     privTcontrol(std::numeric_limits<double>::quiet_NaN()),
+-    dtsOffset(dtsOffset), show(show), errCount(0)
++    dtsOffset(dtsOffset), show(show), errCount(0),
++    thresholdTimer(io, this)
+ {
+     nameTcontrol = labelTcontrol;
+     nameTcontrol += " CPU" + std::to_string(cpuId);
+@@ -293,8 +294,13 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+ 
+ void CPUSensor::checkThresholds(void)
+ {
++    if (!isPowerOn())
++    {
++        return;
++    }
++
+     if (show)
+     {
+-        thresholds::checkThresholds(this);
++        thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
+     }
+ }
+diff --git a/src/MOSTempSensor.cpp b/src/MOSTempSensor.cpp
+index 87939bc..00cde26 100755
+--- a/src/MOSTempSensor.cpp
++++ b/src/MOSTempSensor.cpp
+@@ -163,7 +163,14 @@ void MOSTempSensor::read(void)
+                           << static_cast<int>(temp) << "\n";
+             }
+             updateValueInvalid(false);
+-            updateValue(v);
++            if(v >= 0XFF)
++            {
++                std::cerr << "Invalid mos reading:" <<v << "\n";
++            }
++            else
++            {
++                updateValue(v);
++            }
+         }
+         else
+         {
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0048-Add-event-disabled-event-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0048-Add-event-disabled-event-sensor.patch
new file mode 100755
index 0000000..3cde7ee
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0048-Add-event-disabled-event-sensor.patch
@@ -0,0 +1,26 @@
+From ff0f4fe644a004cd551aacad8c02e631372d9bf6 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 23 Jul 2020 16:22:04 +0800
+Subject: [PATCH] Add event disabled event sensor
+
+---
+ src/eventSensor.cpp | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/src/eventSensor.cpp b/src/eventSensor.cpp
+index da34f2a..28f5943 100755
+--- a/src/eventSensor.cpp
++++ b/src/eventSensor.cpp
+@@ -47,7 +47,8 @@ const static boost::container::flat_map<std::string, std::string>eventsensors
+         {"IPMI_POWER_OFF","fru_state"},
+         {"IPMI_POWER_SOFT","fru_state"},
+         {"IPMI_POWER_RESET","fru_state"},
+-        {"WATCHDOG2","watchdog2"}
++        {"WATCHDOG2","watchdog2"},
++        {"EVENT_CLEARED","event_disabled"}
+     };
+ 
+ struct eventSensor 
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0049-filter-out-invalidate-sys-air-inlet-value.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0049-filter-out-invalidate-sys-air-inlet-value.patch
new file mode 100755
index 0000000..be1c1f5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0049-filter-out-invalidate-sys-air-inlet-value.patch
@@ -0,0 +1,35 @@
+From f8a9a345af8f0f5e662749f7295807f9ee0c623b Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 13 Aug 2020 15:25:16 +0800
+Subject: [PATCH] filter out invalidate sys air inlet value
+
+---
+ src/HwmonTempSensor.cpp | 12 +++++++++++-
+ 1 file changed, 11 insertions(+), 1 deletion(-)
+
+diff --git a/src/HwmonTempSensor.cpp b/src/HwmonTempSensor.cpp
+index 3453fb2..9c2ee5f 100755
+--- a/src/HwmonTempSensor.cpp
++++ b/src/HwmonTempSensor.cpp
+@@ -167,7 +167,17 @@ void HwmonTempSensor::handleResponse(const boost::system::error_code& err)
+ 
+             if (static_cast<double>(nvalue) != value)
+             {
+-                updateValue(nvalue);
++                if(name=="SYS_Air_Inlet")
++                {
++                    if(nvalue > -30)
++                    {
++                        updateValue(nvalue);
++                    }
++                }
++                else
++                {
++                    updateValue(nvalue);
++                }
+             }
+             errCount = 0;
+             updateValueInvalid(false);
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0050-Update-BMC-watchdog-timeout-SEL.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0050-Update-BMC-watchdog-timeout-SEL.patch
new file mode 100755
index 0000000..5e0cd3c
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0050-Update-BMC-watchdog-timeout-SEL.patch
@@ -0,0 +1,44 @@
+From c82b20780bcf65d61f4ef63f75ab8cb963a89e86 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 13 Aug 2020 17:37:57 +0800
+Subject: [PATCH] Update BMC watchdog timeout SEL
+
+---
+ src/eventSensor.cpp | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+diff --git a/src/eventSensor.cpp b/src/eventSensor.cpp
+index 18b5289..7872062 100755
+--- a/src/eventSensor.cpp
++++ b/src/eventSensor.cpp
+@@ -42,7 +42,8 @@ const static boost::container::flat_map<std::string, std::string>eventsensors
+         {"SYSTEM_RESTART", "restart"}, //system restart sensor
+         {"BUTTON","pwr_button"},  
+         {"BMC_FW_UPDATE","versionchange"}, 
+-        {"BMC_Reboot","mgtsubsyshealth"},    
++        {"BMC_Reboot","mgtsubsyshealth"},
++        {"WATCHDOG_REBOOT","mgtsubsyshealth"},
+         {"PSU_STATUS","power_supply"},
+         {"DCMI_POWER_LIMIT","power_supply"},
+         {"IPMI_POWER_CYCLE","fru_state"},
+@@ -142,7 +143,7 @@ int main()
+     static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
+     static const std::string ipmiSELAddMessage = "SEL Entry";
+     static constexpr size_t selEvtDataMaxSize = 3;
+-    std::string sensorPath = "/xyz/openbmc_project/sensors/mgtsubsyshealth/BMC_Reboot";
++    std::string sensorPath = "/xyz/openbmc_project/sensors/mgtsubsyshealth/WATCHDOG_REBOOT";
+     
+     if (read_register(0x1e6e203c, &scu3c) < 0)
+     {
+@@ -156,7 +157,7 @@ int main()
+         std::vector<uint8_t> eventData(3, 0xFF);
+         bool assert = true;
+ 
+-        eventData[0] = 0x1;
++        eventData[0] = 0x2;
+         sdbusplus::message::message writeSEL = systemBus->new_method_call(
+             ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+         
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0051-Implement-the-average-mode-for-fan-tech-value.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0051-Implement-the-average-mode-for-fan-tech-value.patch
new file mode 100755
index 0000000..600b9e3
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0051-Implement-the-average-mode-for-fan-tech-value.patch
@@ -0,0 +1,74 @@
+From 0fb966d84258af8115caba6aa3a8125cf92f4b47 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 26 Aug 2020 14:10:26 +0800
+Subject: [PATCH] Implement the average mode for fan tech value
+
+---
+ include/TachSensor.hpp |  4 ++++
+ src/TachSensor.cpp     | 21 ++++++++++++++++++++-
+ 2 files changed, 24 insertions(+), 1 deletion(-)
+
+diff --git a/include/TachSensor.hpp b/include/TachSensor.hpp
+index 379bf17..d6910cb 100755
+--- a/include/TachSensor.hpp
++++ b/include/TachSensor.hpp
+@@ -14,6 +14,9 @@
+ #include <utility>
+ #include <vector>
+ 
++constexpr auto MAX_COLLECTION_VALUE_SIZE = 10;
++constexpr auto DEFAULT_TACH_VALUE= 6000;
++
+ class PresenceSensor
+ {
+   public:
+@@ -88,6 +91,7 @@ class TachSensor : public Sensor
+     void handleResponse(const boost::system::error_code& err);
+     void checkThresholds(void) override;
+     thresholds::ThresholdTimer thresholdTimer;
++    std::vector<double> collectedValue;
+ };
+ 
+ inline void logFanInserted(const std::string& device)
+diff --git a/src/TachSensor.cpp b/src/TachSensor.cpp
+index 2cdbff3..006de65 100755
+--- a/src/TachSensor.cpp
++++ b/src/TachSensor.cpp
+@@ -94,6 +94,7 @@ TachSensor::TachSensor(const std::string& path, const std::string& objectType,
+                  "/xyz/openbmc_project/sensors/fan_tach/" + name}});
+         itemAssoc->initialize();
+     }
++    collectedValue.assign(MAX_COLLECTION_VALUE_SIZE,DEFAULT_TACH_VALUE);
+     setInitialProperties(conn);
+     setupPowerMatch(conn);
+     setupRead();
+@@ -184,7 +185,25 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
+                 responseStream.clear();
+                 if (static_cast<double>(nvalue) != value)
+                 {
+-                    updateValue(nvalue);
++                    double averageCount = 0;
++                    double average =0;
++
++                    if(collectedValue.size() >= MAX_COLLECTION_VALUE_SIZE){
++                        collectedValue.erase(collectedValue.begin());
++                        collectedValue.push_back(nvalue);
++                    }
++                    else{
++                        collectedValue.push_back(nvalue);
++                    }
++                    for (auto it = collectedValue.begin(); it != collectedValue.end(); it++)
++                    {
++                        average = average + *it;
++                        averageCount++;
++                    }
++                    if(averageCount){
++                        average = average/averageCount;
++                    }
++                    updateValue(average);
+                 }
+                 errCount = 0;
+                 updateValueInvalid(false);
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0052-Change-the-using-timer-from-deadline_timer-to-steady.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0052-Change-the-using-timer-from-deadline_timer-to-steady.patch
new file mode 100755
index 0000000..b331242
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0052-Change-the-using-timer-from-deadline_timer-to-steady.patch
@@ -0,0 +1,928 @@
+From 7ed2f4f299f56a9803716e8224b7a9a31e7cd04a Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 27 Aug 2020 14:47:57 +0800
+Subject: [PATCH] Change the using timer from deadline_timer to steady_timer
+
+To chnage the steady_timer also need to change the time function from posix_time to chrono.
+---
+ include/ADCSensor.hpp              |  2 +-
+ include/CPUSensor.hpp              |  2 +-
+ include/ChassisIntrusionSensor.hpp |  2 +-
+ include/HwmonTempSensor.hpp        |  2 +-
+ include/IpmbSensor.hpp             |  4 ++--
+ include/MCUTempSensor.hpp          |  4 ++--
+ include/MNVMeSensor.hpp            |  4 ++--
+ include/MOSTempSensor.hpp          |  4 ++--
+ include/NVMeSensor.hpp             |  4 ++--
+ include/PSUEvent.hpp               |  2 +-
+ include/PSUSensor.hpp              |  2 +-
+ include/TachSensor.hpp             |  2 +-
+ include/Thresholds.hpp             |  6 +++---
+ src/ADCSensor.cpp                  |  7 +++----
+ src/ADCSensorMain.cpp              |  6 +++---
+ src/CPUSensor.cpp                  |  5 ++---
+ src/CPUSensorMain.cpp              | 27 +++++++++++++--------------
+ src/ChassisIntrusionSensor.cpp     |  2 +-
+ src/ExitAirTempSensor.cpp          |  4 ++--
+ src/FanMain.cpp                    |  4 ++--
+ src/HostMemoryEccSenosr.cpp        | 27 +++++++++++++++++++++------
+ src/HwmonTempMain.cpp              |  4 ++--
+ src/HwmonTempSensor.cpp            |  5 ++---
+ src/IpmbSensor.cpp                 | 12 ++++++------
+ src/MCUTempSensor.cpp              |  6 +++---
+ src/MNVMeSensor.cpp                |  6 +++---
+ src/MOSTempSensor.cpp              |  6 +++---
+ src/NVMeSensor.cpp                 |  4 ++--
+ src/NVMeSensorMain.cpp             |  6 +++---
+ src/PSUEvent.cpp                   |  2 +-
+ src/PSUSensor.cpp                  |  5 ++---
+ src/PSUSensorMain.cpp              |  4 ++--
+ src/TachSensor.cpp                 |  5 ++---
+ 33 files changed, 98 insertions(+), 89 deletions(-)
+ mode change 100644 => 100755 include/ChassisIntrusionSensor.hpp
+ mode change 100644 => 100755 include/IpmbSensor.hpp
+ mode change 100644 => 100755 include/MCUTempSensor.hpp
+ mode change 100644 => 100755 include/NVMeSensor.hpp
+ mode change 100644 => 100755 include/PSUEvent.hpp
+ mode change 100644 => 100755 src/ChassisIntrusionSensor.cpp
+ mode change 100644 => 100755 src/ExitAirTempSensor.cpp
+ mode change 100644 => 100755 src/FanMain.cpp
+ mode change 100644 => 100755 src/IpmbSensor.cpp
+ mode change 100644 => 100755 src/MCUTempSensor.cpp
+ mode change 100644 => 100755 src/NVMeSensor.cpp
+ mode change 100644 => 100755 src/NVMeSensorMain.cpp
+ mode change 100644 => 100755 src/PSUEvent.cpp
+
+diff --git a/include/ADCSensor.hpp b/include/ADCSensor.hpp
+index acf4664..a646b89 100755
+--- a/include/ADCSensor.hpp
++++ b/include/ADCSensor.hpp
+@@ -67,7 +67,7 @@ class ADCSensor : public Sensor
+   private:
+     sdbusplus::asio::object_server& objServer;
+     boost::asio::posix::stream_descriptor inputDev;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+     boost::asio::streambuf readBuf;
+     std::string path;
+     size_t errCount;
+diff --git a/include/CPUSensor.hpp b/include/CPUSensor.hpp
+index 18a72e8..4d3baf0 100755
+--- a/include/CPUSensor.hpp
++++ b/include/CPUSensor.hpp
+@@ -39,7 +39,7 @@ class CPUSensor : public Sensor
+   private:
+     sdbusplus::asio::object_server& objServer;
+     boost::asio::posix::stream_descriptor inputDev;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+     boost::asio::streambuf readBuf;
+     std::shared_ptr<sdbusplus::asio::connection> connCPURead;
+     std::string nameTcontrol;
+diff --git a/include/ChassisIntrusionSensor.hpp b/include/ChassisIntrusionSensor.hpp
+old mode 100644
+new mode 100755
+index f65ef33..60f2621
+--- a/include/ChassisIntrusionSensor.hpp
++++ b/include/ChassisIntrusionSensor.hpp
+@@ -36,7 +36,7 @@ class ChassisIntrusionSensor
+     // valid if it is PCH register via i2c
+     int mBusId;
+     int mSlaveAddr;
+-    boost::asio::deadline_timer mPollTimer;
++    boost::asio::steady_timer mPollTimer;
+ 
+     // valid if it is via GPIO
+     bool mGpioInverted;
+diff --git a/include/HwmonTempSensor.hpp b/include/HwmonTempSensor.hpp
+index 0f159bc..a3f1e29 100755
+--- a/include/HwmonTempSensor.hpp
++++ b/include/HwmonTempSensor.hpp
+@@ -24,7 +24,7 @@ class HwmonTempSensor : public Sensor
+   private:
+     sdbusplus::asio::object_server& objServer;
+     boost::asio::posix::stream_descriptor inputDev;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+     boost::asio::streambuf readBuf;
+     std::string path;
+     PowerState readState;
+diff --git a/include/IpmbSensor.hpp b/include/IpmbSensor.hpp
+old mode 100644
+new mode 100755
+index 2185b68..3d54435
+--- a/include/IpmbSensor.hpp
++++ b/include/IpmbSensor.hpp
+@@ -1,7 +1,7 @@
+ #pragma once
+ #include "sensor.hpp"
+ 
+-#include <boost/asio/deadline_timer.hpp>
++#include <boost/asio/steady_timer.hpp>
+ #include <boost/container/flat_map.hpp>
+ #include <chrono>
+ #include <limits>
+@@ -63,5 +63,5 @@ struct IpmbSensor : public Sensor
+   private:
+     sdbusplus::asio::object_server& objectServer;
+     std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+ };
+diff --git a/include/MCUTempSensor.hpp b/include/MCUTempSensor.hpp
+old mode 100644
+new mode 100755
+index eb12c9a..9253915
+--- a/include/MCUTempSensor.hpp
++++ b/include/MCUTempSensor.hpp
+@@ -1,7 +1,7 @@
+ #pragma once
+ #include "sensor.hpp"
+ 
+-#include <boost/asio/deadline_timer.hpp>
++#include <boost/asio/steady_timer.hpp>
+ #include <boost/container/flat_map.hpp>
+ #include <chrono>
+ #include <limits>
+@@ -31,5 +31,5 @@ struct MCUTempSensor : public Sensor
+     int getMCURegsInfoWord(uint8_t regs, int16_t* pu16data);
+     sdbusplus::asio::object_server& objectServer;
+     std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+ };
+diff --git a/include/MNVMeSensor.hpp b/include/MNVMeSensor.hpp
+index fecb766..5c9bc7b 100755
+--- a/include/MNVMeSensor.hpp
++++ b/include/MNVMeSensor.hpp
+@@ -1,7 +1,7 @@
+ #pragma once
+ #include "sensor.hpp"
+ 
+-#include <boost/asio/deadline_timer.hpp>
++#include <boost/asio/steady_timer.hpp>
+ #include <boost/container/flat_map.hpp>
+ #include <chrono>
+ #include <limits>
+@@ -30,5 +30,5 @@ struct NVMeSensor : public Sensor
+     int getNVMeTemp(uint8_t* pu8data);
+     sdbusplus::asio::object_server& objectServer;
+     std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+ };
+diff --git a/include/MOSTempSensor.hpp b/include/MOSTempSensor.hpp
+index be022ab..6932bd6 100755
+--- a/include/MOSTempSensor.hpp
++++ b/include/MOSTempSensor.hpp
+@@ -1,7 +1,7 @@
+ #pragma once
+ #include "sensor.hpp"
+ 
+-#include <boost/asio/deadline_timer.hpp>
++#include <boost/asio/steady_timer.hpp>
+ #include <boost/container/flat_map.hpp>
+ #include <chrono>
+ #include <limits>
+@@ -29,5 +29,5 @@ struct MOSTempSensor : public Sensor
+     int getMOSRegsInfoWord(uint8_t regs, int16_t* pu16data);
+     sdbusplus::asio::object_server& objectServer;
+     std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+ };
+diff --git a/include/NVMeSensor.hpp b/include/NVMeSensor.hpp
+old mode 100644
+new mode 100755
+index ec0bfd1..d0dac61
+--- a/include/NVMeSensor.hpp
++++ b/include/NVMeSensor.hpp
+@@ -35,9 +35,9 @@ struct NVMeContext : std::enable_shared_from_this<NVMeContext>
+ 
+     void pollNVMeDevices();
+ 
+-    boost::asio::deadline_timer scanTimer;
++    boost::asio::steady_timer scanTimer;
+     int rootBus; // Root bus for this drive
+-    boost::asio::deadline_timer mctpResponseTimer;
++    boost::asio::steady_timer mctpResponseTimer;
+     boost::asio::ip::tcp::socket nvmeSlaveSocket;
+     std::list<std::shared_ptr<NVMeSensor>> sensors; // used as a poll queue
+ };
+diff --git a/include/PSUEvent.hpp b/include/PSUEvent.hpp
+old mode 100644
+new mode 100755
+index 623806b..0b842bc
+--- a/include/PSUEvent.hpp
++++ b/include/PSUEvent.hpp
+@@ -46,7 +46,7 @@ class PSUSubEvent
+     std::string path;
+     std::string eventName;
+     std::string groupEventName;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+     boost::asio::streambuf readBuf;
+     void setupRead(void);
+     void handleResponse(const boost::system::error_code& err);
+diff --git a/include/PSUSensor.hpp b/include/PSUSensor.hpp
+index ec59acd..8414e78 100755
+--- a/include/PSUSensor.hpp
++++ b/include/PSUSensor.hpp
+@@ -24,7 +24,7 @@ class PSUSensor : public Sensor
+   private:
+     sdbusplus::asio::object_server& objServer;
+     boost::asio::posix::stream_descriptor inputDev;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+     boost::asio::streambuf readBuf;
+     std::string path;
+     size_t errCount;
+diff --git a/include/TachSensor.hpp b/include/TachSensor.hpp
+index d6910cb..84ff121 100755
+--- a/include/TachSensor.hpp
++++ b/include/TachSensor.hpp
+@@ -83,7 +83,7 @@ class TachSensor : public Sensor
+     std::shared_ptr<sdbusplus::asio::dbus_interface> itemIface;
+     std::shared_ptr<sdbusplus::asio::dbus_interface> itemAssoc;
+     boost::asio::posix::stream_descriptor inputDev;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+     boost::asio::streambuf readBuf;
+     std::string path;
+     size_t errCount;
+diff --git a/include/Thresholds.hpp b/include/Thresholds.hpp
+index 29c7a49..8baaa4e 100755
+--- a/include/Thresholds.hpp
++++ b/include/Thresholds.hpp
+@@ -52,7 +52,7 @@ struct TimerUsed
+     Direction direction;
+ };
+ 
+-using TimerPair = std::pair<struct TimerUsed, boost::asio::deadline_timer>;
++using TimerPair = std::pair<struct TimerUsed, boost::asio::steady_timer>;
+ 
+ 
+ struct ThresholdTimer
+@@ -102,14 +102,14 @@ struct ThresholdTimer
+         if (pair == nullptr)
+         {
+             pair = &timers.emplace_back(timerUsed,
+-                                        boost::asio::deadline_timer(io));
++                                        boost::asio::steady_timer(io));
+ 
+         }
+         pair->first.used = true;
+         pair->first.level = threshold.level;
+         pair->first.direction = threshold.direction;
+ 
+-        pair->second.expires_from_now(boost::posix_time::seconds(waitTime));
++        pair->second.expires_from_now(boost::asio::chrono::seconds(waitTime));
+         pair->second.async_wait(
+             [this, pair, threshold](boost::system::error_code ec) {
+                 pair->first.used = false;
+diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
+index 0be500f..c82e118 100755
+--- a/src/ADCSensor.cpp
++++ b/src/ADCSensor.cpp
+@@ -20,7 +20,6 @@
+ 
+ #include <boost/algorithm/string/predicate.hpp>
+ #include <boost/algorithm/string/replace.hpp>
+-#include <boost/date_time/posix_time/posix_time.hpp>
+ #include <cmath>
+ #include <filesystem>
+ #include <fstream>
+@@ -105,7 +104,7 @@ void ADCSensor::setupRead(void)
+         // value. Guarantee that the HW signal can be stable, the HW signal
+         // could be instability.
+         waitTimer.expires_from_now(
+-            boost::posix_time::milliseconds(gpioBridgeEnableMs));
++            boost::asio::chrono::milliseconds(gpioBridgeEnableMs));
+         waitTimer.async_wait([&](const boost::system::error_code& ec) {
+             if (ec == boost::asio::error::operation_aborted)
+             {
+@@ -154,7 +153,7 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
+             return;
+         }
+         inputDev.assign(fd);
+-        waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++        waitTimer.expires_from_now(boost::asio::chrono::milliseconds(sensorPollMs));
+         waitTimer.async_wait([&](const boost::system::error_code& ec) {
+             if (ec == boost::asio::error::operation_aborted)
+             {
+@@ -233,7 +232,7 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
+         return; // we're no longer valid
+     }
+     inputDev.assign(fd);
+-    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++    waitTimer.expires_from_now(boost::asio::chrono::milliseconds(sensorPollMs));
+     waitTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+diff --git a/src/ADCSensorMain.cpp b/src/ADCSensorMain.cpp
+index 1679946..5cdf9e5 100755
+--- a/src/ADCSensorMain.cpp
++++ b/src/ADCSensorMain.cpp
+@@ -303,7 +303,7 @@ int main()
+         createSensors(io, objectServer, sensors, systemBus, nullptr);
+     });
+ 
+-    boost::asio::deadline_timer filterTimer(io);
++    boost::asio::steady_timer filterTimer(io);
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message& message) {
+             if (message.is_method_error())
+@@ -313,7 +313,7 @@ int main()
+             }
+             sensorsChanged->insert(message.get_path());
+             // this implicitly cancels the timer
+-            filterTimer.expires_from_now(boost::posix_time::seconds(1));
++            filterTimer.expires_from_now(boost::asio::chrono::seconds(1));
+ 
+             filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+@@ -361,7 +361,7 @@ int main()
+             }
+ 
+             // this implicitly cancels the timer
+-            filterTimer.expires_from_now(boost::posix_time::seconds(1));
++            filterTimer.expires_from_now(boost::asio::chrono::seconds(1));
+ 
+             filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+index fda9028..345249a 100755
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -22,7 +22,6 @@
+ 
+ #include <boost/algorithm/string/predicate.hpp>
+ #include <boost/algorithm/string/replace.hpp>
+-#include <boost/date_time/posix_time/posix_time.hpp>
+ #include <iostream>
+ #include <istream>
+ #include <limits>
+@@ -139,7 +138,7 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+             return; // we're no longer valid
+         }
+         inputDev.assign(fd);
+-        waitTimer.expires_from_now(boost::posix_time::milliseconds(pollTime));
++        waitTimer.expires_from_now(boost::asio::chrono::milliseconds(pollTime));
+         waitTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+@@ -282,7 +281,7 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+         return; // we're no longer valid
+     }
+     inputDev.assign(fd);
+-    waitTimer.expires_from_now(boost::posix_time::milliseconds(pollTime));
++    waitTimer.expires_from_now(boost::asio::chrono::milliseconds(pollTime));
+     waitTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+diff --git a/src/CPUSensorMain.cpp b/src/CPUSensorMain.cpp
+index f066aa6..b1dd814 100755
+--- a/src/CPUSensorMain.cpp
++++ b/src/CPUSensorMain.cpp
+@@ -25,7 +25,6 @@
+ #include <boost/algorithm/string/replace.hpp>
+ #include <boost/container/flat_map.hpp>
+ #include <boost/container/flat_set.hpp>
+-#include <boost/date_time/posix_time/posix_time.hpp>
+ #include <boost/process/child.hpp>
+ #include <filesystem>
+ #include <fstream>
+@@ -98,8 +97,8 @@ static constexpr std::array<const char*, 2> hiddenProps = {
+     CPUSensor::labelTcontrol, "Tthrottle"};
+ 
+ void detectCpuAsync(
+-    boost::asio::deadline_timer& pingTimer,
+-    boost::asio::deadline_timer& creationTimer, boost::asio::io_service& io,
++    boost::asio::steady_timer& pingTimer,
++    boost::asio::steady_timer& creationTimer, boost::asio::io_service& io,
+     sdbusplus::asio::object_server& objectServer,
+     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+     boost::container::flat_set<CPUConfig>& cpuConfigs,
+@@ -437,8 +436,8 @@ void exportDevice(const CPUConfig& config)
+     std::cout << parameters << " on bus " << busStr << " is exported\n";
+ }
+ 
+-void detectCpu(boost::asio::deadline_timer& pingTimer,
+-               boost::asio::deadline_timer& creationTimer,
++void detectCpu(boost::asio::steady_timer& pingTimer,
++               boost::asio::steady_timer& creationTimer,
+                boost::asio::io_service& io,
+                sdbusplus::asio::object_server& objectServer,
+                std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+@@ -544,7 +543,7 @@ void detectCpu(boost::asio::deadline_timer& pingTimer,
+     if (rescanDelaySeconds)
+     {
+         creationTimer.expires_from_now(
+-            boost::posix_time::seconds(rescanDelaySeconds));
++            boost::asio::chrono::seconds(rescanDelaySeconds));
+         creationTimer.async_wait([&](const boost::system::error_code& ec) {
+             if (ec == boost::asio::error::operation_aborted)
+             {
+@@ -568,14 +567,14 @@ void detectCpu(boost::asio::deadline_timer& pingTimer,
+ }
+ 
+ void detectCpuAsync(
+-    boost::asio::deadline_timer& pingTimer,
+-    boost::asio::deadline_timer& creationTimer, boost::asio::io_service& io,
++    boost::asio::steady_timer& pingTimer,
++    boost::asio::steady_timer& creationTimer, boost::asio::io_service& io,
+     sdbusplus::asio::object_server& objectServer,
+     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+     boost::container::flat_set<CPUConfig>& cpuConfigs,
+     ManagedObjectType& sensorConfigs)
+ {
+-    pingTimer.expires_from_now(boost::posix_time::seconds(1));
++    pingTimer.expires_from_now(boost::asio::chrono::seconds(1));
+     pingTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+@@ -703,12 +702,12 @@ int main()
+ 
+     sdbusplus::asio::object_server objectServer(systemBus);
+     std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+-    boost::asio::deadline_timer pingTimer(io);
+-    boost::asio::deadline_timer creationTimer(io);
+-    boost::asio::deadline_timer filterTimer(io);
++    boost::asio::steady_timer pingTimer(io);
++    boost::asio::steady_timer creationTimer(io);
++    boost::asio::steady_timer filterTimer(io);
+     ManagedObjectType sensorConfigs;
+ 
+-    filterTimer.expires_from_now(boost::posix_time::seconds(1));
++    filterTimer.expires_from_now(boost::asio::chrono::seconds(1));
+     filterTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+@@ -736,7 +735,7 @@ int main()
+             }
+ 
+             // this implicitly cancels the timer
+-            filterTimer.expires_from_now(boost::posix_time::seconds(1));
++            filterTimer.expires_from_now(boost::asio::chrono::seconds(1));
+             filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+                 {
+diff --git a/src/ChassisIntrusionSensor.cpp b/src/ChassisIntrusionSensor.cpp
+old mode 100644
+new mode 100755
+index 4b2327e..9a2d3ee
+--- a/src/ChassisIntrusionSensor.cpp
++++ b/src/ChassisIntrusionSensor.cpp
+@@ -135,7 +135,7 @@ void ChassisIntrusionSensor::pollSensorStatusByPch()
+ {
+     // setting a new experation implicitly cancels any pending async wait
+     mPollTimer.expires_from_now(
+-        boost::posix_time::seconds(intrusionSensorPollSec));
++        boost::asio::chrono::seconds(intrusionSensorPollSec));
+ 
+     mPollTimer.async_wait([&](const boost::system::error_code& ec) {
+         // case of timer expired
+diff --git a/src/ExitAirTempSensor.cpp b/src/ExitAirTempSensor.cpp
+old mode 100644
+new mode 100755
+index 9ba311b..eb81519
+--- a/src/ExitAirTempSensor.cpp
++++ b/src/ExitAirTempSensor.cpp
+@@ -927,11 +927,11 @@ int main()
+ 
+     io.post([&]() { createSensor(objectServer, sensor, systemBus); });
+ 
+-    boost::asio::deadline_timer configTimer(io);
++    boost::asio::steady_timer configTimer(io);
+ 
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message&) {
+-            configTimer.expires_from_now(boost::posix_time::seconds(1));
++            configTimer.expires_from_now(boost::asio::chrono::seconds(1));
+             // create a timer because normally multiple properties change
+             configTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/FanMain.cpp b/src/FanMain.cpp
+old mode 100644
+new mode 100755
+index 37a4e63..6d9ca46
+--- a/src/FanMain.cpp
++++ b/src/FanMain.cpp
+@@ -435,7 +435,7 @@ int main()
+         createRedundancySensor(tachSensors, systemBus, objectServer);
+     });
+ 
+-    boost::asio::deadline_timer filterTimer(io);
++    boost::asio::steady_timer filterTimer(io);
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message& message) {
+             if (message.is_method_error())
+@@ -445,7 +445,7 @@ int main()
+             }
+             sensorsChanged->insert(message.get_path());
+             // this implicitly cancels the timer
+-            filterTimer.expires_from_now(boost::posix_time::seconds(1));
++            filterTimer.expires_from_now(boost::asio::chrono::seconds(1));
+ 
+             filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/HostMemoryEccSenosr.cpp b/src/HostMemoryEccSenosr.cpp
+index cc68752..b168c9c 100755
+--- a/src/HostMemoryEccSenosr.cpp
++++ b/src/HostMemoryEccSenosr.cpp
+@@ -55,7 +55,7 @@ struct leakyBucketSensor
+   private:
+     sdbusplus::asio::object_server& objectServer;
+     std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
+-    boost::asio::deadline_timer waitTimer;
++    boost::asio::steady_timer waitTimer;
+     std::shared_ptr<sdbusplus::asio::dbus_interface> intf;
+ };
+ 
+@@ -88,7 +88,7 @@ void leakyBucketSensor::init(void)
+ void leakyBucketSensor::read(void)
+ {
+ 
+-    waitTimer.expires_from_now(boost::posix_time::hours(pollTime));
++    waitTimer.expires_from_now(boost::asio::chrono::hours(pollTime));
+     waitTimer.async_wait([this](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+@@ -116,7 +116,7 @@ bool leakyBucketSensor::addEcc(void)
+     if(count == 1)
+     {
+         waitTimer.cancel();
+-        waitTimer.expires_from_now(boost::posix_time::hours(pollTime));
++        waitTimer.expires_from_now(boost::asio::chrono::hours(pollTime));
+     }
+ #endif     
+     //NOTE!!: according to F4 implementation, the count should be cleared when overflow
+@@ -127,9 +127,24 @@ bool leakyBucketSensor::addEcc(void)
+ 
+     intf->set_property("count", count);
+     if constexpr (1){
+-        boost::posix_time::time_duration td = waitTimer.expires_from_now();
+-        //std::cerr << "expires_from_now :" << td.seconds() << "\n";
+-        std::cerr << boost::format("%d:%d:%d") % td.hours() % td.minutes() % td.seconds() << "\n";
++        typedef std::chrono::duration<int, std::ratio<86400>> days;
++
++        std::chrono::duration<int64_t, std::nano> td = waitTimer.expires_from_now();
++        std::chrono::nanoseconds ns = std::chrono::nanoseconds(td.count());
++        auto d = std::chrono::duration_cast<days>(ns);
++        ns -= d;
++        auto h = std::chrono::duration_cast<std::chrono::hours>(ns);
++        ns -= h;
++        auto m = std::chrono::duration_cast<std::chrono::minutes>(ns);
++        ns -= m;
++        auto s = std::chrono::duration_cast<std::chrono::seconds>(ns);
++
++        std::cerr
++            << std::setw(2) << d.count() << "d:"
++            << std::setw(2) << h.count() << "h:"
++            << std::setw(2) << m.count() << "m:"
++            << std::setw(2) << s.count() << 's'
++            << "\n";
+     }
+     
+     return overflow;
+diff --git a/src/HwmonTempMain.cpp b/src/HwmonTempMain.cpp
+index 353803d..289df86 100755
+--- a/src/HwmonTempMain.cpp
++++ b/src/HwmonTempMain.cpp
+@@ -290,7 +290,7 @@ int main()
+         createSensors(io, objectServer, sensors, systemBus, nullptr);
+     });
+ 
+-    boost::asio::deadline_timer filterTimer(io);
++    boost::asio::steady_timer filterTimer(io);
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message& message) {
+             if (message.is_method_error())
+@@ -300,7 +300,7 @@ int main()
+             }
+             sensorsChanged->insert(message.get_path());
+             // this implicitly cancels the timer
+-            filterTimer.expires_from_now(boost::posix_time::seconds(1));
++            filterTimer.expires_from_now(boost::asio::chrono::seconds(1));
+ 
+             filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/HwmonTempSensor.cpp b/src/HwmonTempSensor.cpp
+index 9c2ee5f..0e06c08 100755
+--- a/src/HwmonTempSensor.cpp
++++ b/src/HwmonTempSensor.cpp
+@@ -20,7 +20,6 @@
+ 
+ #include <boost/algorithm/string/predicate.hpp>
+ #include <boost/algorithm/string/replace.hpp>
+-#include <boost/date_time/posix_time/posix_time.hpp>
+ #include <iostream>
+ #include <istream>
+ #include <limits>
+@@ -124,7 +123,7 @@ void HwmonTempSensor::handleResponse(const boost::system::error_code& err)
+             return;
+         }
+         inputDev.assign(fd);
+-        waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++        waitTimer.expires_from_now(boost::asio::chrono::milliseconds(sensorPollMs));
+         waitTimer.async_wait([&](const boost::system::error_code& ec) {
+             if (ec == boost::asio::error::operation_aborted)
+             {
+@@ -217,7 +216,7 @@ void HwmonTempSensor::handleResponse(const boost::system::error_code& err)
+         return; // we're no longer valid
+     }
+     inputDev.assign(fd);
+-    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++    waitTimer.expires_from_now(boost::asio::chrono::milliseconds(sensorPollMs));
+     waitTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+diff --git a/src/IpmbSensor.cpp b/src/IpmbSensor.cpp
+old mode 100644
+new mode 100755
+index 11aac0c..5bf0a28
+--- a/src/IpmbSensor.cpp
++++ b/src/IpmbSensor.cpp
+@@ -56,7 +56,7 @@ using IpmbMethodType =
+ 
+ boost::container::flat_map<std::string, std::unique_ptr<IpmbSensor>> sensors;
+ 
+-std::unique_ptr<boost::asio::deadline_timer> initCmdTimer;
++std::unique_ptr<boost::asio::steady_timer> initCmdTimer;
+ 
+ IpmbSensor::IpmbSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
+                        boost::asio::io_service& io,
+@@ -240,7 +240,7 @@ void IpmbSensor::read(void)
+ {
+     static constexpr size_t pollTime = 1; // in seconds
+ 
+-    waitTimer.expires_from_now(boost::posix_time::seconds(pollTime));
++    waitTimer.expires_from_now(boost::asio::chrono::seconds(pollTime));
+     waitTimer.async_wait([this](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+@@ -510,7 +510,7 @@ void reinitSensors(sdbusplus::message::message& message)
+             // we seem to send this command too fast sometimes, wait before
+             // sending
+             initCmdTimer->expires_from_now(
+-                boost::posix_time::seconds(reinitWaitSeconds));
++                boost::asio::chrono::seconds(reinitWaitSeconds));
+ 
+             initCmdTimer->async_wait([](const boost::system::error_code ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+@@ -538,15 +538,15 @@ int main()
+     systemBus->request_name("xyz.openbmc_project.IpmbSensor");
+     sdbusplus::asio::object_server objectServer(systemBus);
+ 
+-    initCmdTimer = std::make_unique<boost::asio::deadline_timer>(io);
++    initCmdTimer = std::make_unique<boost::asio::steady_timer>(io);
+ 
+     io.post([&]() { createSensors(io, objectServer, sensors, systemBus); });
+ 
+-    boost::asio::deadline_timer configTimer(io);
++    boost::asio::steady_timer configTimer(io);
+ 
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message&) {
+-            configTimer.expires_from_now(boost::posix_time::seconds(1));
++            configTimer.expires_from_now(boost::asio::chrono::seconds(1));
+             // create a timer because normally multiple properties change
+             configTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/MCUTempSensor.cpp b/src/MCUTempSensor.cpp
+old mode 100644
+new mode 100755
+index 06376b6..feaea64
+--- a/src/MCUTempSensor.cpp
++++ b/src/MCUTempSensor.cpp
+@@ -157,7 +157,7 @@ void MCUTempSensor::read(void)
+ {
+     static constexpr size_t pollTime = 1; // in seconds
+ 
+-    waitTimer.expires_from_now(boost::posix_time::seconds(pollTime));
++    waitTimer.expires_from_now(boost::asio::chrono::seconds(pollTime));
+     waitTimer.async_wait([this](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+@@ -277,11 +277,11 @@ int main()
+ 
+     io.post([&]() { createSensors(io, objectServer, sensors, systemBus); });
+ 
+-    boost::asio::deadline_timer configTimer(io);
++    boost::asio::steady_timer configTimer(io);
+ 
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message&) {
+-            configTimer.expires_from_now(boost::posix_time::seconds(1));
++            configTimer.expires_from_now(boost::asio::chrono::seconds(1));
+             // create a timer because normally multiple properties change
+             configTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/MNVMeSensor.cpp b/src/MNVMeSensor.cpp
+index b9e4196..e21c027 100755
+--- a/src/MNVMeSensor.cpp
++++ b/src/MNVMeSensor.cpp
+@@ -277,7 +277,7 @@ void NVMeSensor::read(void)
+ {
+     static constexpr size_t pollTime = 1; // in seconds
+ 
+-    waitTimer.expires_from_now(boost::posix_time::seconds(pollTime));
++    waitTimer.expires_from_now(boost::asio::chrono::seconds(pollTime));
+     waitTimer.async_wait([this](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+@@ -393,11 +393,11 @@ int main()
+ 
+     io.post([&]() { createSensors(io, objectServer, sensors, systemBus); });
+ 
+-    boost::asio::deadline_timer configTimer(io);
++    boost::asio::steady_timer configTimer(io);
+ 
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message&) {
+-            configTimer.expires_from_now(boost::posix_time::seconds(1));
++            configTimer.expires_from_now(boost::asio::chrono::seconds(1));
+             // create a timer because normally multiple properties change
+             configTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/MOSTempSensor.cpp b/src/MOSTempSensor.cpp
+index 00cde26..140fc25 100755
+--- a/src/MOSTempSensor.cpp
++++ b/src/MOSTempSensor.cpp
+@@ -140,7 +140,7 @@ void MOSTempSensor::read(void)
+ {
+     static constexpr size_t pollTime = 1; // in seconds
+ 
+-    waitTimer.expires_from_now(boost::posix_time::seconds(pollTime));
++    waitTimer.expires_from_now(boost::asio::chrono::seconds(pollTime));
+     waitTimer.async_wait([this](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+@@ -272,11 +272,11 @@ int main(int argc, char** argv)
+ 
+     io.post([&]() { createSensors(io, objectServer, sensors, systemBus); });
+ 
+-    boost::asio::deadline_timer configTimer(io);
++    boost::asio::steady_timer configTimer(io);
+ 
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message& message) {
+-            configTimer.expires_from_now(boost::posix_time::seconds(1));
++            configTimer.expires_from_now(boost::asio::chrono::seconds(1));
+             // create a timer because normally multiple properties change
+             configTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/NVMeSensor.cpp b/src/NVMeSensor.cpp
+old mode 100644
+new mode 100755
+index e993833..4706f20
+--- a/src/NVMeSensor.cpp
++++ b/src/NVMeSensor.cpp
+@@ -221,7 +221,7 @@ void readAndProcessNVMeSensor(const std::shared_ptr<NVMeContext>& nvmeDevice)
+ 
+     // setup the timeout timer
+     nvmeDevice->mctpResponseTimer.expires_from_now(
+-        boost::posix_time::seconds(mctpResponseTimeout));
++        boost::asio::chrono::seconds(mctpResponseTimeout));
+ 
+     nvmeDevice->mctpResponseTimer.async_wait(
+         [sensor, nvmeDevice](const boost::system::error_code errorCode) {
+@@ -403,7 +403,7 @@ NVMeContext::NVMeContext(boost::asio::io_service& io, int rootBus) :
+ 
+ void NVMeContext::pollNVMeDevices()
+ {
+-    scanTimer.expires_from_now(boost::posix_time::seconds(1));
++    scanTimer.expires_from_now(boost::asio::chrono::seconds(1));
+     scanTimer.async_wait(
+         [self{shared_from_this()}](const boost::system::error_code errorCode) {
+             if (errorCode == boost::asio::error::operation_aborted)
+diff --git a/src/NVMeSensorMain.cpp b/src/NVMeSensorMain.cpp
+old mode 100644
+new mode 100755
+index 1858ea9..9c0928c
+--- a/src/NVMeSensorMain.cpp
++++ b/src/NVMeSensorMain.cpp
+@@ -16,7 +16,7 @@
+ 
+ #include "NVMeSensor.hpp"
+ 
+-#include <boost/asio/deadline_timer.hpp>
++#include <boost/asio/steady_timer.hpp>
+ #include <regex>
+ 
+ static constexpr const char* sensorType =
+@@ -148,12 +148,12 @@ int main()
+ 
+     io.post([&]() { createSensors(io, objectServer, systemBus); });
+ 
+-    boost::asio::deadline_timer filterTimer(io);
++    boost::asio::steady_timer filterTimer(io);
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&filterTimer, &io, &objectServer,
+          &systemBus](sdbusplus::message::message& message) {
+             // this implicitly cancels the timer
+-            filterTimer.expires_from_now(boost::posix_time::seconds(1));
++            filterTimer.expires_from_now(boost::asio::chrono::seconds(1));
+ 
+             filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+diff --git a/src/PSUEvent.cpp b/src/PSUEvent.cpp
+old mode 100644
+new mode 100755
+index 4e5c5a7..e2cc9cb
+--- a/src/PSUEvent.cpp
++++ b/src/PSUEvent.cpp
+@@ -225,7 +225,7 @@ void PSUSubEvent::handleResponse(const boost::system::error_code& err)
+         errCount++;
+     }
+     lseek(fd, 0, SEEK_SET);
+-    waitTimer.expires_from_now(boost::posix_time::milliseconds(eventPollMs));
++    waitTimer.expires_from_now(boost::asio::chrono::milliseconds(eventPollMs));
+     waitTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+diff --git a/src/PSUSensor.cpp b/src/PSUSensor.cpp
+index 18ce06a..75fa4db 100755
+--- a/src/PSUSensor.cpp
++++ b/src/PSUSensor.cpp
+@@ -20,7 +20,6 @@
+ 
+ #include <boost/algorithm/string/predicate.hpp>
+ #include <boost/algorithm/string/replace.hpp>
+-#include <boost/date_time/posix_time/posix_time.hpp>
+ #include <iostream>
+ #include <istream>
+ #include <limits>
+@@ -149,7 +148,7 @@ void PSUSensor::handleResponse(const boost::system::error_code& err)
+             return;
+         }
+         inputDev.assign(fd);
+-        waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++        waitTimer.expires_from_now(boost::asio::chrono::milliseconds(sensorPollMs));
+         waitTimer.async_wait([&](const boost::system::error_code& ec) {
+             if (ec == boost::asio::error::operation_aborted)
+             {
+@@ -217,7 +216,7 @@ void PSUSensor::handleResponse(const boost::system::error_code& err)
+     }
+ 
+     lseek(fd, 0, SEEK_SET);
+-    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
++    waitTimer.expires_from_now(boost::asio::chrono::milliseconds(sensorPollMs));
+     waitTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+diff --git a/src/PSUSensorMain.cpp b/src/PSUSensorMain.cpp
+index abb4df3..7a948e5 100755
+--- a/src/PSUSensorMain.cpp
++++ b/src/PSUSensorMain.cpp
+@@ -886,7 +886,7 @@ int main()
+     propertyInitialize();
+ 
+     io.post([&]() { createSensors(io, objectServer, systemBus); });
+-    boost::asio::deadline_timer filterTimer(io);
++    boost::asio::steady_timer filterTimer(io);
+     std::function<void(sdbusplus::message::message&)> eventHandler =
+         [&](sdbusplus::message::message& message) {
+             if (message.is_method_error())
+@@ -894,7 +894,7 @@ int main()
+                 std::cerr << "callback method error\n";
+                 return;
+             }
+-            filterTimer.expires_from_now(boost::posix_time::seconds(3));
++            filterTimer.expires_from_now(boost::asio::chrono::seconds(3));
+             filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                 if (ec == boost::asio::error::operation_aborted)
+                 {
+diff --git a/src/TachSensor.cpp b/src/TachSensor.cpp
+index 006de65..601c0a9 100755
+--- a/src/TachSensor.cpp
++++ b/src/TachSensor.cpp
+@@ -22,7 +22,6 @@
+ 
+ #include <boost/algorithm/string/predicate.hpp>
+ #include <boost/algorithm/string/replace.hpp>
+-#include <boost/date_time/posix_time/posix_time.hpp>
+ #include <fstream>
+ #include <gpiod.hpp>
+ #include <iostream>
+@@ -151,7 +150,7 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
+             return;
+         }
+         inputDev.assign(fd);
+-        waitTimer.expires_from_now(boost::posix_time::milliseconds(pollTime));
++        waitTimer.expires_from_now(boost::asio::chrono::milliseconds(pollTime));
+         waitTimer.async_wait([&](const boost::system::error_code& ec) {
+             if (ec == boost::asio::error::operation_aborted)
+             {
+@@ -247,7 +246,7 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
+         return; // we're no longer valid
+     }
+     inputDev.assign(fd);
+-    waitTimer.expires_from_now(boost::posix_time::milliseconds(pollTime));
++    waitTimer.expires_from_now(boost::asio::chrono::milliseconds(pollTime));
+     waitTimer.async_wait([&](const boost::system::error_code& ec) {
+         if (ec == boost::asio::error::operation_aborted)
+         {
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0053-add-ADC-boundary-retry.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0053-add-ADC-boundary-retry.patch
new file mode 100755
index 0000000..21beab6
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0053-add-ADC-boundary-retry.patch
@@ -0,0 +1,48 @@
+From 421edd73320fae841732bd94bf58f3a262c65f28 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Thu, 22 Oct 2020 17:31:01 +0800
+Subject: [PATCH 1/1] add ADC boundary retry
+
+---
+ include/ADCSensor.hpp | 1 +
+ src/ADCSensor.cpp     | 8 +++++---
+ 2 files changed, 6 insertions(+), 3 deletions(-)
+
+diff --git a/include/ADCSensor.hpp b/include/ADCSensor.hpp
+index a646b89..75928ba 100755
+--- a/include/ADCSensor.hpp
++++ b/include/ADCSensor.hpp
+@@ -72,6 +72,7 @@ class ADCSensor : public Sensor
+     std::string path;
+     size_t errCount;
+     double scaleFactor;
++    int retry = 0;
+     std::optional<BridgeGpio> bridgeGpio;
+     PowerState readState;
+     thresholds::ThresholdTimer thresholdTimer;
+diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
+index c82e118..2a20d66 100755
+--- a/src/ADCSensor.cpp
++++ b/src/ADCSensor.cpp
+@@ -180,13 +180,15 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
+             double rawValue  = nvalue;
+             if(rawValue >= 1790) 
+             {
+-                std::cerr << "rawValue:" <<rawValue << "\n";
++                std::cerr << "rawValue:" <<rawValue << "\n";    
++                retry++;
++            }else{
++                retry = 0;
+             }
+-
+             nvalue = (nvalue / sensorScaleFactor) / scaleFactor;
+             nvalue = std::round(nvalue * roundFactor) / roundFactor;
+                 
+-            if ((nvalue != value) && (rawValue <= 1790))
++            if ((nvalue != value) && ((rawValue < 1790) || (retry >= 3)))
+             {
+                 updateValue(nvalue);
+             }
+-- 
+2.26.2
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0054-Implement-the-average-mode-for-PSU-fan-sensor-value.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0054-Implement-the-average-mode-for-PSU-fan-sensor-value.patch
new file mode 100755
index 0000000..88121e1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0054-Implement-the-average-mode-for-PSU-fan-sensor-value.patch
@@ -0,0 +1,84 @@
+From 7b782f66b67d67b6f20c14ce452aae2d635b2164 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 22 Oct 2020 20:06:46 +0800
+Subject: [PATCH] Implement the average mode for PSU fan sensor value
+
+---
+ include/PSUSensor.hpp |  4 ++++
+ src/PSUSensor.cpp     | 30 +++++++++++++++++++++++++++++-
+ 2 files changed, 33 insertions(+), 1 deletion(-)
+
+diff --git a/include/PSUSensor.hpp b/include/PSUSensor.hpp
+index 8414e78..4a78838 100755
+--- a/include/PSUSensor.hpp
++++ b/include/PSUSensor.hpp
+@@ -8,6 +8,9 @@
+ #include <sdbusplus/asio/object_server.hpp>
+ #include <string>
+ 
++constexpr auto MAX_COLLECTION_VALUE_SIZE = 10;
++constexpr auto DEFAULT_TACH_VALUE= 6000;
++
+ class PSUSensor : public Sensor
+ {
+   public:
+@@ -27,6 +30,7 @@ class PSUSensor : public Sensor
+     boost::asio::steady_timer waitTimer;
+     boost::asio::streambuf readBuf;
+     std::string path;
++    std::vector<double> collectedValue;
+     size_t errCount;
+     unsigned int sensorFactor;
+     void setupRead(void);
+diff --git a/src/PSUSensor.cpp b/src/PSUSensor.cpp
+index 75fa4db..8e1ac88 100755
+--- a/src/PSUSensor.cpp
++++ b/src/PSUSensor.cpp
+@@ -86,6 +86,10 @@ PSUSensor::PSUSensor(const std::string& path, const std::string& objectType,
+     // register and initialize "Associations" property.
+     setInitialProperties(conn);
+ 
++    if(path.find("fan")!= std::string::npos){
++        collectedValue.assign(MAX_COLLECTION_VALUE_SIZE,DEFAULT_TACH_VALUE);
++    }
++
+     association = objectServer.add_interface(dbusPath, association::interface);
+ 
+     createInventoryAssoc(conn, association, configurationPath);
+@@ -182,8 +186,32 @@ void PSUSensor::handleResponse(const boost::system::error_code& err)
+                     std::cerr << "Update " << path << " from " << value
+                               << " to " << nvalue << "\n";
+                 }
++                if(path.find("fan")!= std::string::npos)
++                {
++                    double averageCount = 0;
++                    double average =0;
+ 
+-                updateValue(nvalue);
++                    if(collectedValue.size() >= MAX_COLLECTION_VALUE_SIZE){
++                        collectedValue.erase(collectedValue.begin());
++                        collectedValue.push_back(nvalue);
++                    }
++                    else{
++                        collectedValue.push_back(nvalue);
++                    }
++                    for (auto it = collectedValue.begin(); it != collectedValue.end(); it++)
++                    {
++                        average = average + *it;
++                        averageCount++;
++                    }
++                    if(averageCount){
++                        average = average/averageCount;
++                    }
++                    updateValue(average);
++                }
++                else
++                {
++                    updateValue(nvalue);
++                }
+             }
+ 
+             updateValueInvalid(false);
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0055-Add-the-debug-log-for-dimm-sensor.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0055-Add-the-debug-log-for-dimm-sensor.patch
new file mode 100755
index 0000000..d491d72
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0055-Add-the-debug-log-for-dimm-sensor.patch
@@ -0,0 +1,29 @@
+From ff1a777b049b5ab9584ec5363534739c2b3f1160 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 22 Oct 2020 20:05:12 +0800
+Subject: [PATCH] Add the debug log for dimm sensor
+
+---
+ src/CPUSensor.cpp | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
+index 345249a..3b2d3ef 100755
+--- a/src/CPUSensor.cpp
++++ b/src/CPUSensor.cpp
+@@ -160,6 +160,12 @@ void CPUSensor::handleResponse(const boost::system::error_code& err)
+             double nvalue = std::stof(response);
+             responseStream.clear();
+             nvalue /= CPUSensor::sensorScaleFactor;
++
++            if(path.find("peci-dimmtemp")!= std::string::npos && nvalue > 80)
++            {
++                std::cerr << "path:" << path << ", value:" << nvalue << "\n";
++            }
++
+             if (nvalue == sensorDisable)
+             {
+                 updateValueInvalid(true);
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0056-create-bmc-reset-flag.patch b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0056-create-bmc-reset-flag.patch
new file mode 100755
index 0000000..b290d78
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors/0056-create-bmc-reset-flag.patch
@@ -0,0 +1,34 @@
+From d1feb419768c55cb1ed8934986d32f77b115dc3f Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Wed, 7 Oct 2020 19:45:13 +0800
+Subject: [PATCH] create bmc reset flag
+
+---
+ src/AcLostSensor.cpp | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
+ mode change 100644 => 100755 src/AcLostSensor.cpp
+
+diff --git a/src/AcLostSensor.cpp b/src/AcLostSensor.cpp
+old mode 100644
+new mode 100755
+index b459f7b..c7fa3cc
+--- a/src/AcLostSensor.cpp
++++ b/src/AcLostSensor.cpp
+@@ -126,6 +126,17 @@ int main()
+             std::cerr << "set SCU3C register failed\n";
+         }
+     }
++    else
++    {
++        memset(command, 0, sizeof(command));
++        sprintf(command, "touch /run/bmcRebootFlag");
++        std::cerr << "create bmcRebootFlag flag" << '\n';
++        rc = system(command);
++        if (rc != 0)
++        {
++            std::cerr << "touch /run/bmcRebootFlag file failed\n";
++        }
++    }
+ 
+     io.run();
+ 
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors_git.bbappend
new file mode 100755
index 0000000..2407db1
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/dbus-sensors_git.bbappend
@@ -0,0 +1,65 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+# Disable the CPU sensor Tcontrol threshold setting
+EXTRA_OECMAKE_append += " -DBMC_CPU_SENSOR_TCONTROL=OFF"
+
+SRC_URI += "file://0001-add-supported-pmbus-name-cffps1.patch \
+            file://0002-Filter-out-FAN-threshold-event-during-power-transiti.patch \
+            file://0003-New-processor-sensor-to-replace-gpio-sensor.patch \
+            file://0004-support-ipmi-ACPI-sensor.patch \
+            file://0005-add-event-sensor.patch \
+            file://0006-Add-OCP-NIC-temperature-sensor.patch \
+            file://0007-add-necessary-event-sensors-in-dbus.patch \
+            file://0013-add-ipmi-power-status-sensor.patch \
+            file://0015-hidden-peci-core-temperature-sensor.patch \
+            file://0018-change-power-match-to-pgood-event.patch \
+            file://0020-Add-prochot-sensor.patch \
+            file://0021-Add-Invalid-Value-property-for-power-on-sensors.patch \
+            file://0022-Add-type-sensors-to-support-the-invalid-value-proper.patch \
+            file://0023-Add-thermtrip-sensor.patch \
+            file://0024-disable-PSU-PWM-detecting.patch \
+            file://0025-Add-VR-MOS-Margin-sensor.patch \
+            file://0026-support-leaky-bucket-sensor.patch \
+            file://0030-add-sensor-reading-unavailable-bit-for-VR-sensor.patch \
+            file://0031-Fix-the-cpu-sensor-display.patch \
+            file://0032-mct-NVMe-sensor.patch \
+            file://0033-Modify-MNVMe-sensor-debug-message-with-using-debug-f.patch \
+            file://0034-Fix-cpu-senor-data-update-error-after-code-base-upda.patch \
+            file://0035-Fix-CPU-DTS-margin-reading-incorrect.patch \
+            file://0036-Fix-sensor-hysteresis-issue.patch \
+            file://0037-Fix-cpu-sensor-hang-and-get-power-status-error.patch \
+            file://0038-Add-watchdog2-and-power-control-event-sensor.patch \
+            file://0039-Add-DCMI-power-event-sensor.patch \
+            file://0040-change-ADC-range-to-be-configurable.patch \
+            file://0041-add-assert-value-to-log-event-data.patch \
+            file://0042-Stop-the-timer-when-the-deasserted-events-occur.patch \
+            file://0043-add-offset-value-for-E810-OCP-card.patch \
+            file://0044-log-assert-event-when-timer-cancelled.patch \
+            file://0045-filter-out-invalidate-ADC-value.patch \
+            file://0047-Filter-out-invalidate-MOS-temperature-value-and-add-.patch \
+            file://0046-add-BMC-watchdog-timeout-SEL.patch \
+            file://0048-Add-event-disabled-event-sensor.patch \
+            file://0049-filter-out-invalidate-sys-air-inlet-value.patch \
+            file://0050-Update-BMC-watchdog-timeout-SEL.patch \
+            file://0051-Implement-the-average-mode-for-fan-tech-value.patch \
+            file://0052-Change-the-using-timer-from-deadline_timer-to-steady.patch \
+            file://0053-add-ADC-boundary-retry.patch \
+            file://0054-Implement-the-average-mode-for-PSU-fan-sensor-value.patch \
+            file://0055-Add-the-debug-log-for-dimm-sensor.patch \
+            file://0056-create-bmc-reset-flag.patch \
+            "
+
+SYSTEMD_SERVICE_${PN} += " xyz.openbmc_project.processorsensor.service"
+SYSTEMD_SERVICE_${PN} += " xyz.openbmc_project.acpisensor.service"
+SYSTEMD_SERVICE_${PN} += " xyz.openbmc_project.aclostsensor.service"
+SYSTEMD_SERVICE_${PN} += " xyz.openbmc_project.mnvmesensor.service"
+SYSTEMD_SERVICE_${PN} += " xyz.openbmc_project.mostempsensor.service"
+SYSTEMD_SERVICE_${PN} += " xyz.openbmc_project.hostmemoryeccsensor.service"
+SYSTEMD_SERVICE_${PN} += " xyz.openbmc_project.eventsensor.service"
+
+DEPENDS += "obmc-libmisc"
+
+RDEPENDS_${PN} += "obmc-libmisc"
+
+
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%.bbappend.deprecated b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%.bbappend.deprecated
new file mode 100755
index 0000000..e3d3c48
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%.bbappend.deprecated
@@ -0,0 +1,25 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI_prepend = "file://iio-hwmon.conf \
+                  "
+
+do_install_append() {
+        install -d ${D}/etc/default/obmc/hwmon/
+        install -m 644 ${WORKDIR}/iio-hwmon.conf ${D}/etc/default/obmc/hwmon/iio-hwmon.conf
+        install -d ${D}/etc/default/obmc/hwmon/vsensor
+}
+
+NAMES = " \
+        bus@1e78a000/i2c-bus@40/nct7802@28 \
+        bus@1e78a000/i2c-bus@100/power-supply@58 \
+        pwm-tacho-controller@1e786000 \
+        "
+
+ITEMSFMT = "ahb/apb/{0}.conf"
+
+ITEMS = "${@compose_list(d, 'ITEMSFMT', 'NAMES')}"
+
+ENVS = "obmc/hwmon/{0}"
+SYSTEMD_ENVIRONMENT_FILE_${PN} += "${@compose_list(d, 'ENVS', 'ITEMS')}"
+
+       
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/iio-hwmon.conf b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/iio-hwmon.conf
new file mode 100755
index 0000000..0c224f5
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/iio-hwmon.conf
@@ -0,0 +1,77 @@
+LABEL_in1=PVCCP_P0_ADC0
+GAIN_in1=1.333
+OFFSET_in1=0
+
+LABEL_in2=PVCCIO_P0_ADC1
+GAIN_in2=1
+OFFSET_in2=0
+
+LABEL_in3=PVDDQ_P0_ADC2
+GAIN_in3=1
+OFFSET_in3=0
+
+LABEL_in4=PVPP_P0_ADC3
+GAIN_in4=1.846
+OFFSET_in4=0
+
+LABEL_in5=PVCCP_P1_ADC4
+GAIN_in5=1.333
+OFFSET_in5=0
+
+LABEL_in6=PVCCIO_P1_ADC5
+GAIN_in6=1
+OFFSET_in6=0
+
+LABEL_in7=PVDDQ_P1_ADC6
+GAIN_in7=1
+OFFSET_in7=0
+
+LABEL_in8=PVPP_P1_ADC7
+GAIN_in8=1.846
+OFFSET_in8=0
+
+LABEL_in9=PVCC12_ADC8
+GAIN_in9=8.913
+OFFSET_in9=0
+CRITHI_in9=13200
+CRITLO_in9=10800
+
+LABEL_in10=PVCC5_ADC9
+GAIN_in10=3.75
+OFFSET_in10=0
+CRITHI_in10=5500
+CRITLO_in10=4500
+
+LABEL_in11=PVCC3_ADC10
+GAIN_in11=2.468
+OFFSET_in11=0
+CRITHI_in11=3630
+CRITLO_in11=2970
+
+LABEL_in12=PVCC3_AUX_ADC11
+GAIN_in12=2.468
+OFFSET_in12=0
+CRITHI_in12=3630
+CRITLO_in12=2970
+
+LABEL_in13=P1V8_PCH_ADC12
+GAIN_in13=1.333
+OFFSET_in13=0
+CRITHI_in13=1980
+CRITLO_in13=1620
+
+LABEL_in14=PVNN_PCH_ADC13
+GAIN_in14=1
+OFFSET_in14=0
+
+LABEL_in15=P1V05_PCH_ADC14
+GAIN_in15=1
+OFFSET_in15=0
+CRITHI_in15=1155
+CRITLO_in15=945
+
+LABEL_in16=RTC_BAT_ADC15
+GAIN_in16=3
+OFFSET_in16=0
+CRITHI_in16=3300
+CRITLO_in16=2700
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/bus@1e78a000/i2c-bus@100/power-supply@58.conf b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/bus@1e78a000/i2c-bus@100/power-supply@58.conf
new file mode 100755
index 0000000..1cdfa0f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/bus@1e78a000/i2c-bus@100/power-supply@58.conf
@@ -0,0 +1,13 @@
+LABEL_in1="PSU_VOLTAGE_IN"
+
+LABEL_power1="PSU_POWER_IN"
+
+LABEL_in2="PSU_VOLTAGE_OUT"
+
+LABEL_power2="PSU_POWER_OUT"
+
+LABEL_curr1="PSU_CURRENT_OUT"
+
+LABEL_fan1="PSU_FAN"
+
+LABEL_temp1="PSU_TEMP"
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/bus@1e78a000/i2c-bus@40/nct7802@28.conf b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/bus@1e78a000/i2c-bus@40/nct7802@28.conf
new file mode 100755
index 0000000..ebd5c7e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/bus@1e78a000/i2c-bus@40/nct7802@28.conf
@@ -0,0 +1,11 @@
+LABEL_temp1=SYS_AIR_INLET
+CRITLO_temp1=10000
+CRITHI_temp1=60000
+
+LABEL_temp2=MB_AIR_INLET
+CRITLO_temp2=10000
+CRITHI_temp2=60000
+
+LABEL_temp3=SYS_AIR_OUTLET
+CRITLO_temp3=10000
+CRITHI_temp3=60000
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/pwm-tacho-controller@1e786000.conf b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/pwm-tacho-controller@1e786000.conf
new file mode 100755
index 0000000..61892f3
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/obmc/hwmon/ahb/apb/pwm-tacho-controller@1e786000.conf
@@ -0,0 +1,29 @@
+LABEL_fan1=CPU0_FAN
+OFFSET_fan1=0
+CRITLO_fan1=2000
+CRITHI_fan1=29200
+PWM_TARGET_fan1 = "1"
+
+LABEL_fan2=CPU1_FAN
+OFFSET_fan2=0
+CRITLO_fan2=2000
+CRITHI_fan2=29200
+PWM_TARGET_fan2 = "2"
+
+LABEL_fan3=SYS_FAN1
+OFFSET_fan3=0
+CRITLO_fan3=2000
+CRITHI_fan3=29200
+PWM_TARGET_fan3 = "3"
+
+LABEL_fan4=SYS_FAN2
+OFFSET_fan4=0
+CRITLO_fan4=2000
+CRITHI_fan4=29200
+PWM_TARGET_fan4 = "4"
+
+LABEL_fan5=SYS_FAN3
+OFFSET_fan5=0
+CRITLO_fan5=2000
+CRITHI_fan5=29200
+PWM_TARGET_fan5 = "5"
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/vsensor/cpudimm-temp.conf b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/vsensor/cpudimm-temp.conf
new file mode 100755
index 0000000..1398883
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/vsensor/cpudimm-temp.conf
@@ -0,0 +1,8 @@
+LABEL_temp1=cpu0_Temp
+CRITHI_temp1=92000
+CRITLO_temp1=0
+
+LABEL_temp3=DIMM0_Temp
+CRITHI_temp1=80000
+CRITLO_temp1=0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/vsensor/pch-temp.conf b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/vsensor/pch-temp.conf
new file mode 100755
index 0000000..a12a2f7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sensors/phosphor-hwmon%/vsensor/pch-temp.conf
@@ -0,0 +1,4 @@
+LABEL_temp1=PCH_Temp
+CRITHI_temp1=83000
+CRITLO_temp1=0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/power-cap.override.yml b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/power-cap.override.yml
new file mode 100755
index 0000000..5b94e45
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/power-cap.override.yml
@@ -0,0 +1,18 @@
+---
+/xyz/openbmc_project/control/host0/power_cap:
+    - Interface: xyz.openbmc_project.Control.Power.Cap
+      Properties:
+          PowerCap:
+              Default: 200
+              Validation:
+                  Type: "range"
+                  Validator: "0..1000"
+                  Unit: "Watts"
+          PowerCapEnable:
+               Default: 'false'
+          ExceptionAction:
+              Default: Cap::Action::Log
+          CorrectionTime:
+              Default: 5000
+          SamplingPeriod:
+              Default: 10
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/power-restore-policy.override.yml b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/power-restore-policy.override.yml
new file mode 100755
index 0000000..2a1fa6b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/power-restore-policy.override.yml
@@ -0,0 +1,10 @@
+---
+/xyz/openbmc_project/control/host0/power_restore_policy:
+    - Interface: xyz.openbmc_project.Control.Power.RestorePolicy
+      Properties:
+          PowerRestorePolicy:
+              Default: RestorePolicy::Policy::AlwaysOn
+          PowerRestoreDelay:
+              Default: 0
+          PowerRestoreAlwaysOnPolicy:
+              Default: RestorePolicy::AlwaysOnPolicy::Immediately
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/processor-state.override.yml b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/processor-state.override.yml
new file mode 100755
index 0000000..6418528
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/processor-state.override.yml
@@ -0,0 +1,6 @@
+---
+/xyz/openbmc_project/control/processor:
+    - Interface: xyz.openbmc_project.Control.Processor
+      Properties:
+          ProcessorStatus:
+              Default: Processor::State::NORMAL
diff --git a/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/service-status.override.yml b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/service-status.override.yml
new file mode 100755
index 0000000..7c60937
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/service-status.override.yml
@@ -0,0 +1,6 @@
+---
+/xyz/openbmc_project/oem/ServiceStatus:
+    - Interface: xyz.openbmc_project.OEM.ServiceStatus
+      Properties:
+          WebService:
+              Default: 1
diff --git a/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/sol-pattern.override.yml b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/sol-pattern.override.yml
new file mode 100755
index 0000000..691f778
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager/sol-pattern.override.yml
@@ -0,0 +1,39 @@
+---
+/xyz/openbmc_project/oem/solpattern1:
+    - Interface: xyz.openbmc_project.OEM.SOLPattern
+      Properties:
+          MatchCount:
+              Default: 0
+          CriticalThreshold:
+              Default: 10
+          NonCriticalThreshold:
+              Default: 10
+/xyz/openbmc_project/oem/solpattern2:
+    - Interface: xyz.openbmc_project.OEM.SOLPattern
+      Properties:
+          MatchCount:
+              Default: 0
+          CriticalThreshold:
+              Default: 15
+          NonCriticalThreshold:
+              Default: 15
+/xyz/openbmc_project/oem/solpattern3:
+    - Interface: xyz.openbmc_project.OEM.SOLPattern
+      Properties:
+          MatchCount:
+              Default: 0
+          CriticalThreshold:
+              Default: 20
+          NonCriticalThreshold:
+              Default: 20
+
+/xyz/openbmc_project/oem/solpattern4:
+    - Interface: xyz.openbmc_project.OEM.SOLPattern
+      Properties:
+          MatchCount:
+              Default: 0
+          CriticalThreshold:
+              Default: 30
+          NonCriticalThreshold:
+              Default: 30
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager_git.bbappend
new file mode 100755
index 0000000..431bcdf
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/settings/phosphor-settings-manager_git.bbappend
@@ -0,0 +1,7 @@
+FILESEXTRAPATHS_append := ":${THISDIR}/${PN}"
+SRC_URI_append = " file://processor-state.override.yml \
+                   file://sol-pattern.override.yml \
+                   file://power-restore-policy.override.yml \
+                   file://service-status.override.yml \
+                   file://power-cap.override.yml \
+                   "
diff --git a/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf/0001-make-pgood-property-writable.patch b/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf/0001-make-pgood-property-writable.patch
new file mode 100755
index 0000000..b38ad3a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf/0001-make-pgood-property-writable.patch
@@ -0,0 +1,34 @@
+From 1428f5bfd43beac4807b1498995da72c30189ced Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Fri, 7 Feb 2020 14:20:16 +0800
+Subject: [PATCH 1/1] make pgood property writable
+
+---
+ libopenbmc_intf/openbmc_intf.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/openbmc_intf.c b/openbmc_intf.c
+index 32efdd8..c5625d5 100644
+--- a/openbmc_intf.c
++++ b/openbmc_intf.c
+@@ -16273,7 +16273,7 @@ static const _ExtendedGDBusPropertyInfo _control_power_property_info_pgood =
+     -1,
+     (gchar *) "pgood",
+     (gchar *) "i",
+-    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
++    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
+     NULL
+   },
+   "pgood",
+@@ -16286,7 +16286,7 @@ static const _ExtendedGDBusPropertyInfo _control_power_property_info_state =
+     -1,
+     (gchar *) "state",
+     (gchar *) "i",
+-    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
++    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
+     NULL
+   },
+   "state",
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf/gpio_defs.json b/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf/gpio_defs.json
new file mode 100755
index 0000000..b509b5e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf/gpio_defs.json
@@ -0,0 +1,42 @@
+{
+    "gpio_configs": {
+        "power_config": {
+            "power_good_in": "PGOOD",
+            "power_up_outs": "",
+            "reset_outs": ""
+        }
+    },
+
+    "gpio_definitions": [
+        {
+            "name": "PGOOD",
+            "pin": "S1",
+            "direction": "in"
+        },
+        {
+            "name": "POWER_BUTTON",
+            "pin": "E2",
+            "direction": "both"
+        },
+        {
+            "name": "POWER_UP_PIN",
+            "pin": "E3",
+            "direction": "out"
+        },
+        {
+            "name": "RESET_BUTTON",
+            "pin": "E0",
+            "direction": "both"
+        },
+        {
+            "name": "RESET_OUT",
+            "pin": "E1",
+            "direction": "out"
+        },
+        {
+            "name": "ID_BUTTON",
+            "pin": "S0",
+            "direction": "both"
+        }
+    ]
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf_git.bbappend
new file mode 100755
index 0000000..a8918ff
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/skeleton/obmc-libobmc-intf_git.bbappend
@@ -0,0 +1,5 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-make-pgood-property-writable.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching.bb b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching.bb
new file mode 100755
index 0000000..ef068f7
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching.bb
@@ -0,0 +1,31 @@
+SUMMARY = "SOL Pattern Matching"
+DESCRIPTION = "Twitter SOL Pattern Matching Service"
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+SRC_URI = " \
+           file://include \
+           file://service \
+           file://src \
+           file://sol-pattern.json \
+           file://CMakeLists.txt \
+           file://LICENSE \
+          "
+
+SYSTEMD_SERVICE_${PN} = "xyz.openbmc_project.sol-pattern-matching.service"
+
+DEPENDS = "boost \
+           nlohmann-json \
+           sdbusplus \
+          "
+inherit cmake systemd
+
+S = "${WORKDIR}"
+
+EXTRA_OECMAKE = "-DYOCTO=1"
+
+do_install_append() {
+    install -d ${D}/etc
+    install -m 0644 ${S}/sol-pattern.json ${D}/etc/sol-pattern.json
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/CMakeLists.txt b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/CMakeLists.txt
new file mode 100755
index 0000000..c96a6ac
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/CMakeLists.txt
@@ -0,0 +1,66 @@
+cmake_minimum_required (VERSION 3.5 FATAL_ERROR)
+set (BUILD_SHARED_LIBRARIES OFF)
+include (ExternalProject)
+set (CMAKE_CXX_STANDARD 17)
+set (CMAKE_CXX_STANDARD_REQUIRED ON)
+set (
+    CMAKE_CXX_FLAGS
+    "${CMAKE_CXX_FLAGS} -lstdc++fs \
+    -Werror \
+    -Wall \
+    -Wextra \
+    -Wnon-virtual-dtor \
+    -Wold-style-cast \
+    -Wcast-align \
+    -Wunused \
+    -Woverloaded-virtual \
+    -Wpedantic \
+    -Wmisleading-indentation \
+    -Wduplicated-cond \
+    -Wduplicated-branches \
+    -Wlogical-op \
+    -Wnull-dereference \
+    -Wuseless-cast \
+    -Wdouble-promotion \
+    -Wformat=2 \
+    -Wno-sign-compare \
+    -Wno-reorder \
+    -Wshadow \
+    -Wconversion \
+"
+)
+
+set (CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})
+
+project (patern-matching CXX)
+
+option (HUNTER_ENABLED "Enable hunter package pulling" OFF)
+
+# set (EXTERNAL_PACKAGES Boost sdbusplus-project nlohmann-json)
+set (LINK_LIBS -lsystemd stdc++fs sdbusplus)
+
+add_definitions (-DBOOST_ERROR_CODE_HEADER_ONLY)
+add_definitions (-DBOOST_SYSTEM_NO_DEPRECATED)
+add_definitions (-DBOOST_ALL_NO_LIB)
+add_definitions (-DBOOST_NO_RTTI)
+add_definitions (-DBOOST_NO_TYPEID)
+add_definitions (-DBOOST_ASIO_DISABLE_THREADS)
+
+link_directories (${EXTERNAL_INSTALL_LOCATION}/lib)
+
+include_directories (${CMAKE_CURRENT_SOURCE_DIR}/include)
+
+set (SRC_FILES src/PatternMatch.cpp)
+add_executable (sol-pattern-matching src/PatternMatchMain.cpp ${SRC_FILES})
+target_link_libraries (sol-pattern-matching ${LINK_LIBS})
+
+
+set (SERVICE_FILE_SRC_DIR ${PROJECT_SOURCE_DIR}/service)
+set (
+    SERVICE_FILES
+    ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.sol-pattern-matching.service
+)
+set (SERVICE_FILE_INSTALL_DIR /lib/systemd/system/)
+
+install (TARGETS sol-pattern-matching DESTINATION bin)
+install (FILES ${SERVICE_FILES} DESTINATION ${SERVICE_FILE_INSTALL_DIR})
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/LICENSE b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/LICENSE
new file mode 100755
index 0000000..261eeb9
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/include/PatternMatch.hpp b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/include/PatternMatch.hpp
new file mode 100755
index 0000000..1262f3b
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/include/PatternMatch.hpp
@@ -0,0 +1,70 @@
+/*
+// Copyright (c) 2019 Wiwynn Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#pragma once
+
+#include <unistd.h>
+#include <variant>
+#include <iostream>
+#include <systemd/sd-journal.h>
+#include <sdbusplus/asio/object_server.hpp>
+#include <boost/process.hpp>
+#include <nlohmann/json.hpp>
+#include <boost/asio/steady_timer.hpp>
+
+static const std::string sensorPathPrefix = "/xyz/openbmc_project/sensors/";
+static const std::string solValueInterface = "xyz.openbmc_project.Sensor.Value";
+static const std::string solPatternInterface = "xyz.openbmc_project.Sensor.SOLPattern";
+
+static const std::string patternFilePath = "/etc/sol-pattern.json";
+static const int maxPatternNum = 4;
+static const nlohmann::json defaultPattern =
+{
+    {"Pattern1", ""},
+    {"Pattern2", ""},
+    {"Pattern3", ""},
+    {"Pattern4", ""}
+};
+
+class SolPatternSensor
+{
+    public:
+        SolPatternSensor(sdbusplus::asio::object_server& objectServer,
+                        std::shared_ptr<sdbusplus::asio::connection>& conn,
+                        boost::asio::io_service& io, const std::string& sensorType,
+                        const std::string& sensorName, const std::string& ptnString);
+        ~SolPatternSensor();
+
+    private:
+        sdbusplus::asio::object_server& objServer;
+        boost::asio::steady_timer waitTimer;
+        std::shared_ptr<sdbusplus::asio::dbus_interface> sensorInterface;
+        std::shared_ptr<sdbusplus::asio::dbus_interface> patternInterface;
+        std::string patternName;
+        std::string patternString;
+        std::string matchingCmd;
+        unsigned int hitCount;
+        unsigned int newHitCount;
+        int errCount;
+
+        bool setHitCount(const unsigned int& newValue, unsigned int& oldValue);
+        bool setPattern(const std::string& newValue, std::string& oldValue);
+        bool updateHitCount(const unsigned int& newValue);
+
+        void setupMatching(void);
+        bool runMatching(void);
+        void handleResponse(void);
+};
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/service/xyz.openbmc_project.sol-pattern-matching.service b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/service/xyz.openbmc_project.sol-pattern-matching.service
new file mode 100755
index 0000000..f0cf142
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/service/xyz.openbmc_project.sol-pattern-matching.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Twitter SOL Pattern Matching Service
+StopWhenUnneeded=false
+Wants=obmc-console@ttyS2.service
+After=obmc-console@ttyS2.service
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/sol-pattern-matching
+SyslogIdentifier=sol-pattern-matching
+
+[Install]
+WantedBy=multi-user.target
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/sol-pattern.json b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/sol-pattern.json
new file mode 100755
index 0000000..b0acf05
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/sol-pattern.json
@@ -0,0 +1,6 @@
+{
+    "Pattern1": "",
+    "Pattern2": "",
+    "Pattern3": "",
+    "Pattern4": ""
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/src/PatternMatch.cpp b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/src/PatternMatch.cpp
new file mode 100755
index 0000000..087dda6
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/src/PatternMatch.cpp
@@ -0,0 +1,244 @@
+/*
+// Copyright (c) 2019 Wiwynn Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <unistd.h>
+#include <PatternMatch.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <iostream>
+#include <fstream>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+#include <systemd/sd-journal.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+static const std::string solLogFile = "/var/log/obmc-console.log";
+static constexpr unsigned int sensorPollSec = 5;
+static constexpr size_t warnAfterErrorCount = 10;
+
+int execmd(char* cmd,char* result) {
+    char buffer[128];
+    FILE* pipe = popen(cmd, "r");
+    if (!pipe)
+        return -1;
+
+    while(!feof(pipe)) {
+        if(fgets(buffer, 128, pipe)){
+            strcat(result,buffer);
+        }
+    }
+    pclose(pipe);
+    return 0;
+}
+
+SolPatternSensor::SolPatternSensor(
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorType,
+    const std::string& sensorName, const std::string& ptnString):
+    objServer(objectServer), waitTimer(io), patternName(sensorName),
+    patternString(ptnString), hitCount(0), newHitCount(0), errCount(0)
+{
+    std::string dbusPath = sensorPathPrefix + sensorType + sensorName;
+
+    sensorInterface = objectServer.add_interface(
+        dbusPath, solValueInterface.c_str());
+    
+    unsigned int maxValue = 255;
+    unsigned int minValue = 0;
+    bool invalidValue = false;
+    sensorInterface->register_property("InvalidValue", invalidValue);
+    sensorInterface->register_property("MaxValue", maxValue);
+    sensorInterface->register_property("MinValue", minValue);
+
+    // Pattern Hit value
+    sensorInterface->register_property("Value", hitCount,
+    [&](const unsigned int& newValue, unsigned int& oldValue) {
+        return setHitCount(newValue, oldValue);
+    });
+
+    if (!sensorInterface->initialize())
+    {
+        std::cerr << "error initializing value interface\n";
+    }
+
+    // Pattern String
+    patternInterface = objectServer.add_interface(
+        dbusPath, solPatternInterface.c_str());
+    
+    patternInterface->register_property("Pattern", patternString,
+    [&](const std::string& newValue, std::string& oldValue) {
+        return setPattern(newValue, oldValue);
+    });
+
+    if (!patternInterface->initialize())
+    {
+        std::cerr << "error initializing value interface\n";
+    }
+
+    // Matching command
+    matchingCmd = "egrep -c -m 255 \"" + patternString + "\" " + solLogFile;
+
+    setupMatching();
+}
+
+SolPatternSensor::~SolPatternSensor()
+{
+    waitTimer.cancel();
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(patternInterface);
+}
+
+bool SolPatternSensor::setHitCount(const unsigned int& newValue, 
+                                         unsigned int& oldValue)
+{
+     oldValue = newValue;
+     hitCount = newValue;
+
+     return true;
+}
+
+bool SolPatternSensor::setPattern(const std::string& newValue, 
+                                        std::string& oldValue)
+{
+     oldValue = newValue;
+     patternString = newValue;
+     matchingCmd = "egrep -c -m 255 \"" + patternString + "\" " + solLogFile;
+     
+     // Update the Pattern JSON
+     nlohmann::json patternData;
+     std::ifstream patternFileIn(patternFilePath.c_str());
+     if(patternFileIn)
+     {
+        patternData = nlohmann::json::parse(patternFileIn, nullptr, false);
+        patternFileIn.close();
+     }
+
+     if ((!patternData.is_null()) &&
+         (!patternData.is_discarded()))
+     {
+        if(patternData.find(patternName.c_str()) != patternData.end())
+        {
+            // Modify the pattern string and update the pattern json
+            patternData.at(patternName.c_str()) = newValue;
+
+            std::ofstream patternFileOut(patternFilePath.c_str());
+            if(patternFileOut)
+            {
+                patternFileOut << patternData.dump(4);
+                patternFileOut.close();
+            }
+        }
+     }
+
+     return true;
+}
+
+bool SolPatternSensor::updateHitCount(const unsigned int& newValue)
+{
+    sensorInterface->set_property("Value", newValue);
+
+    return true;
+}
+
+void SolPatternSensor::setupMatching(void)
+{
+    bool res = runMatching();
+    if( res != true)
+    {
+        errCount++;
+    }
+    else
+    {
+       errCount = 0;
+    }
+
+    handleResponse();
+}
+
+bool SolPatternSensor::runMatching(void)
+{
+    // if it is a null string
+    if(0 == patternString.size())
+    {
+        newHitCount = 0;
+        return true;
+    }
+
+    char cmd[400]={0};
+    char response[50]="";
+    int rc=0;
+
+    memset(cmd,0,sizeof(cmd));
+    snprintf(cmd,sizeof(cmd),"egrep -a -m 255 -o \"%s\" %s | wc -l ",patternString.c_str(),solLogFile.c_str());
+
+    memset(response,0,sizeof(response));
+    rc=execmd(cmd,response);
+
+    if(rc==0)
+    {
+        newHitCount = static_cast<unsigned int>(strtol(response, NULL, 10));
+    }
+    else
+    {
+        return false;
+    }
+
+    /*boost::process::ipstream ips;
+    boost::process::child c(matchingCmd.c_str(), boost::process::std_out > ips);
+    c.wait();
+
+    if(!c.exit_code())
+    {
+        std::string matchingRes;
+        ips >> matchingRes;
+        newHitCount = static_cast<unsigned int>(strtol(matchingRes.c_str(), NULL, 10));
+    }
+    else
+    {
+        return false;
+    }*/
+
+    return true;
+}
+
+void SolPatternSensor::handleResponse()
+{
+    if (errCount >= warnAfterErrorCount)
+    {
+        updateHitCount(0);
+    }
+    else
+    {
+        if (newHitCount != hitCount)
+        {
+            updateHitCount(newHitCount);
+        }
+    }
+
+    waitTimer.expires_from_now(boost::asio::chrono::seconds(sensorPollSec));
+    waitTimer.async_wait([&](const boost::system::error_code& ec) {
+        if (ec == boost::asio::error::operation_aborted)
+        {
+            return; // we're being canceled
+        }
+        setupMatching();
+    });
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/src/PatternMatchMain.cpp b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/src/PatternMatchMain.cpp
new file mode 100755
index 0000000..7e2a948
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/sol/pattern-matching/src/PatternMatchMain.cpp
@@ -0,0 +1,141 @@
+/*
+// Copyright (c) 2019 Wiwynn Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <PatternMatch.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <filesystem>
+#include <fstream>
+#include <regex>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <systemd/sd-journal.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+bool createDefaultPatternFile()
+{
+    std::ofstream patternFileOut(patternFilePath.c_str());
+
+    if(!patternFileOut)
+    {
+        return false;
+    }
+    else
+    {
+        patternFileOut << defaultPattern.dump(4);
+        patternFileOut.close();
+    }
+
+    return true;
+}
+
+bool createPatternSensors(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::unique_ptr<SolPatternSensor>>& sensors,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection)
+{
+    // 1. Check if the pattern file exists.
+    struct stat buf;
+    if(0 != stat(patternFilePath.c_str(), &buf))
+    {
+        // If the pattern file does not exit, create a new one with default value.
+        // sd_journal_print(LOG_CRIT, "[SOL] Pattern File doesn't exist.\n");
+        std::cerr << "[sol] pattern file does not exist.\n";
+        if(true != createDefaultPatternFile())
+        {
+            return false;
+        }
+    }
+
+    // 2. SOL Pattern JSON Parse
+    nlohmann::json patternData;
+    std::ifstream patternFileIn(patternFilePath.c_str());
+    if(patternFileIn)
+    {
+        patternData = nlohmann::json::parse(patternFileIn, nullptr, false);
+
+        if (patternData.is_discarded())
+        {
+            std::cerr << "[sol] pattern file syntax error \n";
+            if(true != createDefaultPatternFile())
+            {
+                return false;
+            }
+
+            patternData = defaultPattern;
+        }
+
+        patternFileIn.close();
+
+    }
+    else
+    {
+        std::cerr << "[sol] failed to open pattern file \n";
+        if(true != createDefaultPatternFile())
+        {
+            return false;
+        }
+        
+        patternData = defaultPattern;
+    }
+    
+    // 2.2 JSON Parsing
+    std::string ptnName;
+    std::string ptnType;
+    std::string ptnString;
+
+    for(int idx=0; idx<maxPatternNum; idx++)
+    {
+        ptnName = "Pattern" + std::to_string((idx+1));
+        ptnType = "pattern/";
+
+        if(patternData.find(ptnName.c_str()) != patternData.end())
+        {
+            ptnString = patternData.at(ptnName.c_str()).get<std::string>();
+        }
+        else
+        {
+            ptnString = "";
+        }
+        
+        // Print out the pattern string and pattern length 
+        sensors[ptnName] = std::make_unique<SolPatternSensor>(
+            objectServer, dbusConnection, io, ptnType, ptnName, ptnString);
+    }
+
+    return true;
+}
+
+int main(int argc, char *argv[])
+{
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    systemBus->request_name("xyz.openbmc_project.SolPatternSensor");
+    sdbusplus::asio::object_server objectServer(systemBus);
+    boost::container::flat_map<std::string, std::unique_ptr<SolPatternSensor>> sensors;
+    
+    io.post([&]() {
+        createPatternSensors(io, objectServer, sensors, systemBus);
+    });
+
+    // boost::asio::steady_timer filterTimer(io);
+
+    io.run();
+
+    return 0;
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/srvcfg-manager/srvcfg-manager_git.bb b/meta-mct/meta-s5549/recipes-phosphor/srvcfg-manager/srvcfg-manager_git.bb
new file mode 100755
index 0000000..cc16bfa
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/srvcfg-manager/srvcfg-manager_git.bb
@@ -0,0 +1,26 @@
+  
+SUMMARY = "Service configuration manager daemon to control the service"
+DESCRIPTION = "Applications must use service manager daemon to configure \
+              phosphor-ipmi-net, bmcweb, obmc-console etc in the system, \
+              instead of directly controlling the same using 'systemd' or \
+              'iptables'."
+HOMEPAGE = "https://github.com/openbmc/service-config-manager"
+PR = "r1"
+PV = "1.0+git${SRCPV}"
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://LICENSE;md5=7becf906c8f8d03c237bad13bc3dac53"
+
+SRC_URI = "git://github.com/openbmc/service-config-manager"
+SRCREV = "1f3813f819f11b27f515891c239113f0b4e60936"
+
+inherit meson pkgconfig systemd
+
+S = "${WORKDIR}/git"
+SYSTEMD_SERVICE_${PN} = "srvcfg-manager.service"
+
+DEPENDS = " \
+    boost \
+    phosphor-logging \
+    sdbusplus \
+    systemd \
+    "
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-post-code-manager/0001-Implement-the-clear-bios-post-code-feature-for-host-.patch b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-post-code-manager/0001-Implement-the-clear-bios-post-code-feature-for-host-.patch
new file mode 100755
index 0000000..21e1690
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-post-code-manager/0001-Implement-the-clear-bios-post-code-feature-for-host-.patch
@@ -0,0 +1,56 @@
+From c7dd8fafd9042959cd86fa44676a77297e29b100 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 21 Sep 2020 15:04:48 +0800
+Subject: [PATCH] Implement the clear bios post code feature for host warn
+ reset
+
+---
+ inc/post_code.hpp | 25 +++++++++++++++++++++++++
+ 1 file changed, 25 insertions(+)
+ mode change 100644 => 100755 inc/post_code.hpp
+
+diff --git a/inc/post_code.hpp b/inc/post_code.hpp
+old mode 100644
+new mode 100755
+index 3c4ac4a..d651c39
+--- a/inc/post_code.hpp
++++ b/inc/post_code.hpp
+@@ -117,6 +117,30 @@ struct PostCode : sdbusplus::server::object_t<post_code>
+                         }
+                     }
+                 }
++            }),
++        propertiesChangedSignalLpcReset(
++            bus,
++            sdbusplus::bus::match::rules::type::signal() +
++                sdbusplus::bus::match::rules::member("LpcReset"),
++            [this](sdbusplus::message::message &msg) {
++                std::string objectName;
++                uint32_t value;
++                msg.read(value);
++
++                if(value)
++                {
++                    if (this->currentBootCycleIndex() >=
++                        this->maxBootCycleNum())
++                    {
++                        this->currentBootCycleIndex(1);
++                    }
++                    else
++                    {
++                        this->currentBootCycleIndex(
++                            this->currentBootCycleIndex() + 1);
++                    }
++                    this->postCodes.clear();
++                }
+             })
+     {
+         phosphor::logging::log<phosphor::logging::level::INFO>(
+@@ -154,6 +178,7 @@ struct PostCode : sdbusplus::server::object_t<post_code>
+     void savePostCodes(uint64_t code);
+     sdbusplus::bus::match_t propertiesChangedSignalRaw;
+     sdbusplus::bus::match_t propertiesChangedSignalCurrentHostState;
++    sdbusplus::bus::match_t propertiesChangedSignalLpcReset;
+     fs::path serialize(const std::string &path);
+     bool deserialize(const fs::path &path, uint16_t &index);
+     bool deserializePostCodes(const fs::path &path,
diff --git a/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-post-code-manager_%.bbappend b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-post-code-manager_%.bbappend
new file mode 100755
index 0000000..8c6e192
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-post-code-manager_%.bbappend
@@ -0,0 +1,4 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-Implement-the-clear-bios-post-code-feature-for-host-.patch"
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0001-Detect-host-status-by-pgood.patch b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0001-Detect-host-status-by-pgood.patch
new file mode 100755
index 0000000..e63a8f4
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0001-Detect-host-status-by-pgood.patch
@@ -0,0 +1,137 @@
+From 2be12fa2d6f6907251fe2edb7a831a261c4c4e30 Mon Sep 17 00:00:00 2001
+From: Ray Lue <ray.lue@mic.com.tw>
+Date: Wed, 11 Mar 2020 18:56:40 +0800
+Subject: [PATCH 1/1] Detect host status by pgood
+
+---
+ host_check_main_mct.cpp | 104 ++++++++++++++++++++++++++++++++++++++++
+ meson.build             |   2 +-
+ 2 files changed, 105 insertions(+), 1 deletion(-)
+ create mode 100644 host_check_main_mct.cpp
+
+diff --git a/host_check_main_mct.cpp b/host_check_main_mct.cpp
+new file mode 100644
+index 0000000..1638733
+--- /dev/null
++++ b/host_check_main_mct.cpp
+@@ -0,0 +1,104 @@
++#include <cstdlib>
++#include <unistd.h>
++#include <iostream>
++#include <fstream>
++#include <cstdio>
++#include <sdbusplus/bus.hpp>
++#include <phosphor-logging/log.hpp>
++#include <config.h>
++
++using namespace phosphor::logging;
++
++bool hostRunning = false;
++
++// Determine power status by getting pgood
++void determineInitialState()
++{
++    using sdbusplus::exception::SdBusError;
++
++    sdbusplus::message::variant<int> pgood = -1;
++	int save_pgood = -1;
++    auto bus = sdbusplus::bus::new_default();
++    auto method = bus.new_method_call(
++        "org.openbmc.control.Power", "/org/openbmc/control/power0",
++        "org.freedesktop.DBus.Properties", "Get");
++
++    method.append("org.openbmc.control.Power", "pgood");
++    try
++    {
++        auto reply = bus.call(method);
++        if (reply.is_method_error())
++        {
++            log<level::ERR>(
++                "Error in response message - could not get initial pgood");
++            goto fail;
++        }
++
++        try
++        {
++            reply.read(pgood);
++        }
++        catch (const SdBusError& e)
++        {
++            log<level::ERR>("Error in bus response - bad encoding of pgood",
++                            entry("ERROR=%s", e.what()),
++                            entry("REPLY_SIG=%s", reply.get_signature()));
++            goto fail;
++        }
++		save_pgood = std::get<int>(pgood);
++        if (save_pgood == 1)
++        {
++            log<level::INFO>("Initial Host State will be On");
++            hostRunning = true;
++            return;
++        }
++    }
++    catch (const SdBusError& e)
++    {
++        // It's acceptable for the pgood state service to not be available
++        // since it will notify us of the pgood state when it comes up.
++        if (e.name() != nullptr &&
++            strcmp("org.freedesktop.DBus.Error.ServiceUnknown", e.name()) == 0)
++        {
++            goto fail;
++        }
++
++        // Only log for unexpected error types.
++        log<level::ERR>("Error performing call to get pgood",
++                        entry("ERROR=%s", e.what()));
++        goto fail;
++    }
++
++fail:
++    log<level::INFO>("Initial Host State will be Off");
++    hostRunning = false;
++
++    return;
++}
++
++int main(int argc, char* argv[])
++{
++    log<level::INFO>("Check if host is running");
++
++    determineInitialState();    
++
++    // If host running then create file
++    if (hostRunning)
++    {
++        log<level::INFO>("Host is running!");
++        // Create file for host instance and create in filesystem to indicate
++        // to services that host is running
++        auto size = std::snprintf(nullptr, 0, HOST_RUNNING_FILE, 0);
++        size++; // null
++        std::unique_ptr<char[]> buf(new char[size]);
++        std::snprintf(buf.get(), size, HOST_RUNNING_FILE, 0);
++        std::ofstream outfile(buf.get());
++        outfile.close();
++    }
++    else
++    {
++        log<level::INFO>("Host is not running!");
++    }
++
++    return 0;
++}
+diff --git a/meson.build b/meson.build
+index f4eb4bb..2f83960 100644
+--- a/meson.build
++++ b/meson.build
+@@ -90,7 +90,7 @@ executable('phosphor-discover-system-state',
+ )
+ 
+ executable('phosphor-host-check',
+-            'host_check_main.cpp',
++            'host_check_main_mct.cpp',
+             dependencies: [
+             sdbusplus, phosphorlogging
+             ],
+-- 
+2.22.0
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0002-Determine-the-host-initial-state-with-pgood.patch b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0002-Determine-the-host-initial-state-with-pgood.patch
new file mode 100755
index 0000000..1a1cd79
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0002-Determine-the-host-initial-state-with-pgood.patch
@@ -0,0 +1,73 @@
+From 859a3316e480ed96bbf6b31ee0bac851d4c985bb Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Fri, 27 Dec 2019 13:55:36 +0800
+Subject: [PATCH] Determine-the-host-initial-state-with-pgood
+
+---
+ host_state_manager.cpp | 42 ++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 42 insertions(+)
+ mode change 100644 => 100755 host_state_manager.cpp
+
+diff --git a/host_state_manager.cpp b/host_state_manager.cpp
+old mode 100644
+new mode 100755
+index 025d8b0..32451df
+--- a/host_state_manager.cpp
++++ b/host_state_manager.cpp
+@@ -95,7 +95,48 @@ void Host::subscribeToSystemdSignals()
+ 
+ void Host::determineInitialState()
+ {
++    /*  Determine the host initial state with the pgood property.
++        Running / Off
++    */
++    sdbusplus::message::variant<int> pgood = -1;
++    auto method = this->bus.new_method_call(
++        "org.openbmc.control.Power", "/org/openbmc/control/power0",
++        "org.freedesktop.DBus.Properties", "Get");
++
++    method.append("org.openbmc.control.Power", "pgood");
++    try
++    {
++        auto reply = this->bus.call(method);
++        reply.read(pgood);
++
++        if (sdbusplus::message::variant_ns::get<int>(pgood) == 1)
++        {
++            log<level::INFO>("Initial Host State will be Running",
++                        entry("CURRENT_HOST_STATE=%s",
++                            convertForMessage(HostState::Running).c_str()));
++            server::Host::currentHostState(HostState::Running);
++            server::Host::requestedHostTransition(Transition::On);
++        }
++        else
++        {
++            log<level::INFO>("Initial Host State will be Off",
++                        entry("CURRENT_HOST_STATE=%s",
++                            convertForMessage(HostState::Off).c_str()));
++            server::Host::currentHostState(HostState::Off);
++            server::Host::requestedHostTransition(Transition::Off);
++        }
++    }
++    catch (const SdBusError& e)
++    {
++        // Only log for unexpected error types.
++        log<level::ERR>("Error performing call to get pgood",
++                        entry("ERROR=%s", e.what()));
++
++        server::Host::currentHostState(HostState::Off);
++        server::Host::requestedHostTransition(Transition::Off);
++    }
+ 
++/*
+     if (stateActive(HOST_STATE_POWERON_MIN_TGT))
+     {
+         log<level::INFO>("Initial Host State will be Running",
+@@ -112,6 +153,7 @@ void Host::determineInitialState()
+         server::Host::currentHostState(HostState::Off);
+         server::Host::requestedHostTransition(Transition::Off);
+     }
++*/
+ 
+     if (!deserialize(HOST_STATE_PERSIST_PATH))
+     {
diff --git a/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0003-Implement-the-AC-restore-random-and-fixed-delay.patch b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0003-Implement-the-AC-restore-random-and-fixed-delay.patch
new file mode 100755
index 0000000..f0c8475
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0003-Implement-the-AC-restore-random-and-fixed-delay.patch
@@ -0,0 +1,105 @@
+From 6a656b0b53c0bab9b763a18836f399d453e13446 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 23 Mar 2020 10:18:35 +0800
+Subject: [PATCH] Implement the AC restore random and fixed delay
+
+---
+ discover_system_state.cpp | 72 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 72 insertions(+)
+ mode change 100644 => 100755 discover_system_state.cpp
+
+diff --git a/discover_system_state.cpp b/discover_system_state.cpp
+old mode 100644
+new mode 100755
+index 836011a..c634606
+--- a/discover_system_state.cpp
++++ b/discover_system_state.cpp
+@@ -2,6 +2,8 @@
+ #include <iostream>
+ #include <map>
+ #include <string>
++#include <chrono>
++#include <random>
+ #include "config.h"
+ #include <systemd/sd-bus.h>
+ #include <sdbusplus/exception.hpp>
+@@ -179,6 +181,76 @@ int main(int argc, char** argv)
+         RestorePolicy::convertPolicyFromString(powerPolicy))
+     {
+         log<level::INFO>("power_policy=ALWAYS_POWER_ON, powering host on");
++
++        auto method = bus.new_method_call(
++            settings.service(settings.powerRestorePolicy, powerRestoreIntf).c_str(),
++            settings.powerRestorePolicy.c_str(), "org.freedesktop.DBus.Properties",
++            "Get");
++        method.append(powerRestoreIntf, "PowerRestoreAlwaysOnPolicy");
++
++        sdbusplus::message::variant<std::string> result;
++        try
++        {
++            auto reply = bus.call(method);
++            reply.read(result);
++        }
++        catch (const SdBusError& e)
++        {
++            log<level::ERR>("Error in PowerRestoreAlwaysOnPolicy Get",
++                            entry("ERROR=%s", e.what()));
++            elog<InternalFailure>();
++        }
++
++        auto powerAlwaysOnPolicy = sdbusplus::message::variant_ns::get<std::string>(result);
++
++        if (RestorePolicy::AlwaysOnPolicy::Random ==
++            RestorePolicy::convertAlwaysOnPolicyFromString(powerAlwaysOnPolicy) ||
++            RestorePolicy::AlwaysOnPolicy::Fixed ==
++            RestorePolicy::convertAlwaysOnPolicyFromString(powerAlwaysOnPolicy))
++        {
++            auto method = bus.new_method_call(
++                settings.service(settings.powerRestorePolicy, powerRestoreIntf).c_str(),
++                settings.powerRestorePolicy.c_str(), "org.freedesktop.DBus.Properties",
++                "Get");
++            method.append(powerRestoreIntf, "PowerRestoreDelay");
++
++            sdbusplus::message::variant<uint32_t> result;
++            try
++            {
++                auto reply = bus.call(method);
++                reply.read(result);
++            }
++            catch (const SdBusError& e)
++            {
++                log<level::ERR>("Error in PowerRestoreDelay Get",
++                                entry("ERROR=%s", e.what()));
++                elog<InternalFailure>();
++            }
++
++            auto powerRestoreDelay = sdbusplus::message::variant_ns::get<uint32_t>(result);
++
++            if (RestorePolicy::AlwaysOnPolicy::Random ==
++                RestorePolicy::convertAlwaysOnPolicyFromString(powerAlwaysOnPolicy))
++            {
++                std::random_device rd;
++                std::default_random_engine gen = std::default_random_engine(rd());
++                std::uniform_int_distribution<int> dis(0,powerRestoreDelay);
++                powerRestoreDelay = dis(gen);
++            }
++
++            log<level::INFO>("Checking power always on policy and setting delay",
++                entry("POWER_ALWAYS_ON_POLICY=%s", powerAlwaysOnPolicy.c_str()),
++                entry("POWER_RESTORE_DELAY=%d", powerRestoreDelay));
++
++            std::this_thread::sleep_for (std::chrono::seconds(powerRestoreDelay));
++        }
++        else{
++            log<level::INFO>("Checking power always on policy",
++                entry("POWER_ALWAYS_ON_POLICY=%s", powerAlwaysOnPolicy.c_str()));
++        }
++
++        log<level::INFO>("power_policy=ALWAYS_POWER_ON, Starting power on");
++
+         setProperty(bus, hostPath, HOST_BUSNAME, "RequestedHostTransition",
+                     convertForMessage(server::Host::Transition::On));
+     }
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0004-ignore-power-policy-when-BMC-reset.patch b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0004-ignore-power-policy-when-BMC-reset.patch
new file mode 100755
index 0000000..bbb94fa
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager/0004-ignore-power-policy-when-BMC-reset.patch
@@ -0,0 +1,21 @@
+From dace17de4c9ee2f7ee11692ae5ef79d0ae4ba231 Mon Sep 17 00:00:00 2001
+From: "wendy.shi" <wendy.shi@mic.com.tw>
+Date: Mon, 12 Oct 2020 09:42:53 +0800
+Subject: [PATCH] ignore power policy when BMC reset
+
+---
+ service_files/phosphor-discover-system-state@.service | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/service_files/phosphor-discover-system-state@.service b/service_files/phosphor-discover-system-state@.service
+index 21554c9..43e314b 100644
+--- a/service_files/phosphor-discover-system-state@.service
++++ b/service_files/phosphor-discover-system-state@.service
+@@ -8,6 +8,7 @@ Wants=mapper-wait@-xyz-openbmc_project-state-chassis%i.service
+ After=mapper-wait@-xyz-openbmc_project-state-chassis%i.service
+ After=op-reset-chassis-on@%i.service
+ ConditionPathExists=!/run/openbmc/chassis@%i-on
++ConditionPathExists=!/run/bmcRebootFlag
+ 
+ [Service]
+ Restart=no
diff --git a/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager_git.bbappend
new file mode 100755
index 0000000..5876312
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/state/phosphor-state-manager_git.bbappend
@@ -0,0 +1,8 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-Detect-host-status-by-pgood.patch \
+            file://0002-Determine-the-host-initial-state-with-pgood.patch \
+            file://0003-Implement-the-AC-restore-random-and-fixed-delay.patch \
+            file://0004-ignore-power-policy-when-BMC-reset.patch \
+           "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/0001-Fix-watchdog-timeout-action-do-not-work.patch b/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/0001-Fix-watchdog-timeout-action-do-not-work.patch
new file mode 100755
index 0000000..b96a901
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/0001-Fix-watchdog-timeout-action-do-not-work.patch
@@ -0,0 +1,142 @@
+From 840387d449e6175fceb95ae852f37f7cd9a6e826 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 20 May 2020 13:02:19 +0800
+Subject: [PATCH] Fix watchdog timeout action do not work
+
+Change timeout function implementation from timeout target to power target
+Create the function for setting dbus RequestedHostTransition parameter
+---
+ watchdog.cpp | 72 ++++++++++++++++++++++++++++++++++++++++++++++++------------
+ watchdog.hpp |  8 +++++++
+ 2 files changed, 66 insertions(+), 14 deletions(-)
+ mode change 100644 => 100755 watchdog.cpp
+ mode change 100644 => 100755 watchdog.hpp
+
+diff --git a/watchdog.cpp b/watchdog.cpp
+old mode 100644
+new mode 100755
+index 57e9050..daf98a1
+--- a/watchdog.cpp
++++ b/watchdog.cpp
+@@ -131,22 +131,21 @@ void Watchdog::timeOutHandler()
+             entry("TIMER_USE=%s", convertForMessage(expiredTimerUse()).c_str()),
+             entry("TARGET=%s", target->second.c_str()));
+ 
+-        try
++        switch (action)
+         {
+-            auto method = bus.new_method_call(SYSTEMD_SERVICE, SYSTEMD_ROOT,
+-                                              SYSTEMD_INTERFACE, "StartUnit");
+-            method.append(target->second);
+-            method.append("replace");
+-
+-            bus.call_noreply(method);
+-        }
+-        catch (const SdBusError& e)
+-        {
+-            log<level::ERR>("watchdog: Failed to start unit",
+-                            entry("TARGET=%s", target->second.c_str()),
+-                            entry("ERROR=%s", e.what()));
+-            commit<InternalFailure>();
++            case Action::None:
++                break;
++            case Action::HardReset:
++                initiate_state_transition(State::Host::Transition::ForceWarmReboot);
++                break;
++            case Action::PowerOff:
++                initiate_state_transition(State::Host::Transition::Off);
++                break;
++            case Action::PowerCycle:
++                initiate_state_transition(State::Host::Transition::Reboot);
++                break;
+         }
++
+     }
+ 
+     tryFallbackOrDisable();
+@@ -175,5 +174,50 @@ void Watchdog::tryFallbackOrDisable()
+     WatchdogInherits::enabled(false);
+ }
+ 
++std::string Watchdog::getService(const std::string& path, const std::string& interface)
++{
++    constexpr auto mapperObjPath = "/xyz/openbmc_project/object_mapper";
++    constexpr auto mapperService = "xyz.openbmc_project.ObjectMapper";
++    constexpr auto mapperIface = "xyz.openbmc_project.ObjectMapper";
++
++    auto method = bus.new_method_call(mapperService, mapperObjPath, mapperIface,
++                                      "GetObject");
++    method.append(path, std::vector{interface});
++    auto result = bus.call(method);
++
++    std::map<std::string, std::vector<std::string>> objectData;
++    result.read(objectData);
++
++    return objectData.begin()->first;
++}
++
++void Watchdog::initiate_state_transition(State::Host::Transition transition)
++{
++    // OpenBMC Host State Manager dbus framework
++    constexpr auto HOST_STATE_MANAGER_ROOT = "/xyz/openbmc_project/state/host0";
++    constexpr auto HOST_STATE_MANAGER_IFACE = "xyz.openbmc_project.State.Host";
++    constexpr auto DBUS_PROPERTY_IFACE = "org.freedesktop.DBus.Properties";
++    constexpr auto PROPERTY = "RequestedHostTransition";
++
++    std::variant<std::string> state = convertForMessage(transition);
++
++    try
++    {
++        auto service = getService(HOST_STATE_MANAGER_ROOT, DBUS_PROPERTY_IFACE);
++        auto method = bus.new_method_call(service.c_str(), HOST_STATE_MANAGER_ROOT,
++                                          DBUS_PROPERTY_IFACE, "Set");
++        method.append(HOST_STATE_MANAGER_IFACE, PROPERTY , state);
++
++        bus.call_noreply(method);
++
++        log<level::INFO>("Transition request initiated successfully");
++    }
++    catch (const SdBusError& e)
++    {
++        log<level::ERR>("Failed to initiate transition",
++                        entry("ERRNO=0x%X", e.what()));
++    }
++}
++
+ } // namespace watchdog
+ } // namespace phosphor
+diff --git a/watchdog.hpp b/watchdog.hpp
+old mode 100644
+new mode 100755
+index 7de9bb3..9f3b650
+--- a/watchdog.hpp
++++ b/watchdog.hpp
+@@ -9,6 +9,7 @@
+ #include <unordered_map>
+ #include <utility>
+ #include <xyz/openbmc_project/State/Watchdog/server.hpp>
++#include <xyz/openbmc_project/State/Host/server.hpp>
+ 
+ namespace phosphor
+ {
+@@ -17,6 +18,7 @@ namespace watchdog
+ 
+ constexpr auto DEFAULT_MIN_INTERVAL_MS = 0;
+ namespace Base = sdbusplus::xyz::openbmc_project::State::server;
++namespace State = sdbusplus::xyz::openbmc_project::State::server;
+ using WatchdogInherits = sdbusplus::server::object::object<Base::Watchdog>;
+ 
+ /** @class Watchdog
+@@ -170,6 +172,12 @@ class Watchdog : public WatchdogInherits
+ 
+     /** @brief Attempt to enter the fallback watchdog or disables it */
+     void tryFallbackOrDisable();
++
++    /** @brief Calls into Object Mapper to get Dbus object service */
++    std::string getService(const std::string& path, const std::string& interface);
++
++    /** @brief Calls into Host State Manager Dbus object */
++    void initiate_state_transition(State::Host::Transition transition);
+ };
+ 
+ } // namespace watchdog
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/0002-Implement-add-SEL-feature-for-watchdog-timeout.patch b/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/0002-Implement-add-SEL-feature-for-watchdog-timeout.patch
new file mode 100755
index 0000000..79e4b67
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/0002-Implement-add-SEL-feature-for-watchdog-timeout.patch
@@ -0,0 +1,112 @@
+From 8ebd78f9a9ab4403e63b7284d09531049e50bf0e Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 20 May 2020 17:37:21 +0800
+Subject: [PATCH] Implement add SEL feature for watchdog timeout
+
+---
+ watchdog.cpp | 70 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ watchdog.hpp |  3 +++
+ 2 files changed, 73 insertions(+)
+
+diff --git a/watchdog.cpp b/watchdog.cpp
+index daf98a1..3483127 100755
+--- a/watchdog.cpp
++++ b/watchdog.cpp
+@@ -148,6 +148,8 @@ void Watchdog::timeOutHandler()
+ 
+     }
+ 
++    addWatchdogSEL(action,expiredTimerUse());
++
+     tryFallbackOrDisable();
+ }
+ 
+@@ -174,6 +176,74 @@ void Watchdog::tryFallbackOrDisable()
+     WatchdogInherits::enabled(false);
+ }
+ 
++void Watchdog::addWatchdogSEL(Base::Watchdog::Action action,Base::Watchdog::TimerUse timeUse){
++
++    static constexpr auto SEL_LOGGER_SERVICE =
++        "xyz.openbmc_project.Logging.IPMI";
++    static constexpr auto SEL_LOGGER_ROOT =
++        "/xyz/openbmc_project/Logging/IPMI";
++    static constexpr auto SEL_LOGGER_INTERFACE =
++        "xyz.openbmc_project.Logging.IPMI";
++    static constexpr auto SEL_LOGGER_METHOD = "IpmiSelAdd";
++    static constexpr const uint16_t ipmiBMCSlaveAddr = 0x20;
++
++    uint8_t eventData1=0xff;
++    uint8_t eventData2=0xff;
++    switch (action)
++    {
++        case Action::None:
++            eventData1 = 0;
++            break;
++        case Action::HardReset:
++            eventData1 = 1;
++            break;
++        case Action::PowerOff:
++            eventData1 = 2;
++            break;
++        case Action::PowerCycle:
++            eventData1 = 3;
++            break;
++    }
++
++    switch (timeUse)
++    {
++        case TimerUse::Reserved:
++            eventData2 = 0;
++            break;
++        case TimerUse::BIOSFRB2:
++            eventData2 = 1;
++            break;
++        case TimerUse::BIOSPOST:
++            eventData2 = 2;
++            break;
++        case TimerUse::OSLoad:
++            eventData2 = 3;
++            break;
++        case TimerUse::SMSOS:
++            eventData2 = 4;
++            break;
++        case TimerUse::OEM:
++            eventData2 = 5;
++            break;
++    }
++
++    try
++    {
++        auto method =
++            bus.new_method_call(SEL_LOGGER_SERVICE, SEL_LOGGER_ROOT,
++                                SEL_LOGGER_INTERFACE, SEL_LOGGER_METHOD);
++        method.append("watchdog: Timed out",
++                      "/xyz/openbmc_project/sensors/watchdog2/WATCHDOG2",
++                      std::vector<uint8_t>({eventData1, eventData2, 0xFF}), true,
++                      ipmiBMCSlaveAddr);
++        bus.call_noreply(method);
++    }
++    catch (const SdBusError& e)
++    {
++        log<level::ERR>(e.what());
++    }
++}
++
+ std::string Watchdog::getService(const std::string& path, const std::string& interface)
+ {
+     constexpr auto mapperObjPath = "/xyz/openbmc_project/object_mapper";
+diff --git a/watchdog.hpp b/watchdog.hpp
+index 9f3b650..f4c8e72 100755
+--- a/watchdog.hpp
++++ b/watchdog.hpp
+@@ -173,6 +173,9 @@ class Watchdog : public WatchdogInherits
+     /** @brief Attempt to enter the fallback watchdog or disables it */
+     void tryFallbackOrDisable();
+ 
++    /** @brief Add a watchdog SEL to SEL list  */
++    void addWatchdogSEL(Base::Watchdog::Action action,Base::Watchdog::TimerUse timeUse);
++
+     /** @brief Calls into Object Mapper to get Dbus object service */
+     std::string getService(const std::string& path, const std::string& interface);
+ 
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/obmc-enable-host-watchdog@.service b/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/obmc-enable-host-watchdog@.service
new file mode 100755
index 0000000..9fc3baf
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog/obmc-enable-host-watchdog@.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Start Watchdog%i
+Wants=obmc-host-started@%i.target
+After=obmc-host-started@%i.target
+Wants=mapper-wait@-xyz-openbmc_project-watchdog-host%i.service
+After=mapper-wait@-xyz-openbmc_project-watchdog-host%i.service
+Conflicts=obmc-host-stop@%i.target
+ConditionPathExists=!/run/openbmc/host@%i-on
+
+[Service]
+Type=oneshot
+ExecStart=/bin/sh -c "busctl call `mapper get-service /xyz/openbmc_project/watchdog/host%i` /xyz/openbmc_project/watchdog/host%i org.freedesktop.DBus.Properties Set ssv xyz.openbmc_project.State.Watchdog Enabled b false"
+RemainAfterExit=yes
+SyslogIdentifier=obmc-enable-host-watchdog
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog_%.bbappend b/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog_%.bbappend
new file mode 100755
index 0000000..df8cae0
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/phosphor-watchdog_%.bbappend
@@ -0,0 +1,6 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRC_URI += "file://0001-Fix-watchdog-timeout-action-do-not-work.patch \
+            file://0002-Implement-add-SEL-feature-for-watchdog-timeout.patch \
+            "
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog.bb b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog.bb
new file mode 100755
index 0000000..e0fbfc0
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog.bb
@@ -0,0 +1,16 @@
+SUMMARY = "System watchdog"
+DESCRIPTION = "BMC hardware watchdog service that is used to reset BMC \
+               when unrecoverable events occurs"
+
+inherit allarch
+inherit obmc-phosphor-systemd
+
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+SYSTEMD_SERVICE_${PN} += "system-watchdog.service"
+SYSTEMD_ENVIRONMENT_FILE_${PN} += "obmc/system-watchdog/system-watchdog.conf"
+
+SYSTEMD_SERVICE_${PN} += "watchdog-reset.service"
+SYSTEMD_SERVICE_${PN} += "watchdog-clear-failures.service"
+SYSTEMD_SERVICE_${PN} += "watchdog-clear-failures.timer"
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/obmc/system-watchdog/system-watchdog.conf b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/obmc/system-watchdog/system-watchdog.conf
new file mode 100755
index 0000000..63fca35
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/obmc/system-watchdog/system-watchdog.conf
@@ -0,0 +1,3 @@
+TIMEOUT=60
+INTERVAL=10
+DEVICE=/dev/watchdog1
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/system-watchdog.service b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/system-watchdog.service
new file mode 100755
index 0000000..3175217
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/system-watchdog.service
@@ -0,0 +1,11 @@
+[Unit]
+Description=BMC Hardware Watchdog Daemon
+
+[Service]
+EnvironmentFile=/etc/default/obmc/system-watchdog/system-watchdog.conf
+ExecStart=/sbin/watchdog -T ${{TIMEOUT}} -t ${{INTERVAL}} -F ${{DEVICE}}
+ExecStop=/sbin/devmem 0x1e78502c 8 0
+KillSignal=SIGKILL
+
+[Install]
+WantedBy=basic.target
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-clear-failures.service b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-clear-failures.service
new file mode 100755
index 0000000..b824f82
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-clear-failures.service
@@ -0,0 +1,9 @@
+[Unit]
+Description=Reset BMC Hardware Watchdog Failure Count
+
+[Service]
+ExecStart=busctl call xyz.openbmc_project.U_Boot.Environment.Manager \
+          /xyz/openbmc_project/u_boot/environment/mgr \
+          xyz.openbmc_project.U_Boot.Environment.Manager \
+          Write ss bootfailures 0
+Type=oneshot
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-clear-failures.timer b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-clear-failures.timer
new file mode 100755
index 0000000..031bc9f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-clear-failures.timer
@@ -0,0 +1,8 @@
+[Unit]
+Description=Starts the clear watchdog serivce after 30 minutes
+
+[Timer]
+OnBootSec=30min
+
+[Install]
+WantedBy=timers.target
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-reset.service b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-reset.service
new file mode 100755
index 0000000..938ac48
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/watchdog/system-watchdog/watchdog-reset.service
@@ -0,0 +1,7 @@
+[Unit]
+Description=Reset BMC Using Hardware Watchdog
+Conflicts=system-watchdog.service
+
+[Service]
+ExecStart=/sbin/watchdog -T 0 -F /dev/watchdog1
+Type=oneshot
\ No newline at end of file
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0002-Implement-the-feature-for-setting-web-status-to-enab.patch b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0002-Implement-the-feature-for-setting-web-status-to-enab.patch
new file mode 100755
index 0000000..26599cb
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0002-Implement-the-feature-for-setting-web-status-to-enab.patch
@@ -0,0 +1,195 @@
+From 935b90a31a10e0494ff2f5b82b15077a5d3ef0ef Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Thu, 9 Apr 2020 16:02:27 +0800
+Subject: [PATCH] Implement the feature for setting web status to enable or
+ disable
+
+Create a function to get service status via rest api
+Check the web service flag to set web enable or disable
+Create the web disabled notification
+---
+ app/common/services/api-utils.js            | 10 +++++
+ app/index.js                                | 57 +++++++++++++++++++++--------
+ app/login/controllers/login-controller.html |  3 ++
+ app/login/controllers/login-controller.js   | 21 ++++++++++-
+ 4 files changed, 73 insertions(+), 18 deletions(-)
+ mode change 100644 => 100755 app/common/services/api-utils.js
+ mode change 100644 => 100755 app/index.js
+ mode change 100644 => 100755 app/login/controllers/login-controller.html
+ mode change 100644 => 100755 app/login/controllers/login-controller.js
+
+diff --git a/app/common/services/api-utils.js b/app/common/services/api-utils.js
+old mode 100644
+new mode 100755
+index f10476d..1886c7a
+--- a/app/common/services/api-utils.js
++++ b/app/common/services/api-utils.js
+@@ -1780,6 +1780,16 @@ window.angular && (function(angular) {
+                 return response.data;
+               });
+         },
++        getServiceStatus: function() {
++          return $http({
++                   method: 'GET',
++                   url: DataService.getHost() + '/xyz/openbmc_project/oem/ServiceStatus',
++                   withCredentials: true
++                 })
++              .then(function(response) {
++                return response.data;
++              });
++        },
+       };
+       return SERVICE;
+     }
+diff --git a/app/index.js b/app/index.js
+old mode 100644
+new mode 100755
+index 156fab6..668398e
+--- a/app/index.js
++++ b/app/index.js
+@@ -187,29 +187,54 @@ window.angular && (function(angular) {
+         }
+       ])
+       .run([
+-        '$rootScope', '$location', 'dataService', 'userModel', '$cookies',
+-        function($rootScope, $location, dataService, userModel, $cookies) {
++        '$rootScope', '$location', 'dataService', 'userModel', '$cookies', 'APIUtils',
++        function($rootScope, $location, dataService, userModel, $cookies,  APIUtils) {
+           $rootScope.dataService = dataService;
+           dataService.path = $location.path();
+-          $rootScope.$on('$routeChangeStart', function(event, next, current) {
+-            if (next.$$route == null || next.$$route == undefined) return;
+-            if (next.$$route.authenticated) {
+-              if (!userModel.isLoggedIn()) {
+-                $location.path('/login');
++
++          function routeChangeStart (){
++            $rootScope.$on('$routeChangeStart', function(event, next, current) {
++              if (next.$$route == null || next.$$route == undefined) return;
++              if (next.$$route.authenticated) {
++                if (!userModel.isLoggedIn()) {
++                  $location.path('/login');
++                }
++                else{
++                  if(!$rootScope.isWebEnable){
++                    $location.path('/login');
++                  }
++                }
+               }
+-            }
+ 
+-            if (next.$$route.originalPath == '/' ||
+-                next.$$route.originalPath == '/login') {
+-              if (userModel.isLoggedIn()) {
+-                if (current && current.$$route) {
+-                  $location.path(current.$$route.originalPath);
+-                } else {
+-                  $location.path('/overview/server');
++              if (next.$$route.originalPath == '/' ||
++                  next.$$route.originalPath == '/login') {
++                if (userModel.isLoggedIn()) {
++                  if (current && current.$$route) {
++                    $location.path(current.$$route.originalPath);
++                  } else {
++                    if(!$rootScope.isWebEnable){
++                      $location.path('/login');
++                    }
++                    else{
++                      $location.path('/overview/server');
++                    }
++                  }
+                 }
+               }
++            });
++          }
++
++          APIUtils.getServiceStatus().then(
++            function(data) {
++              $rootScope.isWebEnable = data.data.WebService
++              routeChangeStart();
++            },
++            function(error) {
++              console.log(JSON.stringify(error));
++              routeChangeStart();
+             }
+-          });
++          );
++
+           $rootScope.$on('$locationChangeSuccess', function(event) {
+             var path = $location.path();
+             dataService.path = path;
+diff --git a/app/login/controllers/login-controller.html b/app/login/controllers/login-controller.html
+old mode 100644
+new mode 100755
+index e162d8f..618d184
+--- a/app/login/controllers/login-controller.html
++++ b/app/login/controllers/login-controller.html
+@@ -11,6 +11,9 @@
+             <b>Invalid username or password.</b>
+             <br>Please try again.
+           </div>
++          <div class="alert alert-danger" role="alert" ng-if="isDisable">
++            <b>Web service is disabled.</b>
++          </div>
+           <label for="host">BMC Host or BMC IP Address</label>
+           <input type="text" id="host" name="host" class="validate-input" ng-model="host" has-error="serverUnreachable && login__form.host.$pristine" required  autofocus ng-keydown="tryLogin(host, username, password, $event)">
+           <div ng-messages="login__form.host.$error" class="form-error" ng-class="{'visible' : login__form.host.$touched || submitted}">
+diff --git a/app/login/controllers/login-controller.js b/app/login/controllers/login-controller.js
+old mode 100644
+new mode 100755
+index cc0f0b3..10b596c
+--- a/app/login/controllers/login-controller.js
++++ b/app/login/controllers/login-controller.js
+@@ -10,15 +10,18 @@ window.angular && (function(angular) {
+   'use strict';
+ 
+   angular.module('app.login').controller('LoginController', [
++    '$rootScope',
+     '$scope',
+     '$window',
+     'dataService',
+     'userModel',
+     '$location',
+-    function($scope, $window, dataService, userModel, $location) {
++    'APIUtils',
++    function($rootScope, $scope, $window, dataService, userModel, $location, APIUtils) {
+       $scope.dataService = dataService;
+       $scope.serverUnreachable = false;
+       $scope.invalidCredentials = false;
++      $scope.isDisable = false;
+       $scope.host = $scope.dataService.host.replace(/^https?\:\/\//ig, '');
+ 
+       $scope.tryLogin = function(host, username, password, event) {
+@@ -31,6 +34,7 @@ window.angular && (function(angular) {
+       $scope.login = function(host, username, password) {
+         $scope.serverUnreachable = false;
+         $scope.invalidCredentials = false;
++        $scope.isDisable = false;
+         if (!username || username == '' || !password || password == '' ||
+             !host || host == '') {
+           return false;
+@@ -43,7 +47,20 @@ window.angular && (function(angular) {
+               // don't allow forwarding to non-local urls
+               if (next === undefined || next == null ||
+                   next.indexOf(':') >= 0) {
+-                $window.location.hash = '#/overview/server';
++                APIUtils.getServiceStatus().then(
++                  function(data) {
++                    $rootScope.isWebEnable = data.data.WebService
++                    if($rootScope.isWebEnable){
++                      $window.location.hash = '#/overview/server';
++                    }
++                    else{
++                      $scope.isDisable = true;
++                    }
++                  },
++                  function(error) {
++                    console.log(JSON.stringify(error));
++                  }
++                );
+               } else {
+                 $window.location.href = next;
+               }
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0003-Fix-the-page-for-sensors-reading-feature.patch b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0003-Fix-the-page-for-sensors-reading-feature.patch
new file mode 100755
index 0000000..7b491a3
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0003-Fix-the-page-for-sensors-reading-feature.patch
@@ -0,0 +1,137 @@
+From e2576e5776c574e3f53a5ba5fb41a93716b95770 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 5 Oct 2020 16:32:37 +0800
+Subject: [PATCH] Fix the page for sensors reading feature
+
+---
+ app/common/services/api-utils.js      | 33 ++++++++++++++++++++++++++++-----
+ app/common/services/constants.js      |  6 ++++--
+ app/server-health/styles/sensors.scss |  1 +
+ 3 files changed, 33 insertions(+), 7 deletions(-)
+ mode change 100644 => 100755 app/common/services/constants.js
+
+diff --git a/app/common/services/api-utils.js b/app/common/services/api-utils.js
+index 1886c7a..40ab242 100755
+--- a/app/common/services/api-utils.js
++++ b/app/common/services/api-utils.js
+@@ -925,6 +925,7 @@ window.angular && (function(angular) {
+                     var tempKeyParts = [];
+                     var order = 0;
+                     var customOrder = 0;
++                    var unitConvert = '';
+ 
+                     function getSensorStatus(reading) {
+                       var severityFlags = {
+@@ -972,24 +973,45 @@ window.angular && (function(angular) {
+                       };
+                     }
+ 
++                    function convertUnit(unit){
++                      var sensorSortOrder = '';
++                      if(unit.indexOf('temperature')!= -1){
++                        sensorSortOrder = 'xyz.openbmc_project.Sensor.Value.Unit.DegreesC';
++                      } else if(unit.indexOf('fan_tach')!= -1){
++                        sensorSortOrder = 'xyz.openbmc_project.Sensor.Value.Unit.RPMS';
++                      } else if(unit.indexOf('power')!= -1){
++                        sensorSortOrder = 'xyz.openbmc_project.Sensor.Value.Unit.Watts';
++                      } else if(unit.indexOf('voltage')!= -1){
++                        sensorSortOrder = 'xyz.openbmc_project.Sensor.Value.Unit.Volts';
++                      } else if(unit.indexOf('current')!= -1){
++                        sensorSortOrder = 'xyz.openbmc_project.Sensor.Value.Unit.Amperes';
++                      } else if(unit.indexOf('fan_pwm')!= -1){
++                        sensorSortOrder = 'xyz.openbmc_project.Sensor.Value.Unit.Percent';
++                      }
++                      return sensorSortOrder;
++                    }
++
+                     for (var key in content.data) {
+                       if (content.data.hasOwnProperty(key) &&
+-                          content.data[key].hasOwnProperty('Unit')) {
++                          content.data[key].hasOwnProperty('Associations')) {
+                         severity = getSensorStatus(content.data[key]);
+ 
+                         if (!content.data[key].hasOwnProperty('CriticalLow')) {
+                           content.data[key].CriticalLow = '--';
++                        }
++                        if (!content.data[key].hasOwnProperty('CriticalHigh')) {
+                           content.data[key].CriticalHigh = '--';
+                         }
+ 
+                         if (!content.data[key].hasOwnProperty('WarningLow')) {
+                           content.data[key].WarningLow = '--';
++                        }
++                        if (!content.data[key].hasOwnProperty('WarningHigh')) {
+                           content.data[key].WarningHigh = '--';
+                         }
+ 
+                         tempKeyParts = key.split('/');
+                         title = tempKeyParts.pop();
+-                        title = tempKeyParts.pop() + '_' + title;
+                         title = title.split('_')
+                                     .map(function(item) {
+                                       return item.toLowerCase()
+@@ -1000,11 +1022,12 @@ window.angular && (function(angular) {
+                                     .reduce(function(prev, el) {
+                                       return prev + ' ' + el;
+                                     });
++                        unitConvert = convertUnit(tempKeyParts.pop());
+ 
+                         if (Constants.SENSOR_SORT_ORDER.indexOf(
+-                                content.data[key].Unit) > -1) {
++                                unitConvert) > -1) {
+                           customOrder = Constants.SENSOR_SORT_ORDER.indexOf(
+-                              content.data[key].Unit);
++                              unitConvert);
+                         } else {
+                           customOrder = Constants.SENSOR_SORT_ORDER_DEFAULT;
+                         }
+@@ -1018,7 +1041,7 @@ window.angular && (function(angular) {
+                               title: title,
+                               unit:
+                                   Constants
+-                                      .SENSOR_UNIT_MAP[content.data[key].Unit],
++                                      .SENSOR_UNIT_MAP[unitConvert],
+                               severity_flags: severity.flags,
+                               status: severity.severityText,
+                               order: severity.order,
+diff --git a/app/common/services/constants.js b/app/common/services/constants.js
+old mode 100644
+new mode 100755
+index bef2922..25cc43e
+--- a/app/common/services/constants.js
++++ b/app/common/services/constants.js
+@@ -74,7 +74,8 @@ window.angular && (function(angular) {
+         'xyz.openbmc_project.Sensor.Value.Unit.Meters': 'meters',
+         'xyz.openbmc_project.Sensor.Value.Unit.Watts': 'watts',
+         'xyz.openbmc_project.Sensor.Value.Unit.Amperes': 'amperes',
+-        'xyz.openbmc_project.Sensor.Value.Unit.Joules': 'joules'
++        'xyz.openbmc_project.Sensor.Value.Unit.Joules': 'joules',
++        'xyz.openbmc_project.Sensor.Value.Unit.Percent': 'percent'
+       },
+       SERVER_HEALTH: {
+         critical: 'Critical',
+@@ -89,7 +90,8 @@ window.angular && (function(angular) {
+         'xyz.openbmc_project.Sensor.Value.Unit.Volts',
+         'xyz.openbmc_project.Sensor.Value.Unit.Amperes',
+         'xyz.openbmc_project.Sensor.Value.Unit.Joules',
+-        'xyz.openbmc_project.Sensor.Value.Unit.Meters'
++        'xyz.openbmc_project.Sensor.Value.Unit.Meters',
++        'xyz.openbmc_project.Sensor.Value.Unit.Percent'
+       ],
+       SENSOR_SORT_ORDER_DEFAULT: 8,
+       FIRMWARE: {
+diff --git a/app/server-health/styles/sensors.scss b/app/server-health/styles/sensors.scss
+index 6912f04..c846c8e 100644
+--- a/app/server-health/styles/sensors.scss
++++ b/app/server-health/styles/sensors.scss
+@@ -87,6 +87,7 @@ $thresh-normal: $accent-02--02;
+   display: flex;
+   justify-content: space-between;
+   padding: 0.5rem 1rem;
++  overflow: hidden;
+   @include fontCourierBold;
+ 
+   @include mediaQuery(medium) {
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0004-Fix-the-page-for-manage-power-usage.patch b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0004-Fix-the-page-for-manage-power-usage.patch
new file mode 100755
index 0000000..2ef3b0a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0004-Fix-the-page-for-manage-power-usage.patch
@@ -0,0 +1,77 @@
+From 12bd8c51cf328b0b6e9e254ae99a38642c8f2be2 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 6 Oct 2020 10:18:33 +0800
+Subject: [PATCH] Fix the page for manage power usage
+
+---
+ app/common/services/api-utils.js                           | 4 ++--
+ app/server-control/controllers/power-usage-controller.html | 4 ++--
+ app/server-control/controllers/power-usage-controller.js   | 2 +-
+ 3 files changed, 5 insertions(+), 5 deletions(-)
+ mode change 100644 => 100755 app/server-control/controllers/power-usage-controller.html
+ mode change 100644 => 100755 app/server-control/controllers/power-usage-controller.js
+
+diff --git a/app/common/services/api-utils.js b/app/common/services/api-utils.js
+index 40ab242..e7c7bf6 100755
+--- a/app/common/services/api-utils.js
++++ b/app/common/services/api-utils.js
+@@ -1737,7 +1737,7 @@ window.angular && (function(angular) {
+           return $http({
+                    method: 'GET',
+                    url: DataService.getHost() +
+-                       '/xyz/openbmc_project/sensors/power/total_power',
++                       '/xyz/openbmc_project/sensors/power/PSU0_Output_Power',
+                    withCredentials: true
+                  })
+               .then(
+@@ -1746,7 +1746,7 @@ window.angular && (function(angular) {
+                     var content = JSON.parse(json);
+ 
+                     return content.data.Value + ' ' +
+-                        Constants.POWER_CONSUMPTION_TEXT[content.data.Unit];
++                        Constants.POWER_CONSUMPTION_TEXT['xyz.openbmc_project.Sensor.Value.Unit.Watts'];
+                   },
+                   function(error) {
+                     if ('Not Found' == error.statusText) {
+diff --git a/app/server-control/controllers/power-usage-controller.html b/app/server-control/controllers/power-usage-controller.html
+old mode 100644
+new mode 100755
+index 1a2a4b5..bb14467
+--- a/app/server-control/controllers/power-usage-controller.html
++++ b/app/server-control/controllers/power-usage-controller.html
+@@ -52,7 +52,7 @@
+           id="power-cap"
+           type="number"
+           min="100"
+-          max="10000"
++          max="1000"
+           step="1"
+           ng-disabled="!power_cap.PowerCapEnable"
+           ng-model="power_cap.PowerCap"
+@@ -60,7 +60,7 @@
+       </div>
+     </section>
+     <div class="form__actions">
+-      <button type="submit" class="btn-primary" ng-click="setPowerCap()">
++      <button type="button" class="btn-primary" ng-click="setPowerCap()">
+         Save settings
+       </button>
+       <button type="button" class="btn btn-secondary" ng-click="refresh()">
+diff --git a/app/server-control/controllers/power-usage-controller.js b/app/server-control/controllers/power-usage-controller.js
+old mode 100644
+new mode 100755
+index 9398259..ef0aba4
+--- a/app/server-control/controllers/power-usage-controller.js
++++ b/app/server-control/controllers/power-usage-controller.js
+@@ -50,7 +50,7 @@ window.angular && (function(angular) {
+         // The power cap value will be undefined if outside range
+         if (!$scope.power_cap.PowerCap) {
+           toastService.error(
+-              'Power cap value between 100 and 10,000 is required');
++              'Power cap value between 100 and 1,000 is required');
+           return;
+         }
+         $scope.loading = true;
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0005-Disable-unfinished-feature-temporarily.patch b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0005-Disable-unfinished-feature-temporarily.patch
new file mode 100755
index 0000000..9abf2dd
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0005-Disable-unfinished-feature-temporarily.patch
@@ -0,0 +1,128 @@
+From 0a3522128433489d6c19deacc30a0f7a99cdcfc6 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 26 Oct 2020 12:28:43 +0800
+Subject: [PATCH] Disable unfinished feature temporarily
+
+---
+ app/common/directives/app-navigation.html                       | 4 ++--
+ app/configuration/controllers/firmware-controller.html          | 6 +++---
+ app/overview/controllers/system-overview-controller.html        | 4 ++--
+ app/server-control/controllers/power-operations-controller.html | 8 ++++----
+ 4 files changed, 11 insertions(+), 11 deletions(-)
+ mode change 100644 => 100755 app/common/directives/app-navigation.html
+ mode change 100644 => 100755 app/configuration/controllers/firmware-controller.html
+ mode change 100644 => 100755 app/overview/controllers/system-overview-controller.html
+ mode change 100644 => 100755 app/server-control/controllers/power-operations-controller.html
+
+diff --git a/app/common/directives/app-navigation.html b/app/common/directives/app-navigation.html
+old mode 100644
+new mode 100755
+index 41441e2..a77cab6
+--- a/app/common/directives/app-navigation.html
++++ b/app/common/directives/app-navigation.html
+@@ -89,11 +89,11 @@
+         <li ng-class="{'active': (path == '/configuration' || path == '/configuration/firmware')}">
+           <a href="#/configuration/firmware" tabindex="{{(showConfigMenu) ? 0 : -1}}"><span>Firmware</span></a>
+         </li>
+-        <li ng-class="{'active': (path == '/configuration' || path == '/configuration/date-time')}">
++        <!-- <li ng-class="{'active': (path == '/configuration' || path == '/configuration/date-time')}">
+           <a href="#/configuration/date-time" tabindex="{{(showConfigMenu) ? 0 : -1}}"><span>Date and
+               time
+               settings</span></a>
+-        </li>
++        </li> -->
+       </ul>
+     </li>
+     <li ng-class="{opened: showAccessMenu}">
+diff --git a/app/configuration/controllers/firmware-controller.html b/app/configuration/controllers/firmware-controller.html
+old mode 100644
+new mode 100755
+index d2ff89d..7148f5c
+--- a/app/configuration/controllers/firmware-controller.html
++++ b/app/configuration/controllers/firmware-controller.html
+@@ -16,7 +16,7 @@
+     <h2 class="inline bold">Specify image file location</h2>
+   </div>
+   <form id="firmware__upload-form" role="form" class="firmware__upload-form">
+-    <p>Specify an image file located on your workstation or a TFTP server. An image file may contain firmware images for the server, BMC, or other hardware devices. Each image that you upload will be unpacked from the image file and added to the appropriate list above.</p>
++    <p>Specify an image file located on your workstation. An image file may contain firmware images for the server, BMC, or other hardware devices. Each image that you upload will be unpacked from the image file and added to the appropriate list above.</p>
+     <div class=" column firmware__upload-station">
+       <h3>Upload image file from workstation</h3>
+       <p>Select the image file saved on the workstation storage medium to upload to the server BMC.</p>
+@@ -28,7 +28,7 @@
+       <input type="button" value="Upload firmware" class="btn btn-primary float-right" ng-click="upload()"/>
+       <div class="inline uploading" ng-show="uploading">Upload in progress...</div>
+     </div>
+-    <div class="column firmware__upload-tftp">
++    <!-- <div class="column firmware__upload-tftp">
+       <h3>Download image file from TFTP server</h3>
+       <p>Specify both the TFTP server IP address and the image file name stored on it to download to the server BMC.</p>
+       <fieldset>
+@@ -47,7 +47,7 @@
+         </div>
+         <div class="inline uploading" ng-show="downloading">Downloading in progress...</div>
+       </fieldset>
+-    </div>
++    </div> -->
+   </form>
+ </div>
+ 
+diff --git a/app/overview/controllers/system-overview-controller.html b/app/overview/controllers/system-overview-controller.html
+old mode 100644
+new mode 100755
+index b60d510..a745f19
+--- a/app/overview/controllers/system-overview-controller.html
++++ b/app/overview/controllers/system-overview-controller.html
+@@ -6,7 +6,7 @@
+   </button>
+   <div class="row">
+     <div class="small-12 large-8">
+-      <section class="section">
++      <!-- <section class="section">
+         <div class="section-header">
+           <h2 class="section-title h3">Server information</h2>
+         </div>
+@@ -32,7 +32,7 @@
+             </dl>
+           </div>
+         </div>
+-      </section>
++      </section> -->
+ 
+       <section class="section">
+         <div class="section-header">
+diff --git a/app/server-control/controllers/power-operations-controller.html b/app/server-control/controllers/power-operations-controller.html
+old mode 100644
+new mode 100755
+index 222ffb7..70ed575
+--- a/app/server-control/controllers/power-operations-controller.html
++++ b/app/server-control/controllers/power-operations-controller.html
+@@ -64,13 +64,13 @@
+           </div>
+         </div>
+           <!-- TPM Required -->
+-          <div class="boot-options one-time-boot-setting">
++          <!-- <div class="boot-options one-time-boot-setting">
+             <div class="boot-options">
+               <h3 class="content-label">
+                 TPM required policy</h3>
+-              <p> Enable to ensure the system only boots when the TPM is functional. </p>
++              <p> Enable to ensure the system only boots when the TPM is functional. </p> -->
+               <!-- Toggle component -->
+-              <div class="toggle-container">
++              <!-- <div class="toggle-container">
+                   <div class="toggle">
+                     <input
+                       id="toggle__switch-round"
+@@ -90,7 +90,7 @@
+                   </span>
+                 </div>
+             </div>
+-          </div>
++          </div> -->
+           <!-- form actions -->
+           <div class="boot-form-actions">
+             <button type="submit" class="btn btn-primary" ng-click="saveBootSettings();saveTPMPolicy();hostBootSettings.$setPristine()" ng-disabled="dataService.server_unreachable || hostBootSettings.$pristine;">
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0006-Fix-the-page-for-server-information-and-hardware-sta.patch b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0006-Fix-the-page-for-server-information-and-hardware-sta.patch
new file mode 100755
index 0000000..72de452
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0006-Fix-the-page-for-server-information-and-hardware-sta.patch
@@ -0,0 +1,116 @@
+From 76d911d4517b45fe8213c4c4c178e78b8fe85983 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Mon, 12 Oct 2020 15:54:04 +0800
+Subject: [PATCH] Fix the page for server information and hardware status
+ feature
+
+---
+ app/common/services/api-utils.js                         |  7 ++++++-
+ app/common/services/dataService.js                       | 10 ++++++++++
+ app/overview/controllers/system-overview-controller.html | 14 +++++++-------
+ 3 files changed, 23 insertions(+), 8 deletions(-)
+ mode change 100644 => 100755 app/common/services/dataService.js
+
+diff --git a/app/common/services/api-utils.js b/app/common/services/api-utils.js
+index e7c7bf6..5f10d1d 100755
+--- a/app/common/services/api-utils.js
++++ b/app/common/services/api-utils.js
+@@ -1278,7 +1278,8 @@ window.angular && (function(angular) {
+           return $http({
+                    method: 'GET',
+                    url: DataService.getHost() +
+-                       '/xyz/openbmc_project/inventory/system',
++                       '/xyz/openbmc_project/inventory/system' +
++                       DataService.getSystemInformation(),
+                    withCredentials: true
+                  })
+               .then(function(response) {
+@@ -1559,6 +1560,10 @@ window.angular && (function(angular) {
+                 searchText = getSearchText(data);
+                 title = key.split('/').pop();
+                 title = titlelize(title);
++
++                if(title == 'system'){
++                  continue;
++                }
+                 // e.g. /xyz/openbmc_project/inventory/system and
+                 // /xyz/openbmc_project/inventory/system/chassis are depths of 5
+                 // and 6.
+diff --git a/app/common/services/dataService.js b/app/common/services/dataService.js
+old mode 100644
+new mode 100755
+index 87fddba..4ae93a2
+--- a/app/common/services/dataService.js
++++ b/app/common/services/dataService.js
+@@ -32,6 +32,7 @@ window.angular && (function(angular) {
+       this.systemName = '';
+ 
+       this.configJson = require('../../../config.json');
++      this.platformConfigJSON = require('../../../platform-config.json');
+ 
+       this.getServerId = function() {
+         return this.host.replace(/^https?\:\/\//ig, '');
+@@ -110,6 +111,15 @@ window.angular && (function(angular) {
+       this.setSystemName = function(sysName) {
+         this.systemName = sysName;
+       };
++
++      this.getSystemInformation= function() {
++        if(this.platformConfigJSON.systemName && this.platformConfigJSON.systemType){
++          return '/' + this.platformConfigJSON.systemType + '/' + this.platformConfigJSON.systemName;
++        } else {
++          return '';
++        }
++      }
++
+     }
+   ]);
+ })(window.angular);
+diff --git a/app/overview/controllers/system-overview-controller.html b/app/overview/controllers/system-overview-controller.html
+index a745f19..e880c1b 100755
+--- a/app/overview/controllers/system-overview-controller.html
++++ b/app/overview/controllers/system-overview-controller.html
+@@ -6,7 +6,7 @@
+   </button>
+   <div class="row">
+     <div class="small-12 large-8">
+-      <!-- <section class="section">
++      <section class="section">
+         <div class="section-header">
+           <h2 class="section-title h3">Server information</h2>
+         </div>
+@@ -14,25 +14,25 @@
+           <div class="column large-6">
+             <dl class="list-pair">
+               <dt>Model</dt>
+-              <dd>{{ server_info.Model  || "N/A"  }}</dd>
++              <dd>{{ server_info.BoardProduct  || "N/A"  }}</dd>
+             </dl>
+             <dl class="list-pair">
+               <dt>Serial number</dt>
+-              <dd>{{ server_info.SerialNumber || "N/A"  }}</dd>
++              <dd>{{ server_info.BoardSerial || "N/A"  }}</dd>
+             </dl>
+           </div>
+           <div class="column large-6">
+             <dl class="list-pair">
+               <dt>Manufacturer</dt>
+-              <dd>{{ server_info.Manufacturer || "N/A" }}</dd>
++              <dd>{{ server_info.BoardMfg || "N/A" }}</dd>
+             </dl>
+-            <dl class="list-pair">
++            <!-- <dl class="list-pair">
+               <dt>Firmware version</dt>
+               <dd>{{ server_firmware }}</dd>
+-            </dl>
++            </dl> -->
+           </div>
+         </div>
+-      </section> -->
++      </section>
+ 
+       <section class="section">
+         <div class="section-header">
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0007-Fix-the-page-for-system-logs-feature.patch b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0007-Fix-the-page-for-system-logs-feature.patch
new file mode 100755
index 0000000..a649c7e
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0007-Fix-the-page-for-system-logs-feature.patch
@@ -0,0 +1,69 @@
+From aa10e03118b3e8fb31e292608f6799766b688b63 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Tue, 27 Oct 2020 14:28:14 +0800
+Subject: [PATCH] Fix the page for system logs feature
+
+---
+ app/common/services/api-utils.js                     | 8 ++++++--
+ app/server-health/controllers/syslog-controller.html | 4 ++--
+ 2 files changed, 8 insertions(+), 4 deletions(-)
+ mode change 100644 => 100755 app/server-health/controllers/syslog-controller.html
+
+diff --git a/app/common/services/api-utils.js b/app/common/services/api-utils.js
+index 5f10d1d..d341607 100755
+--- a/app/common/services/api-utils.js
++++ b/app/common/services/api-utils.js
+@@ -43,7 +43,7 @@ window.angular && (function(angular) {
+               '/LogServices/EventLog/Entries';
+           if (recordType == 'Oem') {
+             var uri = '/redfish/v1/Systems/' + DataService.systemName +
+-                '/LogServices/Crashdump/Entries';
++                '/LogServices/EventLog/Entries';
+           }
+           return $http({
+                    method: 'GET',
+@@ -53,9 +53,13 @@ window.angular && (function(angular) {
+               .then(
+                   function(response) {
+                     var logEntries = [];
++
+                     angular.forEach(response.data['Members'], function(log) {
+                       if (log.hasOwnProperty('EntryType')) {
+                         if (log['EntryType'] == recordType) {
++                          if (log.hasOwnProperty('@odata.type')) {
++                            log["@odata.type"] = log["@odata.type"].replace('#', '');
++                          }
+                           logEntries.push(log);
+                         }
+                       }
+@@ -71,7 +75,7 @@ window.angular && (function(angular) {
+               '/LogServices/EventLog/Actions/LogService.ClearLog';
+           if (selectedRecordType == 'Oem') {
+             var uri = '/redfish/v1/Systems/' + DataService.systemName +
+-                '/LogServices/Crashdump/Actions/LogService.ClearLog';
++                '/LogServices/EventLog/Actions/LogService.ClearLog';
+           }
+           return $http({
+             method: 'POST',
+diff --git a/app/server-health/controllers/syslog-controller.html b/app/server-health/controllers/syslog-controller.html
+old mode 100644
+new mode 100755
+index 11918bb..2270638
+--- a/app/server-health/controllers/syslog-controller.html
++++ b/app/server-health/controllers/syslog-controller.html
+@@ -14,10 +14,10 @@
+             </ul>
+           </div>
+           <a ng-href="data:text/json;charset=utf-8,{{sysLogs}}" class="inline btn-export float-right"  download="systemLogs.json" ng-show="sysLogs.length">Export </a>
+-          <button class="inline clear-input float-right btn-secondary" ng-click="confirm = !confirm" ng-show="sysLogs.length">&#10005; Clear {{selectedRecordType}} Logs</button>
++          <button class="inline clear-input float-right btn-secondary" ng-click="confirm = !confirm" ng-show="selectedType.length">&#10005; Clear {{selectedType}} Logs</button>
+           <div class="inline__confirm sys-log__confirm" ng-show="confirm">
+             <div class="inline__confirm-message">
+-              <p class="h3">Are you sure you want to <strong class="ng-binding">clear {{selectedRecordType}} logs</strong>?
++              <p class="h3">Are you sure you want to <strong class="ng-binding">clear {{selectedType}} logs</strong>?
+               </p>
+             </div>
+             <div class="inline__confirm-buttons">
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0008-Fix-the-page-for-firmware-feature.patch b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0008-Fix-the-page-for-firmware-feature.patch
new file mode 100755
index 0000000..8a3f6f6
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0008-Fix-the-page-for-firmware-feature.patch
@@ -0,0 +1,120 @@
+From 7cf9800df0f929e9044b12ecbd1e62ea941a12c7 Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 4 Nov 2020 11:01:59 +0800
+Subject: [PATCH] Fix the page for firmware feature
+
+---
+ app/common/directives/firmware-list.html              |  0
+ .../controllers/firmware-controller.html              |  6 +++---
+ app/configuration/controllers/firmware-controller.js  | 19 ++++++++++++++++---
+ 3 files changed, 19 insertions(+), 6 deletions(-)
+ mode change 100644 => 100755 app/common/directives/firmware-list.html
+ mode change 100644 => 100755 app/configuration/controllers/firmware-controller.js
+
+diff --git a/app/common/directives/firmware-list.html b/app/common/directives/firmware-list.html
+old mode 100644
+new mode 100755
+diff --git a/app/configuration/controllers/firmware-controller.html b/app/configuration/controllers/firmware-controller.html
+index 7148f5c..47c2c75 100755
+--- a/app/configuration/controllers/firmware-controller.html
++++ b/app/configuration/controllers/firmware-controller.html
+@@ -121,17 +121,17 @@
+       <form ng-if="activate_image_type == 'Host'">
+         <fieldset>
+           <div class="row column">
+-            <label class="control-radio bold" for="activate-host-without-reboot">Activate firmware file without {{isServerOff() ? "booting" : "rebooting"}} server
++            <label class="control-radio bold" for="activate-host-without-reboot">Activate firmware file without {{isServerOff() ? "booting" : "rebooting"}} server via web
+               <input type="radio" name="activate-host-without-reboot" id="activate-host-without-reboot" ng-model="activate.reboot" ng-value="false"/>
+               <span class="control__indicator control__indicator-on"></span>
+             </label>
+           </div>
+-          <div class="row column">
++          <!-- <div class="row column">
+             <label class="control-radio bold" for="activate-host-with-reboot">Activate firmware file and automatically {{isServerOff() ? "boot" : "reboot"}} server
+               <input type="radio" name="activate-host-with-reboot" id="activate-host-with-reboot" ng-model="activate.reboot" ng-value="true"/>
+               <span class="control__indicator control__indicator-on"></span>
+             </label>
+-          </div>
++          </div> -->
+         </fieldset>
+       </form>
+     </div>
+diff --git a/app/configuration/controllers/firmware-controller.js b/app/configuration/controllers/firmware-controller.js
+old mode 100644
+new mode 100755
+index 451c16c..72cdcf8
+--- a/app/configuration/controllers/firmware-controller.js
++++ b/app/configuration/controllers/firmware-controller.js
+@@ -10,10 +10,10 @@ window.angular && (function(angular) {
+   'use strict';
+ 
+   angular.module('app.configuration').controller('firmwareController', [
+-    '$scope', '$window', 'APIUtils', 'dataService', '$location',
++    '$scope', '$window', 'APIUtils', '$route', 'dataService', '$location',
+     '$anchorScroll', 'Constants', '$interval', '$q', '$timeout', 'toastService',
+     function(
+-        $scope, $window, APIUtils, dataService, $location, $anchorScroll,
++        $scope, $window, APIUtils, $route, dataService, $location, $anchorScroll,
+         Constants, $interval, $q, $timeout, toastService) {
+       $scope.dataService = dataService;
+ 
+@@ -27,6 +27,7 @@ window.angular && (function(angular) {
+       $scope.bmcActiveVersion = '';
+       $scope.hostActiveVersion = '';
+       $scope.activate_confirm = false;
++      $scope.activate_finish = true;
+       $scope.delete_image_id = '';
+       $scope.delete_image_version = '';
+       $scope.activate_image_id = '';
+@@ -60,6 +61,7 @@ window.angular && (function(angular) {
+           APIUtils.getActivation(imageId).then(
+               function(state) {
+                 let imageStateActive = (/\.Active$/).test(state.data);
++                let imageStateReady = (/\.Ready$/).test(state.data);
+                 let imageStateFailed = (/\.Failed$/).test(state.data);
+                 if (imageStateActive || imageStateFailed) {
+                   $interval.cancel(pollActivationTimer);
+@@ -67,6 +69,16 @@ window.angular && (function(angular) {
+                 }
+                 if (imageStateActive) {
+                   deferred.resolve(state);
++                  if(!$scope.activate_finish){
++                    toastService.success('Image success to activate.');
++                    $scope.activate_finish = true;
++                  }
++                } else if (imageStateReady) {
++                  deferred.resolve(state);
++                  if(!$scope.activate_finish){
++                    toastService.success('Image success to activate.');
++                    $scope.activate_finish = true;
++                  }
+                 } else if (imageStateFailed) {
+                   console.log('Image failed to activate: ', imageStateFailed);
+                   toastService.error('Image failed to activate.');
+@@ -139,6 +151,7 @@ window.angular && (function(angular) {
+                   });
+             });
+         $scope.activate_confirm = false;
++        $scope.activate_finish = false;
+       };
+       function powerOn() {
+         dataService.setUnreachableState();
+@@ -155,7 +168,6 @@ window.angular && (function(angular) {
+             });
+       };
+       function warmReboot() {
+-        $scope.uploading = true;
+         dataService.setUnreachableState();
+         APIUtils.hostReboot()
+             .then(function(response) {
+@@ -186,6 +198,7 @@ window.angular && (function(angular) {
+                         '" has been uploaded');
+                     $scope.file = '';
+                     $scope.loadFirmwares();
++                    $route.reload();
+                   },
+                   function(error) {
+                     $scope.uploading = false;
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0009-Fix-the-page-for-local-user-management-feature.patch b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0009-Fix-the-page-for-local-user-management-feature.patch
new file mode 100755
index 0000000..50e6aee
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/0009-Fix-the-page-for-local-user-management-feature.patch
@@ -0,0 +1,37 @@
+From 39180a80f9439dc2dcfe840f9cbc3e4baf3cd85e Mon Sep 17 00:00:00 2001
+From: John Chung <john.chung@mic.com.tw>
+Date: Wed, 4 Nov 2020 15:52:47 +0800
+Subject: [PATCH] Fix the page for local user management feature
+
+---
+ app/access-control/controllers/user-accounts-modal-user.html | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+ mode change 100644 => 100755 app/access-control/controllers/user-accounts-modal-user.html
+
+diff --git a/app/access-control/controllers/user-accounts-modal-user.html b/app/access-control/controllers/user-accounts-modal-user.html
+old mode 100644
+new mode 100755
+index d718dcd..643744f
+--- a/app/access-control/controllers/user-accounts-modal-user.html
++++ b/app/access-control/controllers/user-accounts-modal-user.html
+@@ -64,7 +64,7 @@
+                      name="username"
+                      type="text"
+                      required
+-                     minlength="1"
++                     minlength="5"
+                      maxlength="16"
+                      ng-pattern="'^([a-zA-Z_][a-zA-Z0-9_]*)'"
+                      ng-readonly="modalCtrl.user.isRoot"
+@@ -75,7 +75,7 @@
+                 <span ng-show="form.username.$error.required">
+                   Field is required</span>
+                 <span ng-show="form.username.$error.minlength || form.username.$error.maxlength">
+-                  Length must be between <span class="nowrap">1  16</span> characters</span>
++                  Length must be between <span class="nowrap">5  16</span> characters</span>
+                 <span ng-show="form.username.$error.pattern">
+                   Invalid format</span>
+                 <span ng-show="form.username.$error.duplicateUsername">
+-- 
+2.7.4
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/config.json b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/config.json
new file mode 100755
index 0000000..1543a62
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/config.json
@@ -0,0 +1,8 @@
+{
+  "customKeyEnable": true,
+  "keyType" : "VT100+",
+  "customConsoleDisplaySize": {
+    "width": 100,
+    "height": 32
+  }
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/platform-config.json b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/platform-config.json
new file mode 100755
index 0000000..cd2482a
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui/platform-config.json
@@ -0,0 +1,4 @@
+{
+  "systemName" : "s5549_Baseboard",
+  "systemType" : "board"
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui_git.bbappend b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui_git.bbappend
new file mode 100755
index 0000000..f88774f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/webui/phosphor-webui_git.bbappend
@@ -0,0 +1,15 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
+
+SRCREV = "0c4aceb775cbb461d10e03888f0ab90e5a619dc7"
+
+SRC_URI += "file://platform-config.json;subdir=git/ \
+            file://0002-Implement-the-feature-for-setting-web-status-to-enab.patch \
+            file://0003-Fix-the-page-for-sensors-reading-feature.patch \
+            file://0004-Fix-the-page-for-manage-power-usage.patch \
+            file://0005-Disable-unfinished-feature-temporarily.patch \
+            file://0006-Fix-the-page-for-server-information-and-hardware-sta.patch \
+            file://0007-Fix-the-page-for-system-logs-feature.patch \
+            file://0008-Fix-the-page-for-firmware-feature.patch \
+            file://0009-Fix-the-page-for-local-user-management-feature.patch \
+"
+
diff --git a/meta-mct/meta-s5549/recipes-phosphor/workbook/s5549-config/s5549.py b/meta-mct/meta-s5549/recipes-phosphor/workbook/s5549-config/s5549.py
new file mode 100755
index 0000000..59ecf8f
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/workbook/s5549-config/s5549.py
@@ -0,0 +1,46 @@
+## System states
+
+##   state can change to next state in 2 ways:
+##   - a process emits a GotoSystemState signal with state name to goto
+##   - objects specified in EXIT_STATE_DEPEND have started
+SYSTEM_STATES = [
+    'BASE_APPS',
+    'BMC_STARTING',
+    'BMC_READY',
+    'HOST_POWERING_ON',
+    'HOST_POWERED_ON',
+    'HOST_BOOTING',
+    'HOST_BOOTED',
+    'HOST_POWERED_OFF',
+]
+
+EXIT_STATE_DEPEND = {
+    '<inventory_root>/system/chassis/motherboard/bmc' : { 'fru_type' : 'BMC','is_fru' : False, 'manufacturer' : 'ASPEED' },
+    'BASE_APPS' : {
+        '/xyz/openbmc_poroject/sensors': 0,
+    },
+    'BMC_STARTING' : {
+        '/xyz/openbmc_project/control/chassis0': 0,
+    },
+}
+
+FRU_INSTANCES = {
+        '<inventory_root>/system/chassis/motherboard/bmc' : { 'fru_type' : 'BMC','is_fru' : False, 'manufacturer' : 'ASPEED' },
+}
+
+# I believe these numbers need to match the yaml file used to create the c++ ipmi map.
+# the devices have types, but I don't believe that factors in here, I think these are
+# just unique IDs.
+ID_LOOKUP = {
+    'FRU' : {},
+    # The number at the end needs to match the FRU ID.
+    # https://github.com/openbmc/skeleton/blob/master/pysystemmgr/system_manager.py#L143
+    # The parameter for it is of type 'y' (unsigned 8-bit integer) presumably decimal?
+    'FRU_STR' : {},
+    'SENSOR' : {},
+    'GPIO_PRESENT' : {}
+}
+
+PCH_CONFIG = {
+    'i2c_bus' : '5'
+}
diff --git a/meta-mct/meta-s5549/recipes-phosphor/workbook/s5549-config_git.bb b/meta-mct/meta-s5549/recipes-phosphor/workbook/s5549-config_git.bb
new file mode 100755
index 0000000..2720c4d
--- /dev/null
+++ b/meta-mct/meta-s5549/recipes-phosphor/workbook/s5549-config_git.bb
@@ -0,0 +1,38 @@
+SUMMARY = "S5549 board wiring"
+DESCRIPTION = "Board wiring information for the S5549 system."
+PR = "r1"
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://${MCTBASE}/COPYING.apache-2.0;md5=34400b68072d710fecd0a2940a0d1658"
+
+inherit allarch
+inherit setuptools
+inherit pythonnative
+
+PROVIDES += "virtual/obmc-inventory-data"
+RPROVIDES_${PN} += "virtual-obmc-inventory-data"
+
+DEPENDS += "python"
+
+S = "${WORKDIR}"
+SRC_URI += "file://s5549.py"
+
+# the following is unnecessary.
+python() {
+    machine = d.getVar('MACHINE', True) + '.py'
+    d.setVar('_config_in_skeleton', machine)
+}
+
+do_make_setup() {
+        cp ${S}/${_config_in_skeleton} \
+                ${S}/obmc_system_config.py
+        cat <<EOF > ${S}/setup.py
+from distutils.core import setup
+
+setup(name='${BPN}',
+    version='${PR}',
+    py_modules=['obmc_system_config'],
+    )
+EOF
+}
+
+addtask make_setup after do_patch before do_configure
-- 
2.7.4

